

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LTO Visibility &mdash; Clang 8 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="Clang 8 documentation" href="index.html" />
    <link rel="next" title="SafeStack" href="SafeStack.html" />
    <link rel="prev" title="Control Flow Integrity Design Documentation" href="ControlFlowIntegrityDesign.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Clang 8 documentation</span></a></h1>
        <h2 class="heading"><span>LTO Visibility</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="ControlFlowIntegrityDesign.html">Control Flow Integrity Design Documentation</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="SafeStack.html">SafeStack</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="lto-visibility">
<h1>LTO Visibility<a class="headerlink" href="#lto-visibility" title="Permalink to this headline">¶</a></h1>
<p><em>LTO visibility</em> is a property of an entity that specifies whether it can be
referenced from outside the current LTO unit. A <em>linkage unit</em> is a set of
translation units linked together into an executable or DSO, and a linkage
unit&#8217;s <em>LTO unit</em> is the subset of the linkage unit that is linked together
using link-time optimization; in the case where LTO is not being used, the
linkage unit&#8217;s LTO unit is empty. Each linkage unit has only a single LTO unit.</p>
<p>The LTO visibility of a class is used by the compiler to determine which
classes the whole-program devirtualization (<tt class="docutils literal"><span class="pre">-fwhole-program-vtables</span></tt>) and
control flow integrity (<tt class="docutils literal"><span class="pre">-fsanitize=cfi-vcall</span></tt> and <tt class="docutils literal"><span class="pre">-fsanitize=cfi-mfcall</span></tt>)
features apply to. These features use whole-program information, so they
require the entire class hierarchy to be visible in order to work correctly.</p>
<p>If any translation unit in the program uses either of the whole-program
devirtualization or control flow integrity features, it is effectively an ODR
violation to define a class with hidden LTO visibility in multiple linkage
units. A class with public LTO visibility may be defined in multiple linkage
units, but the tradeoff is that the whole-program devirtualization and
control flow integrity features can only be applied to classes with hidden LTO
visibility. A class&#8217;s LTO visibility is treated as an ODR-relevant property
of its definition, so it must be consistent between translation units.</p>
<p>In translation units built with LTO, LTO visibility is based on the
class&#8217;s symbol visibility as expressed at the source level (i.e. the
<tt class="docutils literal"><span class="pre">__attribute__((visibility(&quot;...&quot;)))</span></tt> attribute, or the <tt class="docutils literal"><span class="pre">-fvisibility=</span></tt>
flag) or, on the Windows platform, the dllimport and dllexport attributes. When
targeting non-Windows platforms, classes with a visibility other than hidden
visibility receive public LTO visibility. When targeting Windows, classes
with dllimport or dllexport attributes receive public LTO visibility. All
other classes receive hidden LTO visibility. Classes with internal linkage
(e.g. classes declared in unnamed namespaces) also receive hidden LTO
visibility.</p>
<p>A class defined in a translation unit built without LTO receives public
LTO visibility regardless of its object file visibility, linkage or other
attributes.</p>
<p>This mechanism will produce the correct result in most cases, but there are
two cases where it may wrongly infer hidden LTO visibility.</p>
<ol class="arabic simple">
<li>As a corollary of the above rules, if a linkage unit is produced from a
combination of LTO object files and non-LTO object files, any hidden
visibility class defined in both a translation unit built with LTO and
a translation unit built without LTO must be defined with public LTO
visibility in order to avoid an ODR violation.</li>
<li>Some ABIs provide the ability to define an abstract base class without
visibility attributes in multiple linkage units and have virtual calls
to derived classes in other linkage units work correctly. One example of
this is COM on Windows platforms. If the ABI allows this, any base class
used in this way must be defined with public LTO visibility.</li>
</ol>
<p>Classes that fall into either of these categories can be marked up with the
<tt class="docutils literal"><span class="pre">[[clang::lto_visibility_public]]</span></tt> attribute. To specifically handle the
COM case, classes with the <tt class="docutils literal"><span class="pre">__declspec(uuid())</span></tt> attribute receive public
LTO visibility. On Windows platforms, clang-cl&#8217;s <tt class="docutils literal"><span class="pre">/MT</span></tt> and <tt class="docutils literal"><span class="pre">/MTd</span></tt>
flags statically link the program against a prebuilt standard library;
these flags imply public LTO visibility for every class declared in the
<tt class="docutils literal"><span class="pre">std</span></tt> and <tt class="docutils literal"><span class="pre">stdext</span></tt> namespaces.</p>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>The following example shows how LTO visibility works in practice in several
cases involving two linkage units, <tt class="docutils literal"><span class="pre">main</span></tt> and <tt class="docutils literal"><span class="pre">dso.so</span></tt>.</p>
<div class="highlight-none"><div class="highlight"><pre>+-----------------------------------------------------------+  +----------------------------------------------------+
| main (clang++ -fvisibility=hidden):                       |  | dso.so (clang++ -fvisibility=hidden):              |
|                                                           |  |                                                    |
|  +-----------------------------------------------------+  |  |  struct __attribute__((visibility(&quot;default&quot;))) C { |
|  | LTO unit (clang++ -fvisibility=hidden -flto):       |  |  |    virtual void f();                               |
|  |                                                     |  |  |  }                                                 |
|  |  struct A { ... };                                  |  |  |  void C::f() {}                                    |
|  |  struct [[clang::lto_visibility_public]] B { ... }; |  |  |  struct D {                                        |
|  |  struct __attribute__((visibility(&quot;default&quot;))) C {  |  |  |    virtual void g() = 0;                           |
|  |    virtual void f();                                |  |  |  };                                                |
|  |  };                                                 |  |  |  struct E : D {                                    |
|  |  struct [[clang::lto_visibility_public]] D {        |  |  |    virtual void g() { ... }                        |
|  |    virtual void g() = 0;                            |  |  |  };                                                |
|  |  };                                                 |  |  |  __attribute__(visibility(&quot;default&quot;))) D *mkE() {  |
|  |                                                     |  |  |    return new E;                                   |
|  +-----------------------------------------------------+  |  |  }                                                 |
|                                                           |  |                                                    |
|  struct B { ... };                                        |  +----------------------------------------------------+
|                                                           |
+-----------------------------------------------------------+
</pre></div>
</div>
<p>We will now describe the LTO visibility of each of the classes defined in
these linkage units.</p>
<p>Class <tt class="docutils literal"><span class="pre">A</span></tt> is not defined outside of <tt class="docutils literal"><span class="pre">main</span></tt>&#8216;s LTO unit, so it can have
hidden LTO visibility. This is inferred from the object file visibility
specified on the command line.</p>
<p>Class <tt class="docutils literal"><span class="pre">B</span></tt> is defined in <tt class="docutils literal"><span class="pre">main</span></tt>, both inside and outside its LTO unit. The
definition outside the LTO unit has public LTO visibility, so the definition
inside the LTO unit must also have public LTO visibility in order to avoid
an ODR violation.</p>
<p>Class <tt class="docutils literal"><span class="pre">C</span></tt> is defined in both <tt class="docutils literal"><span class="pre">main</span></tt> and <tt class="docutils literal"><span class="pre">dso.so</span></tt> and therefore must
have public LTO visibility. This is correctly inferred from the <tt class="docutils literal"><span class="pre">visibility</span></tt>
attribute.</p>
<p>Class <tt class="docutils literal"><span class="pre">D</span></tt> is an abstract base class with a derived class <tt class="docutils literal"><span class="pre">E</span></tt> defined
in <tt class="docutils literal"><span class="pre">dso.so</span></tt>.  This is an example of the COM scenario; the definition of
<tt class="docutils literal"><span class="pre">D</span></tt> in <tt class="docutils literal"><span class="pre">main</span></tt>&#8216;s LTO unit must have public LTO visibility in order to be
compatible with the definition of <tt class="docutils literal"><span class="pre">D</span></tt> in <tt class="docutils literal"><span class="pre">dso.so</span></tt>, which is observable
by calling the function <tt class="docutils literal"><span class="pre">mkE</span></tt>.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="ControlFlowIntegrityDesign.html">Control Flow Integrity Design Documentation</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="SafeStack.html">SafeStack</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2007-2019, The Clang Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
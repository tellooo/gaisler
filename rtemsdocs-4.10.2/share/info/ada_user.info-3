This is ada_user.info, produced by makeinfo version 4.13 from
ada_user.texi.

INFO-DIR-SECTION RTEMS On-Line Manual
START-INFO-DIR-ENTRY
* RTEMS Ada User: (ada_user).          The Ada User's Guide
END-INFO-DIR-ENTRY


File: ada_user.info,  Node: Multiprocessing Manager Global Object Table,  Next: Multiprocessing Manager Remote Operations,  Prev: Multiprocessing Manager Global Objects,  Up: Multiprocessing Manager Background

24.2.3 Global Object Table
--------------------------

RTEMS maintains two tables containing object information on every node
in a multiprocessor system: a local object table and a global object
table.  The local object table on each node is unique and contains
information for all objects created on this node whether those objects
are local or global.  The global object table contains information
regarding all global objects in the system and, consequently, is the
same on every node.

Since each node must maintain an identical copy of the global object
table,  the maximum number of entries in each copy of the table must be
the same.  The maximum number of entries in each copy is determined by
the maximum_global_objects parameter in the Multiprocessor
Configuration Table.  This parameter, as well as the maximum_nodes
parameter, is required to be the same on all nodes.  To maintain
consistency among the table copies, every node in the system must be
informed of the creation or deletion of a global object.


File: ada_user.info,  Node: Multiprocessing Manager Remote Operations,  Next: Multiprocessing Manager Proxies,  Prev: Multiprocessing Manager Global Object Table,  Up: Multiprocessing Manager Background

24.2.4 Remote Operations
------------------------

When an application performs an operation on a remote global object,
RTEMS must generate a Remote Request (RQ) message and send it to the
appropriate node.  After completing the requested operation, the remote
node will build a Remote Response (RR) message and send it to the
originating node.  Messages generated as a side-effect of a directive
(such as deleting a global task) are known as Remote Processes (RP) and
do not require the receiving node to respond.

Other than taking slightly longer to execute directives on remote
objects, the application is unaware of the location of the objects it
acts upon.  The exact amount of overhead required for a remote
operation is dependent on the media connecting the nodes and, to a
lesser degree, on the efficiency of the user-provided MPCI routines.

The following shows the typical transaction sequence during a remote
application:

  1. The application issues a directive accessing a remote global
     object.

  2. RTEMS determines the node on which the object resides.

  3. RTEMS calls the user-provided MPCI routine GET_PACKET to obtain a
     packet in which to build a RQ message.

  4. After building a message packet, RTEMS calls the user-provided
     MPCI routine SEND_PACKET to transmit the packet to the node on
     which the object resides (referred to as the destination node).

  5. The calling task is blocked until the RR message arrives, and
     control of the processor is transferred to another task.

  6. The MPCI layer on the destination node senses the arrival of a
     packet (commonly in an ISR), and calls the
     `rtems_multiprocessing_announce' directive.  This directive
     readies the Multiprocessing Server.

  7. The Multiprocessing Server calls the user-provided MPCI routine
     RECEIVE_PACKET, performs the requested operation, builds an RR
     message, and returns it to the originating node.

  8. The MPCI layer on the originating node senses the arrival of a
     packet (typically via an interrupt), and calls the RTEMS
     `rtems_multiprocessing_announce' directive.  This directive
     readies the Multiprocessing Server.

  9. The Multiprocessing Server calls the user-provided MPCI routine
     RECEIVE_PACKET, readies the original requesting task, and blocks
     until another packet arrives.  Control is transferred to the
     original task which then completes processing of the directive.


If an uncorrectable error occurs in the user-provided MPCI layer, the
fatal error handler should be invoked.  RTEMS assumes the reliable
transmission and reception of messages by the MPCI and makes no attempt
to detect or correct errors.


File: ada_user.info,  Node: Multiprocessing Manager Proxies,  Next: Multiprocessing Manager Multiprocessor Configuration Table,  Prev: Multiprocessing Manager Remote Operations,  Up: Multiprocessing Manager Background

24.2.5 Proxies
--------------

A proxy is an RTEMS data structure which resides on a remote node and
is used to represent a task which must block as part of a remote
operation. This action can occur as part of the
`rtems.semaphore_obtain' and `rtems.message_queue_receive' directives.
If the object were local, the task's control block would be available
for modification to indicate it was blocking on a message queue or
semaphore.  However, the task's control block resides only on the same
node as the task.  As a result, the remote node must allocate a proxy
to represent the task until it can be readied.

The maximum number of proxies is defined in the Multiprocessor
Configuration Table.  Each node in a multiprocessor system may require
a different number of proxies to be configured.  The distribution of
proxy control blocks is application dependent and is different from the
distribution of tasks.


File: ada_user.info,  Node: Multiprocessing Manager Multiprocessor Configuration Table,  Next: Multiprocessing Manager Multiprocessor Communications Interface Layer,  Prev: Multiprocessing Manager Proxies,  Up: Multiprocessing Manager Background

24.2.6 Multiprocessor Configuration Table
-----------------------------------------

The Multiprocessor Configuration Table contains information needed by
RTEMS when used in a multiprocessor system.  This table is discussed in
detail in the section Multiprocessor Configuration Table of the
Configuring a System chapter.


File: ada_user.info,  Node: Multiprocessing Manager Multiprocessor Communications Interface Layer,  Next: Multiprocessing Manager INITIALIZATION,  Prev: Multiprocessing Manager Multiprocessor Configuration Table,  Up: Multiprocessing Manager

24.3 Multiprocessor Communications Interface Layer
==================================================

* Menu:

* Multiprocessing Manager INITIALIZATION::
* Multiprocessing Manager GET_PACKET::
* Multiprocessing Manager RETURN_PACKET::
* Multiprocessing Manager RECEIVE_PACKET::
* Multiprocessing Manager SEND_PACKET::
* Multiprocessing Manager Supporting Heterogeneous Environments::

The Multiprocessor Communications Interface Layer (MPCI) is a set of
user-provided procedures which enable the nodes in a multiprocessor
system to communicate with one another.  These routines are invoked by
RTEMS at various times in the preparation and processing of remote
requests.  Interrupts are enabled when an MPCI procedure is invoked.
It is assumed that if the execution mode and/or interrupt level are
altered by the MPCI layer, that they will be restored prior to
returning to RTEMS.

The MPCI layer is responsible for managing a pool of buffers called
packets and for sending these packets between system nodes.  Packet
buffers contain the messages sent between the nodes.  Typically, the
MPCI layer will encapsulate the packet within an envelope which
contains the information needed by the MPCI layer.  The number of
packets available is dependent on the MPCI layer implementation.

The entry points to the routines in the user's MPCI layer should be
placed in the Multiprocessor Communications Interface Table.  The user
must provide entry points for each of the following table entries in a
multiprocessor system:

   * initialization 	initialize the MPCI

   * get_packet 	obtain a packet buffer

   * return_packet 	return a packet buffer

   * send_packet 	send a packet to another node

   * receive_packet 	called to get an arrived packet

A packet is sent by RTEMS in each of the following situations:

   * an RQ is generated on an originating node;

   * an RR is generated on a destination node;

   * a global object is created;

   * a global object is deleted;

   * a local task blocked on a remote object is deleted;

   * during system initialization to check for system consistency.

If the target hardware supports it, the arrival of a packet at a node
may generate an interrupt.  Otherwise, the real-time clock ISR can
check for the arrival of a packet.  In any case, the
`rtems_multiprocessing_announce' directive must be called to announce
the arrival of a packet.  After exiting the ISR, control will be passed
to the Multiprocessing Server to process the packet.  The
Multiprocessing Server will call the get_packet entry to obtain a
packet buffer and the receive_entry entry to copy the message into the
buffer obtained.


File: ada_user.info,  Node: Multiprocessing Manager INITIALIZATION,  Next: Multiprocessing Manager GET_PACKET,  Prev: Multiprocessing Manager Multiprocessor Communications Interface Layer,  Up: Multiprocessing Manager Multiprocessor Communications Interface Layer

24.3.1 INITIALIZATION
---------------------

The INITIALIZATION component of the user-provided MPCI layer is called
as part of the `rtems_initialize_executive' directive to initialize the
MPCI layer and associated hardware.  It is invoked immediately after
all of the device drivers have been initialized.  This component should
be adhere to the following prototype:

     rtems_mpci_entry user_mpci_initialization(
       rtems_configuration_table *configuration
     );

where configuration is the address of the user's Configuration Table.
Operations on global objects cannot be performed until this component
is invoked.  The INITIALIZATION component is invoked only once in the
life of any system.  If the MPCI layer cannot be successfully
initialized, the fatal error manager should be invoked by this routine.

One of the primary functions of the MPCI layer is to provide the
executive with packet buffers.  The INITIALIZATION routine must create
and initialize a pool of packet buffers.  There must be enough packet
buffers so RTEMS can obtain one whenever needed.


File: ada_user.info,  Node: Multiprocessing Manager GET_PACKET,  Next: Multiprocessing Manager RETURN_PACKET,  Prev: Multiprocessing Manager INITIALIZATION,  Up: Multiprocessing Manager Multiprocessor Communications Interface Layer

24.3.2 GET_PACKET
-----------------

The GET_PACKET component of the user-provided MPCI layer is called when
RTEMS must obtain a packet buffer to send or broadcast a message.  This
component should be adhere to the following prototype:

     rtems_mpci_entry user_mpci_get_packet(
       rtems_packet_prefix **packet
     );

where packet is the address of a pointer to a packet.  This routine
always succeeds and, upon return, packet will contain the address of a
packet.  If for any reason, a packet cannot be successfully obtained,
then the fatal error manager should be invoked.

RTEMS has been optimized to avoid the need for obtaining a packet each
time a message is sent or broadcast.  For example, RTEMS sends response
messages (RR) back to the originator in the same packet in which the
request message (RQ) arrived.


File: ada_user.info,  Node: Multiprocessing Manager RETURN_PACKET,  Next: Multiprocessing Manager RECEIVE_PACKET,  Prev: Multiprocessing Manager GET_PACKET,  Up: Multiprocessing Manager Multiprocessor Communications Interface Layer

24.3.3 RETURN_PACKET
--------------------

The RETURN_PACKET component of the user-provided MPCI layer is called
when RTEMS needs to release a packet to the free packet buffer pool.
This component should be adhere to the following prototype:

     rtems_mpci_entry user_mpci_return_packet(
       rtems_packet_prefix *packet
     );

where packet is the address of a packet.  If the packet cannot be
successfully returned, the fatal error manager should be invoked.


File: ada_user.info,  Node: Multiprocessing Manager RECEIVE_PACKET,  Next: Multiprocessing Manager SEND_PACKET,  Prev: Multiprocessing Manager RETURN_PACKET,  Up: Multiprocessing Manager Multiprocessor Communications Interface Layer

24.3.4 RECEIVE_PACKET
---------------------

The RECEIVE_PACKET component of the user-provided MPCI layer is called
when RTEMS needs to obtain a packet which has previously arrived.  This
component should be adhere to the following prototype:

     rtems_mpci_entry user_mpci_receive_packet(
       rtems_packet_prefix **packet
     );

where packet is a pointer to the address of a packet to place the
message from another node.  If a message is available, then packet will
contain the address of the message from another node.  If no messages
are available, this entry packet should contain NULL.


File: ada_user.info,  Node: Multiprocessing Manager SEND_PACKET,  Next: Multiprocessing Manager Supporting Heterogeneous Environments,  Prev: Multiprocessing Manager RECEIVE_PACKET,  Up: Multiprocessing Manager Multiprocessor Communications Interface Layer

24.3.5 SEND_PACKET
------------------

The SEND_PACKET component of the user-provided MPCI layer is called
when RTEMS needs to send a packet containing a message to another node.
This component should be adhere to the following prototype:

     rtems_mpci_entry user_mpci_send_packet(
       uint32_t               node,
       rtems_packet_prefix  **packet
     );

where node is the node number of the destination and packet is the
address of a packet which containing a message.  If the packet cannot
be successfully sent, the fatal error manager should be invoked.

If node is set to zero, the packet is to be broadcasted to all other
nodes in the system.  Although some MPCI layers will be built upon
hardware which support a broadcast mechanism, others may be required to
generate a copy of the packet for each node in the system.

Many MPCI layers use the `packet_length' field of the
`rtems_packet_prefix' portion of the packet to avoid sending
unnecessary data.  This is especially useful if the media connecting
the nodes is relatively slow.

The to_convert field of the MP_packet_prefix portion of the packet
indicates how much of the packet (in `uint32_t''s) may require
conversion in a heterogeneous system.


File: ada_user.info,  Node: Multiprocessing Manager Supporting Heterogeneous Environments,  Next: Multiprocessing Manager Operations,  Prev: Multiprocessing Manager SEND_PACKET,  Up: Multiprocessing Manager Multiprocessor Communications Interface Layer

24.3.6 Supporting Heterogeneous Environments
--------------------------------------------

Developing an MPCI layer for a heterogeneous system requires a thorough
understanding of the differences between the processors which comprise
the system.  One difficult problem is the varying data representation
schemes used by different processor types.  The most pervasive data
representation problem is the order of the bytes which compose a data
entity.  Processors which place the least significant byte at the
smallest address are classified as little endian processors.  Little
endian byte-ordering is shown below:

     +---------------+----------------+---------------+----------------+
     |               |                |               |                |
     |    Byte 3     |     Byte 2     |    Byte 1     |    Byte 0      |
     |               |                |               |                |
     +---------------+----------------+---------------+----------------+

Conversely, processors which place the most significant byte at the
smallest address are classified as big endian processors.  Big endian
byte-ordering is shown below:

     +---------------+----------------+---------------+----------------+
     |               |                |               |                |
     |    Byte 0     |     Byte 1     |    Byte 2     |    Byte 3      |
     |               |                |               |                |
     +---------------+----------------+---------------+----------------+

Unfortunately, sharing a data structure between big endian and little
endian processors requires translation into a common endian format.  An
application designer typically chooses the common endian format to
minimize conversion overhead.

Another issue in the design of shared data structures is the alignment
of data structure elements.  Alignment is both processor and compiler
implementation dependent.  For example, some processors allow data
elements to begin on any address boundary, while others impose
restrictions.  Common restrictions are that data elements must begin on
either an even address or on a long word boundary.  Violation of these
restrictions may cause an exception or impose a performance penalty.

Other issues which commonly impact the design of shared data structures
include the representation of floating point numbers, bit fields,
decimal data, and character strings.  In addition, the representation
method for negative integers could be one's or two's complement.  These
factors combine to increase the complexity of designing and
manipulating data structures shared between processors.

RTEMS addressed these issues in the design of the packets used to
communicate between nodes.  The RTEMS packet format is designed to
allow the MPCI layer to perform all necessary conversion without
burdening the developer with the details of the RTEMS packet format.
As a result, the MPCI layer must be aware of the following:

   * All packets must begin on a four byte boundary.

   * Packets are composed of both RTEMS and application data.  All
     RTEMS data is treated as thirty-two (32) bit unsigned quantities
     and is in the first `RTEMS.MINIMUM_UNSIGNED32S_TO_CONVERT'
     thirty-two (32) quantities of the packet.

   * The RTEMS data component of the packet must be in native endian
     format.  Endian conversion may be performed by either the sending
     or receiving MPCI layer.

   * RTEMS makes no assumptions regarding the application data
     component of the packet.


File: ada_user.info,  Node: Multiprocessing Manager Operations,  Next: Multiprocessing Manager Announcing a Packet,  Prev: Multiprocessing Manager Supporting Heterogeneous Environments,  Up: Multiprocessing Manager

24.4 Operations
===============

* Menu:

* Multiprocessing Manager Announcing a Packet::


File: ada_user.info,  Node: Multiprocessing Manager Announcing a Packet,  Next: Multiprocessing Manager Directives,  Prev: Multiprocessing Manager Operations,  Up: Multiprocessing Manager Operations

24.4.1 Announcing a Packet
--------------------------

The `rtems_multiprocessing_announce' directive is called by the MPCI
layer to inform RTEMS that a packet has arrived from another node.
This directive can be called from an interrupt service routine or from
within a polling routine.


File: ada_user.info,  Node: Multiprocessing Manager Directives,  Next: Multiprocessing Manager MULTIPROCESSING_ANNOUNCE - Announce the arrival of a packet,  Prev: Multiprocessing Manager Announcing a Packet,  Up: Multiprocessing Manager

24.5 Directives
===============

* Menu:

* Multiprocessing Manager MULTIPROCESSING_ANNOUNCE - Announce the arrival of a packet::

This section details the additional directives required to support
RTEMS in a multiprocessor configuration.  A subsection is dedicated to
each of this manager's directives and describes the calling sequence,
related constants, usage, and status codes.


File: ada_user.info,  Node: Multiprocessing Manager MULTIPROCESSING_ANNOUNCE - Announce the arrival of a packet,  Next: Stack Bounds Checker,  Prev: Multiprocessing Manager Directives,  Up: Multiprocessing Manager Directives

24.5.1 MULTIPROCESSING_ANNOUNCE - Announce the arrival of a packet
------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     void rtems_multiprocessing_announce( void );

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive informs RTEMS that a multiprocessing communications
packet has arrived from another node.  This directive is called by the
user-provided MPCI, and is only used in multiprocessor configurations.

NOTES:
------

This directive is typically called from an ISR.

This directive will almost certainly cause the calling task to be
preempted.

This directive does not generate activity on remote nodes.


File: ada_user.info,  Node: Stack Bounds Checker,  Next: Stack Bounds Checker Introduction,  Prev: Multiprocessing Manager MULTIPROCESSING_ANNOUNCE - Announce the arrival of a packet,  Up: Top

25 Stack Bounds Checker
***********************

* Menu:

* Stack Bounds Checker Introduction::
* Stack Bounds Checker Background::
* Stack Bounds Checker Operations::
* Stack Bounds Checker Routines::


File: ada_user.info,  Node: Stack Bounds Checker Introduction,  Next: Stack Bounds Checker Background,  Prev: Stack Bounds Checker,  Up: Stack Bounds Checker

25.1 Introduction
=================

The stack bounds checker is an RTEMS support component that determines
if a task has overrun its run-time stack.  The routines provided by the
stack bounds checker manager are:

   * `rtems.stack_checker_is_blown' - Has the Current Task Blown its
     Stack

   * `rtems.stack_checker_report_usage' - Report Task Stack Usage


File: ada_user.info,  Node: Stack Bounds Checker Background,  Next: Stack Bounds Checker Task Stack,  Prev: Stack Bounds Checker Introduction,  Up: Stack Bounds Checker

25.2 Background
===============

* Menu:

* Stack Bounds Checker Task Stack::
* Stack Bounds Checker Execution::


File: ada_user.info,  Node: Stack Bounds Checker Task Stack,  Next: Stack Bounds Checker Execution,  Prev: Stack Bounds Checker Background,  Up: Stack Bounds Checker Background

25.2.1 Task Stack
-----------------

Each task in a system has a fixed size stack associated with it.  This
stack is allocated when the task is created.  As the task executes, the
stack is used to contain parameters, return addresses, saved registers,
and local variables.  The amount of stack space required by a task is
dependent on the exact set of routines used.  The peak stack usage
reflects the worst case of subroutine pushing information on the stack.
For example, if a subroutine allocates a local buffer of 1024 bytes,
then this data must be accounted for in the stack of every task that
invokes that routine.

Recursive routines make calculating peak stack usage difficult, if not
impossible.  Each call to the recursive routine consumes n bytes of
stack space.  If the routine recursives 1000 times, then `1000 * n'
bytes of stack space are required.


File: ada_user.info,  Node: Stack Bounds Checker Execution,  Next: Stack Bounds Checker Operations,  Prev: Stack Bounds Checker Task Stack,  Up: Stack Bounds Checker Background

25.2.2 Execution
----------------

The stack bounds checker operates as a set of task extensions.  At task
creation time, the task's stack is filled with a pattern to indicate
the stack is unused.  As the task executes, it will overwrite this
pattern in memory.  At each task switch, the stack bounds checker's
task switch extension is executed.  This extension checks that:

   * the last `n' bytes of the task's stack have not been overwritten.
     If this pattern has been damaged, it indicates that at some point
     since this task was context switch to the CPU, it has used too
     much stack space.

   * the current stack pointer of the task is not within the address
     range allocated for use as the task's stack.


If either of these conditions is detected, then a blown stack error is
reported using the `printk' routine.

The number of bytes checked for an overwrite is processor family
dependent.  The minimum stack frame per subroutine call varies widely
between processor families.  On CISC families like the Motorola MC68xxx
and Intel ix86, all that is needed is a return address.  On more
complex RISC processors, the minimum stack frame per subroutine call
may include space to save a significant number of registers.

Another processor dependent feature that must be taken into account by
the stack bounds checker is the direction that the stack grows.  On some
processor families, the stack grows up or to higher addresses as the
task executes.  On other families, it grows down to lower addresses.
The stack bounds checker implementation uses the stack description
definitions provided by every RTEMS port to get for this information.


File: ada_user.info,  Node: Stack Bounds Checker Operations,  Next: Stack Bounds Checker Initializing the Stack Bounds Checker,  Prev: Stack Bounds Checker Execution,  Up: Stack Bounds Checker

25.3 Operations
===============

* Menu:

* Stack Bounds Checker Initializing the Stack Bounds Checker::
* Stack Bounds Checker Checking for Blown Task Stack::
* Stack Bounds Checker Reporting Task Stack Usage::
* Stack Bounds Checker When a Task Overflows the Stack::


File: ada_user.info,  Node: Stack Bounds Checker Initializing the Stack Bounds Checker,  Next: Stack Bounds Checker Checking for Blown Task Stack,  Prev: Stack Bounds Checker Operations,  Up: Stack Bounds Checker Operations

25.3.1 Initializing the Stack Bounds Checker
--------------------------------------------

The stack checker is initialized automatically when its task create
extension runs for the first time.

The application must include the stack bounds checker extension set in
its set of Initial Extensions.  This set of extensions is defined as
`STACK_CHECKER_EXTENSION'.  If using `<rtems/confdefs.h>' for
Configuration Table generation, then all that is necessary is to define
the macro `CONFIGURE_STACK_CHECKER_ENABLED' before including
`<rtems/confdefs.h>' as shown below:

     #define CONFIGURE_STACK_CHECKER_ENABLED
       ...
     #include <rtems/confdefs.h>


File: ada_user.info,  Node: Stack Bounds Checker Checking for Blown Task Stack,  Next: Stack Bounds Checker Reporting Task Stack Usage,  Prev: Stack Bounds Checker Initializing the Stack Bounds Checker,  Up: Stack Bounds Checker Operations

25.3.2 Checking for Blown Task Stack
------------------------------------

The application may check whether the stack pointer of currently
executing task is within proper bounds at any time by calling the
`rtems.stack_checker_is_blown' method.  This method return `FALSE' if
the task is operating within its stack bounds and has not damaged its
pattern area.


File: ada_user.info,  Node: Stack Bounds Checker Reporting Task Stack Usage,  Next: Stack Bounds Checker When a Task Overflows the Stack,  Prev: Stack Bounds Checker Checking for Blown Task Stack,  Up: Stack Bounds Checker Operations

25.3.3 Reporting Task Stack Usage
---------------------------------

The application may dynamically report the stack usage for every task
in the system by calling the `rtems.stack_checker_report_usage' routine.
This routine prints a table with the peak usage and stack size of every
task in the system.  The following is an example of the report
generated:

         ID      NAME       LOW        HIGH     AVAILABLE      USED
     0x04010001  IDLE  0x003e8a60  0x003e9667       2952        200
     0x08010002  TA1   0x003e5750  0x003e7b57       9096       1168
     0x08010003  TA2   0x003e31c8  0x003e55cf       9096       1168
     0x08010004  TA3   0x003e0c40  0x003e3047       9096       1104
     0xffffffff  INTR  0x003ecfc0  0x003effbf      12160        128

Notice the last time.  The task id is 0xffffffff and its name is "INTR".
This is not actually a task, it is the interrupt stack.


File: ada_user.info,  Node: Stack Bounds Checker When a Task Overflows the Stack,  Next: Stack Bounds Checker Routines,  Prev: Stack Bounds Checker Reporting Task Stack Usage,  Up: Stack Bounds Checker Operations

25.3.4 When a Task Overflows the Stack
--------------------------------------

When the stack bounds checker determines that a stack overflow has
occurred, it will attempt to print a message using `printk' identifying
the task and then shut the system down.  If the stack overflow has
caused corruption, then it is possible that the message can not be
printed.

The following is an example of the output generated:

     BLOWN STACK!!! Offending task(0x3eb360): id=0x08010002; name=0x54413120
       stack covers range 0x003e5750 - 0x003e7b57 (9224 bytes)
       Damaged pattern begins at 0x003e5758 and is 128 bytes long

The above includes the task id and a pointer to the task control block
as well as enough information so one can look at the task's stack and
see what was happening.


File: ada_user.info,  Node: Stack Bounds Checker Routines,  Next: Stack Bounds Checker STACK_CHECKER_IS_BLOWN - Has Current Task Blown Its Stack,  Prev: Stack Bounds Checker When a Task Overflows the Stack,  Up: Stack Bounds Checker

25.4 Routines
=============

* Menu:

* Stack Bounds Checker STACK_CHECKER_IS_BLOWN - Has Current Task Blown Its Stack::
* Stack Bounds Checker STACK_CHECKER_REPORT_USAGE - Report Task Stack Usage::

This section details the stack bounds checker's routines.  A subsection
is dedicated to each of routines and describes the calling sequence,
related constants, usage, and status codes.


File: ada_user.info,  Node: Stack Bounds Checker STACK_CHECKER_IS_BLOWN - Has Current Task Blown Its Stack,  Next: Stack Bounds Checker STACK_CHECKER_REPORT_USAGE - Report Task Stack Usage,  Prev: Stack Bounds Checker Routines,  Up: Stack Bounds Checker Routines

25.4.1 STACK_CHECKER_IS_BLOWN - Has Current Task Blown Its Stack
----------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     function Stack_Checker_Is_Blown return RTEMS.Boolean;

STATUS CODES:
-------------

`TRUE' - Stack is operating within its stack limits
`FALSE' - Current stack pointer is outside allocated area

DESCRIPTION:
------------

This method is used to determine if the current stack pointer of the
currently executing task is within bounds.

NOTES:
------

This method checks the current stack pointer against the high and low
addresses of the stack memory allocated when the task was created and
it looks for damage to the high water mark pattern for the worst case
usage of the task being called.


File: ada_user.info,  Node: Stack Bounds Checker STACK_CHECKER_REPORT_USAGE - Report Task Stack Usage,  Next: CPU Usage Statistics,  Prev: Stack Bounds Checker STACK_CHECKER_IS_BLOWN - Has Current Task Blown Its Stack,  Up: Stack Bounds Checker Routines

25.4.2 STACK_CHECKER_REPORT_USAGE - Report Task Stack Usage
-----------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Stack_Checker_Report_Usage;

STATUS CODES: NONE
------------------

DESCRIPTION:
------------

This routine prints a table with the peak stack usage and stack space
allocation of every task in the system.

NOTES:
------

NONE


File: ada_user.info,  Node: CPU Usage Statistics,  Next: CPU Usage Statistics Introduction,  Prev: Stack Bounds Checker STACK_CHECKER_REPORT_USAGE - Report Task Stack Usage,  Up: Top

26 CPU Usage Statistics
***********************

* Menu:

* CPU Usage Statistics Introduction::
* CPU Usage Statistics Background::
* CPU Usage Statistics Operations::
* CPU Usage Statistics Directives::


File: ada_user.info,  Node: CPU Usage Statistics Introduction,  Next: CPU Usage Statistics Background,  Prev: CPU Usage Statistics,  Up: CPU Usage Statistics

26.1 Introduction
=================

The CPU usage statistics manager is an RTEMS support component that
provides a convenient way to manipulate the CPU usage information
associated with each task The routines provided by the CPU usage
statistics manager are:

   * `rtems.cpu_usage_report' - Report CPU Usage Statistics

   * `rtems.cpu_usage_reset' - Reset CPU Usage Statistics


File: ada_user.info,  Node: CPU Usage Statistics Background,  Next: CPU Usage Statistics Operations,  Prev: CPU Usage Statistics Introduction,  Up: CPU Usage Statistics

26.2 Background
===============

When analyzing and debugging real-time applications, it is important to
be able to know how much CPU time each task in the system consumes.
This support component provides a mechanism to easily obtain this
information with little burden placed on the target.

The raw data is gathered as part of performing a context switch.  RTEMS
keeps track of how many clock ticks have occurred which the task being
switched out has been executing.  If the task has been running less than
1 clock tick, then for the purposes of the statistics, it is assumed to
have executed 1 clock tick.  This results in some inaccuracy but the
alternative is for the task to have appeared to execute 0 clock ticks.

RTEMS versions newer than the 4.7 release series, support the ability
to obtain timestamps with nanosecond granularity if the BSP provides
support.  It is a desirable enhancement to change the way the usage
data is gathered to take advantage of this recently added capability.
Please consider sponsoring the core RTEMS development team to add this
capability.


File: ada_user.info,  Node: CPU Usage Statistics Operations,  Next: CPU Usage Statistics Report CPU Usage Statistics,  Prev: CPU Usage Statistics Background,  Up: CPU Usage Statistics

26.3 Operations
===============

* Menu:

* CPU Usage Statistics Report CPU Usage Statistics::
* CPU Usage Statistics Reset CPU Usage Statistics::


File: ada_user.info,  Node: CPU Usage Statistics Report CPU Usage Statistics,  Next: CPU Usage Statistics Reset CPU Usage Statistics,  Prev: CPU Usage Statistics Operations,  Up: CPU Usage Statistics Operations

26.3.1 Report CPU Usage Statistics
----------------------------------

The application may dynamically report the CPU usage for every task in
the system by calling the `rtems.cpu_usage_report' routine.  This
routine prints a table with the following information per task:

   * task id

   * task name

   * number of clock ticks executed

   * percentage of time consumed by this task

The following is an example of the report generated:

     -------------------------------------------------------------------------------
                                   CPU USAGE BY THREAD
     ------------+----------------------------------------+---------------+---------
      ID         | NAME                                   | SECONDS       | PERCENT
     ------------+----------------------------------------+---------------+---------
      0x04010001 | IDLE                                   |             0 |   0.000
      0x08010002 | TA1                                    |          1203 |   0.748
      0x08010003 | TA2                                    |           203 |   0.126
      0x08010004 | TA3                                    |           202 |   0.126
     ------------+----------------------------------------+---------------+---------
      TICKS SINCE LAST SYSTEM RESET:                                           1600
      TOTAL UNITS:                                                             1608
     -------------------------------------------------------------------------------

Notice that the "TOTAL UNITS" is greater than the ticks per reset.
This is an artifact of the way in which RTEMS keeps track of CPU usage.
When a task is context switched into the CPU, the number of clock ticks
it has executed is incremented.  While the task is executing, this
number is incremented on each clock tick.  Otherwise, if a task begins
and completes execution between successive clock ticks, there would be
no way to tell that it executed at all.

Another thing to keep in mind when looking at idle time, is that many
systems - especially during debug - have a task providing some type of
debug interface.  It is usually fine to think of the total idle time as
being the sum of the IDLE task and a debug task that will not be
included in a production build of an application.


File: ada_user.info,  Node: CPU Usage Statistics Reset CPU Usage Statistics,  Next: CPU Usage Statistics Directives,  Prev: CPU Usage Statistics Report CPU Usage Statistics,  Up: CPU Usage Statistics Operations

26.3.2 Reset CPU Usage Statistics
---------------------------------

Invoking the `rtems.cpu_usage_reset' routine resets the CPU usage
statistics for all tasks in the system.


File: ada_user.info,  Node: CPU Usage Statistics Directives,  Next: CPU Usage Statistics cpu_usage_report - Report CPU Usage Statistics,  Prev: CPU Usage Statistics Reset CPU Usage Statistics,  Up: CPU Usage Statistics

26.4 Directives
===============

* Menu:

* CPU Usage Statistics cpu_usage_report - Report CPU Usage Statistics::
* CPU Usage Statistics cpu_usage_reset - Reset CPU Usage Statistics::

This section details the CPU usage statistics manager's directives.  A
subsection is dedicated to each of this manager's directives and
describes the calling sequence, related constants, usage, and status
codes.


File: ada_user.info,  Node: CPU Usage Statistics cpu_usage_report - Report CPU Usage Statistics,  Next: CPU Usage Statistics cpu_usage_reset - Reset CPU Usage Statistics,  Prev: CPU Usage Statistics Directives,  Up: CPU Usage Statistics Directives

26.4.1 cpu_usage_report - Report CPU Usage Statistics
-----------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure CPU_Usage_Report;

STATUS CODES: NONE
------------------

DESCRIPTION:
------------

This routine prints out a table detailing the CPU usage statistics for
all tasks in the system.

NOTES:
------

The table is printed using the `printk' routine.


File: ada_user.info,  Node: CPU Usage Statistics cpu_usage_reset - Reset CPU Usage Statistics,  Next: Object Services,  Prev: CPU Usage Statistics cpu_usage_report - Report CPU Usage Statistics,  Up: CPU Usage Statistics Directives

26.4.2 cpu_usage_reset - Reset CPU Usage Statistics
---------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure CPU_Usage_Reset;

STATUS CODES: NONE
------------------

DESCRIPTION:
------------

This routine re-initializes the CPU usage statistics for all tasks in
the system to their initial state.  The initial state is that a task
has not executed and thus has consumed no CPU time.  default state
which is when zero period executions have occurred.

NOTES:
------

NONE


File: ada_user.info,  Node: Object Services,  Next: Object Services Introduction,  Prev: CPU Usage Statistics cpu_usage_reset - Reset CPU Usage Statistics,  Up: Top

27 Object Services
******************

* Menu:

* Object Services Introduction::
* Object Services Background::
* Object Services Operations::
* Object Services Directives::


File: ada_user.info,  Node: Object Services Introduction,  Next: Object Services Background,  Prev: Object Services,  Up: Object Services

27.1 Introduction
=================

RTEMS provides a collection of services to assist in the management and
usage of the objects created and utilized via other managers.  These
services assist in the manipulation of RTEMS objects independent of the
API used to create them.  The object related services provided by RTEMS
are:

   * `rtems.build_name' - build object name from characters

   * `rtems.object_get_classic_name' - lookup name from Id

   * `rtems.object_get_name' - obtain object name as string

   * `rtems.object_set_name' - set object name

   * `rtems.object_id_get_api' - obtain API from Id

   * `rtems.object_id_get_class' - obtain class from Id

   * `rtems.object_id_get_node' - obtain node from Id

   * `rtems.object_id_get_index' - obtain index from Id

   * `rtems.build_id' - build object id from components

   * `rtems.object_id_api_minimum' - obtain minimum API value

   * `rtems.object_id_api_maximum' - obtain maximum API value

   * `rtems.object_id_api_minimum_class' - obtain minimum class value

   * `rtems.object_id_api_maximum_class' - obtain maximum class value

   * `rtems.object_get_api_name' - obtain API name

   * `rtems.object_get_api_class_name' - obtain class name

   * `rtems.object_get_class_information' - obtain class information


File: ada_user.info,  Node: Object Services Background,  Next: Object Services APIs,  Prev: Object Services Introduction,  Up: Object Services

27.2 Background
===============

* Menu:

* Object Services APIs::
* Object Services Object Classes::
* Object Services Object Names::


File: ada_user.info,  Node: Object Services APIs,  Next: Object Services Object Classes,  Prev: Object Services Background,  Up: Object Services Background

27.2.1 APIs
-----------

RTEMS implements multiple APIs including an Internal API, the Classic
API, the POSIX API, and the uITRON API.  These APIs share the common
foundation of SuperCore objects and thus share object management code.
This includes a common scheme for object Ids and for managing object
names whether those names be in the thirty-two bit form used by the
Classic API or C strings.

The object Id contains a field indicating the API that an object
instance is associated with.  This field holds a numerically small
non-zero integer.


File: ada_user.info,  Node: Object Services Object Classes,  Next: Object Services Object Names,  Prev: Object Services APIs,  Up: Object Services Background

27.2.2 Object Classes
---------------------

Each API consists of a collection of managers.  Each manager is
responsible for instances of a particular object class.  Classic API
Tasks and POSIX Mutexes example classes.

The object Id contains a field indicating the class that an object
instance is associated with.  This field holds a numerically small
non-zero integer.  In all APIs, a class value of one is reserved for
tasks or threads.


File: ada_user.info,  Node: Object Services Object Names,  Next: Object Services Operations,  Prev: Object Services Object Classes,  Up: Object Services Background

27.2.3 Object Names
-------------------

Every RTEMS object which has an Id may also have a name associated with
it.  Depending on the API, names may be either thirty-two bit integers
as in the Classic API or strings as in the POSIX API.

Some objects have Ids but do not have a defined way to associate a name
with them.  For example, POSIX threads have Ids but per POSIX do not
have names. In RTEMS, objects not defined to have thirty-two bit names
may have string names assigned to them via the `rtems.object_set_name'
service.  The original impetus in providing this service was so the
normally anonymous POSIX threads could have a user defined name in CPU
Usage Reports.


File: ada_user.info,  Node: Object Services Operations,  Next: Object Services Decomposing and Recomposing an Object Id,  Prev: Object Services Object Names,  Up: Object Services

27.3 Operations
===============

* Menu:

* Object Services Decomposing and Recomposing an Object Id::
* Object Services Printing an Object Id::


File: ada_user.info,  Node: Object Services Decomposing and Recomposing an Object Id,  Next: Object Services Printing an Object Id,  Prev: Object Services Operations,  Up: Object Services Operations

27.3.1 Decomposing and Recomposing an Object Id
-----------------------------------------------

Services are provided to decompose an object Id into its subordinate
components. The following services are used to do this:

   * `rtems.object_id_get_api'

   * `rtems.object_id_get_class'

   * `rtems.object_id_get_node'

   * `rtems.object_id_get_index'

The following C language example illustrates the decomposition of an Id
and printing the values.

     void printObjectId(rtems_id id)
     {
       printf(
         "API=%d Class=%d Node=%d Index=%d\n",
         rtems_object_id_get_api(id),
         rtems_object_id_get_class(id),
         rtems_object_id_get_node(id),
         rtems_object_id_get_index(id)
       );
     }

This prints the components of the Ids as integers.

It is also possible to construct an arbitrary Id using the
`rtems.build_id' service.  The following C language example illustrates
how to construct the "next Id."

     rtems_id nextObjectId(rtems_id id)
     {
       return rtems_build_id(
         rtems_object_id_get_api(id),
         rtems_object_id_get_class(id),
         rtems_object_id_get_node(id),
         rtems_object_id_get_index(id) + 1
       );
     }

Note that this Id may not be valid in this system or associated with an
allocated object.


File: ada_user.info,  Node: Object Services Printing an Object Id,  Next: Object Services Directives,  Prev: Object Services Decomposing and Recomposing an Object Id,  Up: Object Services Operations

27.3.2 Printing an Object Id
----------------------------

RTEMS also provides services to associate the API and Class portions of
an Object Id with strings.  This allows the application developer to
provide more information about an object in diagnostic messages.

In the following C language example, an Id is decomposed into its
constituent parts and "pretty-printed."

     void prettyPrintObjectId(rtems_id id)
     {
       int tmpAPI, tmpClass;

       tmpAPI   = rtems_object_id_get_api(id),
       tmpClass = rtems_object_id_get_class(id),

       printf(
         "API=%s Class=%s Node=%d Index=%d\n",
         rtems_object_get_api_name(tmpAPI),
         rtems_object_get_api_class_name(tmpAPI, tmpClass),
         rtems_object_id_get_node(id),
         rtems_object_id_get_index(id)
       );
     }


File: ada_user.info,  Node: Object Services Directives,  Next: Object Services BUILD_NAME - Build object name from characters,  Prev: Object Services Printing an Object Id,  Up: Object Services

27.4 Directives
===============

* Menu:

* Object Services BUILD_NAME - Build object name from characters::
* Object Services OBJECT_GET_CLASSIC_NAME - Lookup name from id::
* Object Services OBJECT_GET_NAME - Obtain object name as string::
* Object Services OBJECT_SET_NAME - Set object name::
* Object Services OBJECT_ID_GET_API - Obtain API from Id::
* Object Services OBJECT_ID_GET_CLASS - Obtain Class from Id::
* Object Services OBJECT_ID_GET_NODE - Obtain Node from Id::
* Object Services OBJECT_ID_GET_INDEX - Obtain Index from Id::
* Object Services BUILD_ID - Build Object Id From Components::
* Object Services OBJECT_ID_API_MINIMUM - Obtain Minimum API Value::
* Object Services OBJECT_ID_API_MAXIMUM - Obtain Maximum API Value::
* Object Services OBJECT_API_MINIMUM_CLASS - Obtain Minimum Class Value::
* Object Services OBJECT_API_MAXIMUM_CLASS - Obtain Maximum Class Value::
* Object Services OBJECT_GET_API_NAME - Obtain API Name::
* Object Services OBJECT_GET_API_CLASS_NAME - Obtain Class Name::
* Object Services OBJECT_GET_CLASS_INFORMATION - Obtain Class Information::


File: ada_user.info,  Node: Object Services BUILD_NAME - Build object name from characters,  Next: Object Services OBJECT_GET_CLASSIC_NAME - Lookup name from id,  Prev: Object Services Directives,  Up: Object Services Directives

27.4.1 BUILD_NAME - Build object name from characters
-----------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Build_Name(
        c1   : in     RTEMS.Unsigned8;
        c2   : in     RTEMS.Unsigned8;
        c3   : in     RTEMS.Unsigned8;
        c4   : in     RTEMS.Unsigned8;
        Name :    out RTEMS.Name
     );

DIRECTIVE STATUS CODES
----------------------

Returns a name constructed from the four characters.

DESCRIPTION:
------------

This service takes the four characters provided as arguments and
constructs a thirty-two bit object name with `c1' in the most
significant byte and `c4' in the least significant byte.

NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Object Services OBJECT_GET_CLASSIC_NAME - Lookup name from id,  Next: Object Services OBJECT_GET_NAME - Obtain object name as string,  Prev: Object Services BUILD_NAME - Build object name from characters,  Up: Object Services Directives

27.4.2 OBJECT_GET_CLASSIC_NAME - Lookup name from id
----------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Get_Classic_Name(
        ID     : in     RTEMS.ID;
        Name   :    out RTEMS.Name;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES
----------------------

`RTEMS.SUCCESSFUL' - name looked up successfully
`RTEMS.INVALID_ADDRESS' - invalid name pointer
`RTEMS.INVALID_ID' - invalid object id
DESCRIPTION:
------------

This service looks up the name for the object `id' specified and, if
found, places the result in `*name'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Object Services OBJECT_GET_NAME - Obtain object name as string,  Next: Object Services OBJECT_SET_NAME - Set object name,  Prev: Object Services OBJECT_GET_CLASSIC_NAME - Lookup name from id,  Up: Object Services Directives

27.4.3 OBJECT_GET_NAME - Obtain object name as string
-----------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Get_Name(
        ID     : in     RTEMS.ID;
        Name   :    out RTEMS.Name;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES
----------------------

Returns a pointer to the name if successful or `NULL' otherwise.

DESCRIPTION:
------------

This service looks up the name of the object specified by `id' and
places it in the memory pointed to by `name'.  Every attempt is made to
return name as a printable string even if the object has the Classic
API thirty-two bit style name.

NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Object Services OBJECT_SET_NAME - Set object name,  Next: Object Services OBJECT_ID_GET_API - Obtain API from Id,  Prev: Object Services OBJECT_GET_NAME - Obtain object name as string,  Up: Object Services Directives

27.4.4 OBJECT_SET_NAME - Set object name
----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Set_Name(
        ID     : in     RTEMS.ID;
        Name   : in     String;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES
----------------------

`RTEMS.SUCCESSFUL' - name looked up successfully
`RTEMS.INVALID_ADDRESS' - invalid name pointer
`RTEMS.INVALID_ID' - invalid object id
DESCRIPTION:
------------

This service sets the name of `id' to that specified by the string
located at `name'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

If the object specified by `id' is of a class that has a string name,
this method will free the existing name to the RTEMS Workspace and
allocate enough memory from the RTEMS Workspace to make a copy of the
string located at `name'.

If the object specified by `id' is of a class that has a thirty-two bit
integer style name, then the first four characters in `*name' will be
used to construct the name.  name to the RTEMS Workspace and allocate
enough memory from the RTEMS Workspace to make a copy of the string


File: ada_user.info,  Node: Object Services OBJECT_ID_GET_API - Obtain API from Id,  Next: Object Services OBJECT_ID_GET_CLASS - Obtain Class from Id,  Prev: Object Services OBJECT_SET_NAME - Set object name,  Up: Object Services Directives

27.4.5 OBJECT_ID_GET_API - Obtain API from Id
---------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Id_Get_API(
        ID  : in     RTEMS.ID;
        API :    out RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES
----------------------

Returns the API portion of the object Id.

DESCRIPTION:
------------

This directive returns the API portion of the provided object `id'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

This directive does NOT validate the `id' provided.


File: ada_user.info,  Node: Object Services OBJECT_ID_GET_CLASS - Obtain Class from Id,  Next: Object Services OBJECT_ID_GET_NODE - Obtain Node from Id,  Prev: Object Services OBJECT_ID_GET_API - Obtain API from Id,  Up: Object Services Directives

27.4.6 OBJECT_ID_GET_CLASS - Obtain Class from Id
-------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Id_Get_Class(
        ID        : in     RTEMS.ID;
        The_Class :    out RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES
----------------------

Returns the class portion of the object Id.

DESCRIPTION:
------------

This directive returns the class portion of the provided object `id'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

This directive does NOT validate the `id' provided.


File: ada_user.info,  Node: Object Services OBJECT_ID_GET_NODE - Obtain Node from Id,  Next: Object Services OBJECT_ID_GET_INDEX - Obtain Index from Id,  Prev: Object Services OBJECT_ID_GET_CLASS - Obtain Class from Id,  Up: Object Services Directives

27.4.7 OBJECT_ID_GET_NODE - Obtain Node from Id
-----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Id_Get_Node(
        ID   : in     RTEMS.ID;
        Node :    out RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES
----------------------

Returns the node portion of the object Id.

DESCRIPTION:
------------

This directive returns the node portion of the provided object `id'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

This directive does NOT validate the `id' provided.


File: ada_user.info,  Node: Object Services OBJECT_ID_GET_INDEX - Obtain Index from Id,  Next: Object Services BUILD_ID - Build Object Id From Components,  Prev: Object Services OBJECT_ID_GET_NODE - Obtain Node from Id,  Up: Object Services Directives

27.4.8 OBJECT_ID_GET_INDEX - Obtain Index from Id
-------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Id_Get_Index(
        ID    : in     RTEMS.ID;
        Index :    out RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES
----------------------

Returns the index portion of the object Id.

DESCRIPTION:
------------

This directive returns the index portion of the provided object `id'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

This directive does NOT validate the `id' provided.


File: ada_user.info,  Node: Object Services BUILD_ID - Build Object Id From Components,  Next: Object Services OBJECT_ID_API_MINIMUM - Obtain Minimum API Value,  Prev: Object Services OBJECT_ID_GET_INDEX - Obtain Index from Id,  Up: Object Services Directives

27.4.9 BUILD_ID - Build Object Id From Components
-------------------------------------------------

CALLING SEQUENCE:
-----------------

     function Build_Id(
        the_api   : in     RTEMS.Unsigned32;
        the_class : in     RTEMS.Unsigned32;
        the_node  : in     RTEMS.Unsigned32;
        the_index : in     RTEMS.Unsigned32
     ) return RTEMS.Id;

DIRECTIVE STATUS CODES
----------------------

Returns an object Id constructed from the provided arguments.

DESCRIPTION:
------------

This service constructs an object Id from the provided `the_api',
`the_class', `the_node', and `the_index'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

This directive does NOT validate the arguments provided or the Object
id returned.


File: ada_user.info,  Node: Object Services OBJECT_ID_API_MINIMUM - Obtain Minimum API Value,  Next: Object Services OBJECT_ID_API_MAXIMUM - Obtain Maximum API Value,  Prev: Object Services BUILD_ID - Build Object Id From Components,  Up: Object Services Directives

27.4.10 OBJECT_ID_API_MINIMUM - Obtain Minimum API Value
--------------------------------------------------------

CALLING SEQUENCE:
-----------------

     function Object_Id_API_Minimum return RTEMS.Unsigned32;

DIRECTIVE STATUS CODES
----------------------

Returns the minimum valid for the API portion of an object Id.

DESCRIPTION:
------------

This service returns the minimum valid for the API portion of an object
Id.

NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Object Services OBJECT_ID_API_MAXIMUM - Obtain Maximum API Value,  Next: Object Services OBJECT_API_MINIMUM_CLASS - Obtain Minimum Class Value,  Prev: Object Services OBJECT_ID_API_MINIMUM - Obtain Minimum API Value,  Up: Object Services Directives

27.4.11 OBJECT_ID_API_MAXIMUM - Obtain Maximum API Value
--------------------------------------------------------

CALLING SEQUENCE:
-----------------

     function Object_Id_API_Maximum return RTEMS.Unsigned32;

DIRECTIVE STATUS CODES
----------------------

Returns the maximum valid for the API portion of an object Id.

DESCRIPTION:
------------

This service returns the maximum valid for the API portion of an object
Id.

NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Object Services OBJECT_API_MINIMUM_CLASS - Obtain Minimum Class Value,  Next: Object Services OBJECT_API_MAXIMUM_CLASS - Obtain Maximum Class Value,  Prev: Object Services OBJECT_ID_API_MAXIMUM - Obtain Maximum API Value,  Up: Object Services Directives

27.4.12 OBJECT_API_MINIMUM_CLASS - Obtain Minimum Class Value
-------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_API_Minimum_Class(
        API     : in     RTEMS.Unsigned32;
        Minimum :    out RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES
----------------------

If `api' is not valid, -1 is returned.

If successful, this service returns the minimum valid for the class
portion of an object Id for the specified `api'.

DESCRIPTION:
------------

This service returns the minimum valid for the class portion of an
object Id for the specified `api'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Object Services OBJECT_API_MAXIMUM_CLASS - Obtain Maximum Class Value,  Next: Object Services OBJECT_GET_API_NAME - Obtain API Name,  Prev: Object Services OBJECT_API_MINIMUM_CLASS - Obtain Minimum Class Value,  Up: Object Services Directives

27.4.13 OBJECT_API_MAXIMUM_CLASS - Obtain Maximum Class Value
-------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_API_Maximum_Class(
        API     : in     RTEMS.Unsigned32;
        Maximum :    out RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES
----------------------

If `api' is not valid, -1 is returned.

If successful, this service returns the maximum valid for the class
portion of an object Id for the specified `api'.

DESCRIPTION:
------------

This service returns the maximum valid for the class portion of an
object Id for the specified `api'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Object Services OBJECT_GET_API_NAME - Obtain API Name,  Next: Object Services OBJECT_GET_API_CLASS_NAME - Obtain Class Name,  Prev: Object Services OBJECT_API_MAXIMUM_CLASS - Obtain Maximum Class Value,  Up: Object Services Directives

27.4.14 OBJECT_GET_API_NAME - Obtain API Name
---------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Get_API_Name(
        API  : in     RTEMS.Unsigned32;
        Name :    out String
     );

DIRECTIVE STATUS CODES
----------------------

If `api' is not valid, the string `"BAD API"' is returned.

If successful, this service returns a pointer to a string containing
the name of the specified `api'.

DESCRIPTION:
------------

This service returns the name of the specified `api'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

The string returned is from constant space.  Do not modify or free it.


File: ada_user.info,  Node: Object Services OBJECT_GET_API_CLASS_NAME - Obtain Class Name,  Next: Object Services OBJECT_GET_CLASS_INFORMATION - Obtain Class Information,  Prev: Object Services OBJECT_GET_API_NAME - Obtain API Name,  Up: Object Services Directives

27.4.15 OBJECT_GET_API_CLASS_NAME - Obtain Class Name
-----------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Get_API_Class_Name(
        The_API   : in     RTEMS.Unsigned32;
        The_Class : in     RTEMS.Unsigned32;
        Name      :    out String
     );

DIRECTIVE STATUS CODES
----------------------

If `the_api' is not valid, the string `"BAD API"' is returned.

If `the_class' is not valid, the string `"BAD CLASS"' is returned.

If successful, this service returns a pointer to a string containing
the name of the specified `the_api'/`the_class' pair.

DESCRIPTION:
------------

This service returns the name of the object class indicated by the
specified `the_api' and `the_class'.

NOTES:
------

This directive is strictly local and does not impact task scheduling.

The string returned is from constant space.  Do not modify or free it.


File: ada_user.info,  Node: Object Services OBJECT_GET_CLASS_INFORMATION - Obtain Class Information,  Next: Chains,  Prev: Object Services OBJECT_GET_API_CLASS_NAME - Obtain Class Name,  Up: Object Services Directives

27.4.16 OBJECT_GET_CLASS_INFORMATION - Obtain Class Information
---------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Object_Get_Class_Information(
        The_API   : in     RTEMS.Unsigned32;
        The_Class : in     RTEMS.Unsigned32;
        Info      :    out RTEMS.Object_API_Class_Information;
        Result    :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES
----------------------

`RTEMS.SUCCESSFUL' - information obtained successfully
`RTEMS.INVALID_ADDRESS' - `info' is NULL
`RTEMS.INVALID_NUMBER' - invalid `api' or `the_class'

If successful, the structure located at `info' will be filled in with
information about the specified `api'/`the_class' pairing.

DESCRIPTION:
------------

This service returns information about the object class indicated by the
specified `api' and `the_class'. This structure is defined as follows:


NOTES:
------

This directive is strictly local and does not impact task scheduling.


File: ada_user.info,  Node: Chains,  Next: Chains Introduction,  Prev: Object Services OBJECT_GET_CLASS_INFORMATION - Obtain Class Information,  Up: Top

28 Chains
*********

* Menu:

* Chains Introduction::
* Chains Background::
* Chains Operations::
* Chains Directives::


File: ada_user.info,  Node: Chains Introduction,  Next: Chains Background,  Prev: Chains,  Up: Chains

28.1 Introduction
=================

The Chains API is an interface to the Super Core (score) chain
implementation. The Super Core uses chains for all list type functions.
This includes wait queues and task queues. The Chains API provided by
RTEMS is:

   * `rtems.chain_node' - Chain node used in user objects

   * `rtems.chain_control' - Chain control node

   * `rtems.chain_initialize' - initialize the chain with nodes

   * `rtems.chain_initialize_empty' - initialize the chain as empty

   * `rtems.chain_is_null_node' - Is the node NULL ?

   * `rtems.chain_head' - Return the chain's head

   * `rtems.chain_tail' - Return the chain's tail

   * `rtems.chain_are_nodes_equal' - Are the node's equal ?

   * `rtems.chain_is_empty' - Is the chain empty ?

   * `rtems.chain_is_first' - Is the Node the first in the chain ?

   * `rtems.chain_is_last' - Is the Node the last in the chain ?

   * `rtems.chain_has_only_one_node' - Does the node have one node ?

   * `rtems.chain_is_head' - Is the node the head ?

   * `rtems.chain_is_tail' - Is the node the tail ?

   * `rtems.chain_extract' - Extract the node from the chain

   * `rtems.chain_extract_unprotected' - Extract the node from the
     chain (unprotected)

   * `rtems.chain_get' - Return the first node on the chain

   * `rtems.chain_get_unprotected' - Return the first node on the chain
     (unprotected)

   * `rtems.chain_insert' - Insert the node into the chain

   * `rtems.chain_insert_unprotected' - Insert the node into the chain
     (unprotected)

   * `rtems.chain_append' - Append the node to chain

   * `rtems.chain_append_unprotected' - Append the node to chain
     (unprotected)

   * `rtems.chain_prepend' - Prepend the node to the end of the chain

   * `rtems.chain_prepend_unprotected' - Prepend the node to chain
     (unprotected)


File: ada_user.info,  Node: Chains Background,  Next: Chains Nodes,  Prev: Chains Introduction,  Up: Chains

28.2 Background
===============

* Menu:

* Chains Nodes::
* Chains Controls::

The Chains API maps to the Super Core Chains API. Chains are
implemented as a double linked list of nodes anchored to a control
node. The list starts at the control node and is terminated at the
control node. A node has previous and next pointers. Being a double
linked list nodes can be inserted and removed without the need to
travse the chain.

Chains have a small memory footprint and can be used in interrupt
service routines and are thread safe in a multi-threaded environment.
The directives list which operations disable interrupts.

Chains are very useful in Board Support packages and applications.


File: ada_user.info,  Node: Chains Nodes,  Next: Chains Controls,  Prev: Chains Background,  Up: Chains Background

28.2.1 Nodes
------------

A chain is made up from nodes that orginate from a chain control
object. A node is of type `rtems.chain_node'. The node is designed to
be part of a user data structure and a cast is used to move from the
node address to the user data structure address. For example:

     typedef struct foo
     {
       rtems.chain_node node;
       int              bar;
     } foo;

creates a type `foo' that can be placed on a chain. To get the foo
structure from the list you perform the following:

     foo* get_foo(rtems.chain_control* control)
     {
       return (foo*) rtems.chain_get(control);
     }

The node is placed at the start of the user's structure to allow the
node address on the chain to be easly cast to the user's structure
address.


File: ada_user.info,  Node: Chains Controls,  Next: Chains Operations,  Prev: Chains Nodes,  Up: Chains Background

28.2.2 Controls
---------------

A chain is anchored with a control object. Chain control provide the
user with access to the nodes on the chain. The control is head of the
node.

            Control
             first ------------------------>
             permanent_null <--------------- NODE
             last ------------------------->

The implementation does not require special checks for manipulating the
first and last nodes on the chain. To accomplish this the
`rtems.chain_control' structure is treated as two overlapping
`rtems.chain_node' structures.  The permanent head of the chain
overlays a node structure on the first and `permanent_null' fields.
The `permanent_tail' of the chain overlays a node structure on the
`permanent_null' and `last' elements of the structure.


File: ada_user.info,  Node: Chains Operations,  Next: Chains Multi-threading,  Prev: Chains Controls,  Up: Chains

28.3 Operations
===============

* Menu:

* Chains Multi-threading::
* Chains Creating a Chain::
* Chains Iterating a Chain::


File: ada_user.info,  Node: Chains Multi-threading,  Next: Chains Creating a Chain,  Prev: Chains Operations,  Up: Chains Operations

28.3.1 Multi-threading
----------------------

Chains are designed to be used in a multi-threading environment. The
directives list which operations mask interrupts. Chains supports tasks
and interrupt service routines appending and extracting nodes with out
the need for extra locks. Chains how-ever cannot insure the integrity
of a chain for all operations. This is the responsibility of the user.
For example an interrupt service routine extracting nodes while a task
is iterating over the chain can have unpredictable results.


File: ada_user.info,  Node: Chains Creating a Chain,  Next: Chains Iterating a Chain,  Prev: Chains Multi-threading,  Up: Chains Operations

28.3.2 Creating a Chain
-----------------------

To create a chain you need to declare a chain control then add nodes to
the control. Consider a user structure and chain control:

     typedef struct foo
     {
       rtems.chain_node node;
       uint8_t char*    data;
     } foo;

     rtems.chain_control chain;

Add nodes with the following code:

     rtems.chain_initialize_empty (&chain);

     for (i = 0; i < count; i++)
     {
       foo* bar = malloc (sizeof (foo));
       if (!bar)
         return -1;
       bar->data = malloc (size);
       rtems.chain_append (&chain, &bar->node);
     }

The chain is initialized and the nodes allocated and appended to the
chain. This is an example of a pool of buffers.


File: ada_user.info,  Node: Chains Iterating a Chain,  Next: Chains Directives,  Prev: Chains Creating a Chain,  Up: Chains Operations

28.3.3 Iterating a Chain
------------------------

Iterating a chain is a common function. The example shows how to
iterate the buffer pool chain created in the last section to find
buffers starting with a specific string. If the buffer is located it is
extracted from the chain and placed on another chain:

     void foobar (const char*          match,
                  rtems.chain_control* chain,
                  rtems.chain_control* out)
     {
       rtems.chain_node* node;
       foo*              bar;

       rtems.chain_initialize_empty (out);

       node = chain->first;

       while (!rtems.chain_is_tail (chain, node))
       {
         bar = (foo*) node;
         rtems_chain_node* next_node = node->next;

         if (strcmp (match, bar->data) == 0)
         {
           rtems.chain_extract (node);
           rtems.chain_append (out, node);
         }

         node = next_node;
       }
     }


File: ada_user.info,  Node: Chains Directives,  Next: Chains Initialize Chain With Nodes,  Prev: Chains Iterating a Chain,  Up: Chains

28.4 Directives
===============

* Menu:

* Chains Initialize Chain With Nodes::
* Chains Initialize Empty::
* Chains Is Null Node ?::
* Chains Head::
* Chains Tail::
* Chains Are Two Nodes Equal ?::
* Chains Is the Chain Empty::
* Chains Is this the First Node on the Chain ?::
* Chains Is this the Last Node on the Chain ?::
* Chains Does this Chain have only One Node ?::
* Chains Is this Node the Chain Head ?::
* Chains Is this Node the Chain Tail ?::
* Chains Extract a Node::
* Chains Get the First Node::
* Chains Insert a Node::
* Chains Append a Node::
* Chains Prepend a Node::

The section details the Chains directives.


File: ada_user.info,  Node: Chains Initialize Chain With Nodes,  Next: Chains Initialize Empty,  Prev: Chains Directives,  Up: Chains Directives

28.4.1 Initialize Chain With Nodes
----------------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns nothing.

DESCRIPTION:
------------

This function take in a pointer to a chain control and initializes it
to contain a set of chain nodes.  The chain will contain `number_nodes'
chain nodes from the memory pointed to by `start_address'.  Each node
is assumed to be `node_size' bytes.

NOTES:
------

This call will discard any nodes on the chain.

This call does NOT inititialize any user data on each node.


File: ada_user.info,  Node: Chains Initialize Empty,  Next: Chains Is Null Node ?,  Prev: Chains Initialize Chain With Nodes,  Up: Chains Directives

28.4.2 Initialize Empty
-----------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns nothing.

DESCRIPTION:
------------

This function take in a pointer to a chain control and initializes it
to empty.

NOTES:
------

This call will discard any nodes on the chain.


File: ada_user.info,  Node: Chains Is Null Node ?,  Next: Chains Head,  Prev: Chains Initialize Empty,  Up: Chains Directives

28.4.3 Is Null Node ?
---------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns `true' is the node point is NULL and `false' if the node is not
NULL.

DESCRIPTION:
------------

Tests the node to see if it is a NULL returning `true' if a null.


File: ada_user.info,  Node: Chains Head,  Next: Chains Tail,  Prev: Chains Is Null Node ?,  Up: Chains Directives

28.4.4 Head
-----------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns the permanent head node of the chain.

DESCRIPTION:
------------

This function returns a pointer to the first node on the chain.


File: ada_user.info,  Node: Chains Tail,  Next: Chains Are Two Nodes Equal ?,  Prev: Chains Head,  Up: Chains Directives

28.4.5 Tail
-----------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns the permanent tail node of the chain.

DESCRIPTION:
------------

This function returns a pointer to the last node on the chain.


File: ada_user.info,  Node: Chains Are Two Nodes Equal ?,  Next: Chains Is the Chain Empty,  Prev: Chains Tail,  Up: Chains Directives

28.4.6 Are Two Nodes Equal ?
----------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

This function returns `true' if the left node and the right node are
equal, and `false' otherwise.

DESCRIPTION:
------------

This function returns `true' if the left node and the right node are
equal, and `false' otherwise.


File: ada_user.info,  Node: Chains Is the Chain Empty,  Next: Chains Is this the First Node on the Chain ?,  Prev: Chains Are Two Nodes Equal ?,  Up: Chains Directives

28.4.7 Is the Chain Empty
-------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

This function returns `true' if there a no nodes on the chain and
`false' otherwise.

DESCRIPTION:
------------

This function returns `true' if there a no nodes on the chain and
`false' otherwise.


File: ada_user.info,  Node: Chains Is this the First Node on the Chain ?,  Next: Chains Is this the Last Node on the Chain ?,  Prev: Chains Is the Chain Empty,  Up: Chains Directives

28.4.8 Is this the First Node on the Chain ?
--------------------------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

This function returns `true' if the node is the first node on a chain
and `false' otherwise.

DESCRIPTION:
------------

This function returns `true' if the node is the first node on a chain
and `false' otherwise.


File: ada_user.info,  Node: Chains Is this the Last Node on the Chain ?,  Next: Chains Does this Chain have only One Node ?,  Prev: Chains Is this the First Node on the Chain ?,  Up: Chains Directives

28.4.9 Is this the Last Node on the Chain ?
-------------------------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

This function returns `true' if the node is the last node on a chain and
`false' otherwise.

DESCRIPTION:
------------

This function returns `true' if the node is the last node on a chain and
`false' otherwise.


File: ada_user.info,  Node: Chains Does this Chain have only One Node ?,  Next: Chains Is this Node the Chain Head ?,  Prev: Chains Is this the Last Node on the Chain ?,  Up: Chains Directives

28.4.10 Does this Chain have only One Node ?
--------------------------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

This function returns `true' if there is only one node on the chain and
`false' otherwise.

DESCRIPTION:
------------

This function returns `true' if there is only one node on the chain and
`false' otherwise.


File: ada_user.info,  Node: Chains Is this Node the Chain Head ?,  Next: Chains Is this Node the Chain Tail ?,  Prev: Chains Does this Chain have only One Node ?,  Up: Chains Directives

28.4.11 Is this Node the Chain Head ?
-------------------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

This function returns `true' if the node is the head of the chain and
`false' otherwise.

DESCRIPTION:
------------

This function returns `true' if the node is the head of the chain and
`false' otherwise.


File: ada_user.info,  Node: Chains Is this Node the Chain Tail ?,  Next: Chains Extract a Node,  Prev: Chains Is this Node the Chain Head ?,  Up: Chains Directives

28.4.12 Is this Node the Chain Tail ?
-------------------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

This function returns `true' if the node is the tail of the chain and
`false' otherwise.

DESCRIPTION:
------------

This function returns `true' if the node is the tail of the chain and
`false' otherwise.


File: ada_user.info,  Node: Chains Extract a Node,  Next: Chains Get the First Node,  Prev: Chains Is this Node the Chain Tail ?,  Up: Chains Directives

28.4.13 Extract a Node
----------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns nothing.

DESCRIPTION:
------------

This routine extracts the node from the chain on which it resides.

NOTES:
------

Interrupts are disabled while extracting the node to ensure the
atomicity of the operation.

Use `rtems.chain_extract_unprotected()' to avoid disabling of
interrupts.


File: ada_user.info,  Node: Chains Get the First Node,  Next: Chains Insert a Node,  Prev: Chains Extract a Node,  Up: Chains Directives

28.4.14 Get the First Node
--------------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns a pointer a node. If a node was removed, then a pointer to that
node is returned. If the chain was empty, then NULL is returned.

DESCRIPTION:
------------

This function removes the first node from the chain and returns a
pointer to that node.  If the chain is empty, then NULL is returned.

NOTES:
------

Interrupts are disabled while obtaining the node to ensure the
atomicity of the operation.

Use `rtems.chain_get_unprotected()' to avoid disabling of interrupts.


File: ada_user.info,  Node: Chains Insert a Node,  Next: Chains Append a Node,  Prev: Chains Get the First Node,  Up: Chains Directives

28.4.15 Insert a Node
---------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns nothing.

DESCRIPTION:
------------

This routine inserts a node on a chain immediately following the
specified node.

NOTES:
------

Interrupts are disabled during the insert to ensure the atomicity of
the operation.

Use `rtems.chain_insert_unprotected()' to avoid disabling of interrupts.


File: ada_user.info,  Node: Chains Append a Node,  Next: Chains Prepend a Node,  Prev: Chains Insert a Node,  Up: Chains Directives

28.4.16 Append a Node
---------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns nothing.

DESCRIPTION:
------------

This routine appends a node to the end of a chain.

NOTES:
------

Interrupts are disabled during the append to ensure the atomicity of
the operation.

Use `rtems.chain_append_unprotected()' to avoid disabling of interrupts.


File: ada_user.info,  Node: Chains Prepend a Node,  Next: Directive Status Codes,  Prev: Chains Append a Node,  Up: Chains Directives

28.4.17 Prepend a Node
----------------------

CALLING SEQUENCE:
-----------------

RETURNS
-------

Returns nothing.

DESCRIPTION:
------------

This routine prepends a node to the front of the chain.

NOTES:
------

Interrupts are disabled during the prepend to ensure the atomicity of
the operation.

Use `rtems.chain_prepend_unprotected()' to avoid disabling of
interrupts.


File: ada_user.info,  Node: Directive Status Codes,  Next: Example Application,  Prev: Chains Prepend a Node,  Up: Top

29 Directive Status Codes
*************************

`RTEMS.SUCCESSFUL' - successful completion

`RTEMS.TASK_EXITTED' - returned from a task

`RTEMS.MP_NOT_CONFIGURED' - multiprocessing not configured

`RTEMS.INVALID_NAME' - invalid object name

`RTEMS.INVALID_ID' - invalid object id

`RTEMS.TOO_MANY' - too many

`RTEMS.TIMEOUT' - timed out waiting

`RTEMS.OBJECT_WAS_DELETED' - object was deleted while waiting

`RTEMS.INVALID_SIZE' - invalid specified size

`RTEMS.INVALID_ADDRESS' - invalid address specified

`RTEMS.INVALID_NUMBER' - number was invalid

`RTEMS.NOT_DEFINED' - item not initialized

`RTEMS.RESOURCE_IN_USE' - resources outstanding

`RTEMS.UNSATISFIED' - request not satisfied

`RTEMS.INCORRECT_STATE' - task is in wrong state

`RTEMS.ALREADY_SUSPENDED' - task already in state

`RTEMS.ILLEGAL_ON_SELF' - illegal for calling task

`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - illegal for remote object

`RTEMS.CALLED_FROM_ISR' - invalid environment

`RTEMS.INVALID_PRIORITY' - invalid task priority

`RTEMS.INVALID_CLOCK' - invalid time buffer

`RTEMS.INVALID_NODE' - invalid node id

`RTEMS.NOT_CONFIGURED' - directive not configured

`RTEMS.NOT_OWNER_OF_RESOURCE' - not owner of resource

`RTEMS.NOT_IMPLEMENTED' - directive not implemented

`RTEMS.INTERNAL_ERROR' - RTEMS inconsistency detected

`RTEMS.NO_MEMORY' - could not get enough memory


File: ada_user.info,  Node: Example Application,  Next: Glossary,  Prev: Directive Status Codes,  Up: Top

30 Example Application
**********************


     Currently there is no example Ada application provided.


File: ada_user.info,  Node: Glossary,  Next: Command and Variable Index,  Prev: Example Application,  Up: Top

31 Glossary
***********

active
     A term used to describe an object which has been created by an
     application.

aperiodic task
     A task which must execute only at irregular intervals and has only
     a soft deadline.

application
     In this document, software which makes use of RTEMS.

ASR
     see Asynchronous Signal Routine.

asynchronous
     Not related in order or timing to other occurrences in the system.

Asynchronous Signal Routine
     Similar to a hardware interrupt except that it is associated with
     a task and is run in the context of a task.  The directives
     provided by the signal manager are used to service signals.

awakened
     A term used to describe a task that has been unblocked and may be
     scheduled to the CPU.

big endian
     A data representation scheme in which the bytes composing a
     numeric value are arranged such that the most significant byte is
     at the lowest address.

bit-mapped
     A data encoding scheme in which each bit in a variable is used to
     represent something different.  This makes for compact data
     representation.

block
     A physically contiguous area of memory.

blocked
     The task state entered by a task which has been previously started
     and cannot continue execution until the reason for waiting has
     been satisfied.

broadcast
     To simultaneously send a message to a logical set of destinations.

BSP
     see Board Support Package.

Board Support Package
     A collection of device initialization and control routines
     specific to a particular type of board or collection of boards.

buffer
     A fixed length block of memory allocated from a partition.

calling convention
     The processor and compiler dependent rules which define the
     mechanism used to invoke subroutines in a high-level language.
     These rules define the passing of arguments, the call and return
     mechanism, and the register set which must be preserved.

Central Processing Unit
     This term is equivalent to the terms processor and microprocessor.

chain
     A data structure which allows for efficient dynamic addition and
     removal of elements.  It differs from an array in that it is not
     limited to a predefined size.

coalesce
     The process of merging adjacent holes into a single larger hole.
     Sometimes this process is referred to as garbage collection.

Configuration Table
     A table which contains information used to tailor RTEMS for a
     particular application.

context
     All of the processor registers and operating system data
     structures associated with a task.

context switch
     Alternate term for task switch.  Taking control of the processor
     from one task and transferring it to another task.

control block
     A data structure used by the executive to define and control an
     object.

core
     When used in this manual, this term refers to the internal
     executive utility functions.  In the interest of application
     portability, the core of the executive should not be used directly
     by applications.

CPU
     An acronym for Central Processing Unit.

critical section
     A section of code which must be executed indivisibly.

CRT
     An acronym for Cathode Ray Tube.  Normally used in reference to
     the man-machine interface.

deadline
     A fixed time limit by which a task must have completed a set of
     actions.  Beyond this point, the results are of reduced value and
     may even be considered useless or harmful.

device
     A peripheral used by the application that requires special
     operation software.  See also device driver.

device driver
     Control software for special peripheral devices used by the
     application.

directives
     RTEMS' provided routines that provide support mechanisms for
     real-time applications.

dispatch
     The act of loading a task's context onto the CPU and transferring
     control of the CPU to that task.

dormant
     The state entered by a task after it is created and before it has
     been started.

Device Driver Table
     A table which contains the entry points for each of the configured
     device drivers.

dual-ported
     A term used to describe memory which can be accessed at two
     different addresses.

embedded
     An application that is delivered as a hidden part of a larger
     system.  For example, the software in a fuel-injection control
     system is an embedded application found in many late-model
     automobiles.

envelope
     A buffer provided by the MPCI layer to RTEMS which is used to pass
     messages between nodes in a multiprocessor system.  It typically
     contains routing information needed by the MPCI.  The contents of
     an envelope are referred to as a packet.

entry point
     The address at which a function or task begins to execute.  In C,
     the entry point of a function is the function's name.

events
     A method for task communication and synchronization. The
     directives provided by the event manager are used to service
     events.

exception
     A synonym for interrupt.

executing
     The task state entered by a task after it has been given control
     of the CPU.

executive
     In this document, this term is used to referred to RTEMS.
     Commonly, an executive is a small real-time operating system used
     in embedded systems.

exported
     An object known by all nodes in a multiprocessor system.  An
     object created with the GLOBAL attribute will be exported.

external address
     The address used to access dual-ported memory by all the nodes in
     a system which do not own the memory.

FIFO
     An acronym for First In First Out.

First In First Out
     A discipline for manipulating entries in a data structure.

floating point coprocessor
     A component used in computer systems to enhance performance in
     mathematically intensive situations.  It is typically viewed as a
     logical extension of the primary processor.

freed
     A resource that has been released by the application to RTEMS.

global
     An object that has been created with the GLOBAL attribute and
     exported to all nodes in a multiprocessor system.

handler
     The equivalent of a manager, except that it is internal to RTEMS
     and forms part of the core.  A handler is a collection of routines
     which provide a related set of functions.  For example, there is a
     handler used by RTEMS to manage all objects.

hard real-time system
     A real-time system in which a missed deadline causes the worked
     performed to have no value or to result in a catastrophic effect
     on the integrity of the system.

heap
     A data structure used to dynamically allocate and deallocate
     variable sized blocks of memory.

heterogeneous
     A multiprocessor computer system composed of dissimilar processors.

homogeneous
     A multiprocessor computer system composed of a single type of
     processor.

ID
     An RTEMS assigned identification tag used to access an active
     object.

IDLE task
     A special low priority task which assumes control of the CPU when
     no other task is able to execute.

interface
     A specification of the methodology used to connect multiple
     independent subsystems.

internal address
     The address used to access dual-ported memory by the node which
     owns the memory.

interrupt
     A hardware facility that causes the CPU to suspend execution, save
     its status, and transfer control to a specific location.

interrupt level
     A mask used to by the CPU to determine which pending interrupts
     should be serviced.  If a pending interrupt is below the current
     interrupt level, then the CPU does not recognize that interrupt.

Interrupt Service Routine
     An ISR is invoked by the CPU to process a pending interrupt.

I/O
     An acronym for Input/Output.

ISR
     An acronym for Interrupt Service Routine.

kernel
     In this document, this term is used as a synonym for executive.

list
     A data structure which allows for dynamic addition and removal of
     entries.  It is not statically limited to a particular size.

little endian
     A data representation scheme in which the bytes composing a
     numeric value are arranged such that the least significant byte is
     at the lowest address.

local
     An object which was created with the LOCAL attribute and is
     accessible only on the node it was created and resides upon.  In a
     single processor configuration, all objects are local.

local operation
     The manipulation of an object which resides on the same node as
     the calling task.

logical address
     An address used by an application.  In a system without memory
     management, logical addresses will equal physical addresses.

loosely-coupled
     A multiprocessor configuration where shared memory is not used for
     communication.

major number
     The index of a device driver in the Device Driver Table.

manager
     A group of related RTEMS' directives which provide access and
     control over resources.

memory pool
     Used interchangeably with heap.

message
     A sixteen byte entity used to communicate between tasks.  Messages
     are sent to message queues and stored in message buffers.

message buffer
     A block of memory used to store messages.

message queue
     An RTEMS object used to synchronize and communicate between tasks
     by transporting messages between sending and receiving tasks.

Message Queue Control Block
     A data structure associated with each message queue used by RTEMS
     to manage that message queue.

minor number
     A numeric value passed to a device driver, the exact usage of
     which is driver dependent.

mode
     An entry in a task's control block that is used to determine if
     the task allows preemption, timeslicing, processing of signals,
     and the interrupt disable level used by the task.

MPCI
     An acronym for Multiprocessor Communications Interface Layer.

multiprocessing
     The simultaneous execution of two or more processes by a multiple
     processor computer system.

multiprocessor
     A computer with multiple CPUs available for executing applications.

Multiprocessor Communications Interface Layer
     A set of user-provided routines which enable the nodes in a
     multiprocessor system to communicate with one another.

Multiprocessor Configuration Table
     The data structure defining the characteristics of the
     multiprocessor target system with which RTEMS will communicate.

multitasking
     The alternation of execution amongst a group of processes on a
     single CPU.  A scheduling algorithm is used to determine which
     process executes at which time.

mutual exclusion
     A term used to describe the act of preventing other tasks from
     accessing a resource simultaneously.

nested
     A term used to describe an ASR that occurs during another ASR or
     an ISR that occurs during another ISR.

node
     A term used to reference a processor running RTEMS in a
     multiprocessor system.

non-existent
     The state occupied by an uncreated or deleted task.

numeric coprocessor
     A component used in computer systems to enhance performance in
     mathematically intensive situations.  It is typically viewed as a
     logical extension of the primary processor.

object
     In this document, this term is used to refer collectively to
     tasks, timers, message queues, partitions, regions, semaphores,
     ports, and rate monotonic periods.  All RTEMS objects have IDs and
     user-assigned names.

object-oriented
     A term used to describe systems with common mechanisms for
     utilizing a variety of entities.  Object-oriented systems shield
     the application from implementation details.

operating system
     The software which controls all the computer's resources and
     provides the base upon which application programs can be written.

overhead
     The portion of the CPUs processing power consumed by the operating
     system.

packet
     A buffer which contains the messages passed between nodes in a
     multiprocessor system.  A packet is the contents of an envelope.

partition
     An RTEMS object which is used to allocate and deallocate fixed
     size blocks of memory from an dynamically specified area of memory.

Partition Control Block
     A data structure associated with each partition used by RTEMS to
     manage that partition.

pending
     A term used to describe a task blocked waiting for an event,
     message, semaphore, or signal.

periodic task
     A task which must execute at regular intervals and comply with a
     hard deadline.

physical address
     The actual hardware address of a resource.

poll
     A mechanism used to determine if an event has occurred by
     periodically checking for a particular status.  Typical events
     include arrival of data, completion of an action, and errors.

pool
     A collection from which resources are allocated.

portability
     A term used to describe the ease with which software can be
     rehosted on another computer.

posting
     The act of sending an event, message, semaphore, or signal to a
     task.

preempt
     The act of forcing a task to relinquish the processor and
     dispatching to another task.

priority
     A mechanism used to represent the relative importance of an
     element in a set of items.  RTEMS uses priority to determine which
     task should execute.

priority inheritance
     An algorithm that calls for the lower priority task holding a
     resource to have its priority increased to that of the highest
     priority task blocked waiting for that resource.  This avoids the
     problem of priority inversion.

priority inversion
     A form of indefinite postponement which occurs when a high
     priority tasks requests access to shared resource currently
     allocated to low priority task.  The high priority task must block
     until the low priority task releases the resource.

processor utilization
     The percentage of processor time used by a task or a set of tasks.

proxy
     An RTEMS control structure used to represent, on a remote node, a
     task which must block as part of a remote operation.

Proxy Control Block
     A data structure associated with each proxy used by RTEMS to
     manage that proxy.

PTCB
     An acronym for Partition Control Block.

PXCB
     An acronym for Proxy Control Block.

quantum
     The application defined unit of time in which the processor is
     allocated.

queue
     Alternate term for message queue.

QCB
     An acronym for Message Queue Control Block.

ready
     A task occupies this state when it is available to be given
     control of the CPU.

real-time
     A term used to describe systems which are characterized by
     requiring deterministic response times to external stimuli.  The
     external stimuli require that the response occur at a precise time
     or the response is incorrect.

reentrant
     A term used to describe routines which do not modify themselves or
     global variables.

region
     An RTEMS object which is used to allocate and deallocate variable
     size blocks of memory from a dynamically specified area of memory.

Region Control Block
     A data structure associated with each region used by RTEMS to
     manage that region.

registers
     Registers are locations physically located within a component,
     typically used for device control or general purpose storage.

remote
     Any object that does not reside on the local node.

remote operation
     The manipulation of an object which does not reside on the same
     node as the calling task.

return code
     Also known as error code or return value.

resource
     A hardware or software entity to which access must be controlled.

resume
     Removing a task from the suspend state.  If the task's state is
     ready following a call to the `rtems.task_resume' directive, then
     the task is available for scheduling.

return code
     A value returned by RTEMS directives to indicate the completion
     status of the directive.

RNCB
     An acronym for Region Control Block.

round-robin
     A task scheduling discipline in which tasks of equal priority are
     executed in the order in which they are made ready.

RS-232
     A standard for serial communications.

running
     The state of a rate monotonic timer while it is being used to
     delineate a period.  The timer exits this state by either expiring
     or being canceled.

schedule
     The process of choosing which task should next enter the executing
     state.

schedulable
     A set of tasks which can be guaranteed to meet their deadlines
     based upon a specific scheduling algorithm.

segments
     Variable sized memory blocks allocated from a region.

semaphore
     An RTEMS object which is used to synchronize tasks and provide
     mutually exclusive access to resources.

Semaphore Control Block
     A data structure associated with each semaphore used by RTEMS to
     manage that semaphore.

shared memory
     Memory which is accessible by multiple nodes in a multiprocessor
     system.

signal
     An RTEMS provided mechanism to communicate asynchronously with a
     task.  Upon reception of a signal, the ASR of the receiving task
     will be invoked.

signal set
     A thirty-two bit entity which is used to represent a task's
     collection of pending signals and the signals sent to a task.

SMCB
     An acronym for Semaphore Control Block.

soft real-time system
     A real-time system in which a missed deadline does not compromise
     the integrity of the system.

sporadic task
     A task which executes at irregular intervals and must comply with
     a hard deadline.  A minimum period of time between successive
     iterations of the task can be guaranteed.

stack
     A data structure that is managed using a Last In First Out (LIFO)
     discipline.  Each task has a stack associated with it which is
     used to store return information and local variables.

status code
     Also known as error code or return value.

suspend
     A term used to describe a task that is not competing for the CPU
     because it has had a `rtems.task_suspend' directive.

synchronous
     Related in order or timing to other occurrences in the system.

system call
     In this document, this is used as an alternate term for directive.

target
     The system on which the application will ultimately execute.

task
     A logically complete thread of execution.  The CPU is allocated
     among the ready tasks.

Task Control Block
     A data structure associated with each task used by RTEMS to manage
     that task.

task switch
     Alternate terminology for context switch.  Taking control of the
     processor from one task and given to another.

TCB
     An acronym for Task Control Block.

tick
     The basic unit of time used by RTEMS.  It is a user-configurable
     number of microseconds.  The current tick expires when the
     `rtems.clock_tick' directive is invoked.

tightly-coupled
     A multiprocessor configuration system which communicates via
     shared memory.

timeout
     An argument provided to a number of directives which determines
     the maximum length of time an application task is willing to wait
     to acquire the resource if it is not immediately available.

timer
     An RTEMS object used to invoke subprograms at a later time.

Timer Control Block
     A data structure associated with each timer used by RTEMS to
     manage that timer.

timeslicing
     A task scheduling discipline in which tasks of equal priority are
     executed for a specific period of time before being preempted by
     another task.

timeslice
     The application defined unit of time in which the processor is
     allocated.

TMCB
     An acronym for Timer Control Block.

transient overload
     A temporary rise in system activity which may cause deadlines to
     be missed.  Rate Monotonic Scheduling can be used to determine if
     all deadlines will be met under transient overload.

user extensions
     Software routines provided by the application to enhance the
     functionality of RTEMS.

User Extension Table
     A table which contains the entry points for each user extensions.

User Initialization Tasks Table
     A table which contains the information needed to create and start
     each of the user initialization tasks.

user-provided
     Alternate term for user-supplied.  This term is used to designate
     any software routines which must be written by the application
     designer.

user-supplied
     Alternate term for user-provided.  This term is used to designate
     any software routines which must be written by the application
     designer.

vector
     Memory pointers used by the processor to fetch the address of
     routines which will handle various exceptions and interrupts.

wait queue
     The list of tasks blocked pending the release of a particular
     resource.  Message queues, regions, and semaphores have a wait
     queue associated with them.

yield
     When a task voluntarily releases control of the processor.



File: ada_user.info,  Node: Top,  Next: List of Figures,  Prev: (dir),  Up: (dir)

ada_user
********

This is the online version of the RTEMS Ada User's Guide.

* Menu:

* List of Figures::
* Preface::
* Overview::
* Key Concepts::
* RTEMS Data Types::
* Initialization Manager::
* Task Manager::
* Interrupt Manager::
* Clock Manager::
* Timer Manager::
* Semaphore Manager::
* Message Manager::
* Event Manager::
* Signal Manager::
* Partition Manager::
* Region Manager::
* Dual-Ported Memory Manager::
* I/O Manager::
* Fatal Error Manager::
* Scheduling Concepts::
* Rate Monotonic Manager::
* Barrier Manager::
* Board Support Packages::
* User Extensions Manager::
* Configuring a System::
* Multiprocessing Manager::
* Stack Bounds Checker::
* CPU Usage Statistics::
* Object Services::
* Chains::
* Directive Status Codes::
* Example Application::
* Glossary::
* Command and Variable Index::
* Concept Index::


File: ada_user.info,  Node: Command and Variable Index,  Next: Concept Index,  Prev: Glossary,  Up: Top

Command and Variable Index
**************************

 [index ]
* Menu:

* _Internal_errors_What_happened:        Fatal Error Manager Announcing a Fatal Error.
                                                              (line   6)
* confdefs.h:                            Configuring a System Automatic Generation of System Configuration.
                                                              (line  21)
* CONFIGURE_APPLICATION_DISABLE_FILESYSTEM: Configuring a System Library Support Definitions.
                                                              (line  56)
* CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER: Configuring a System Device Driver Table.
                                                              (line  42)
* CONFIGURE_APPLICATION_EXTRA_DRIVERS:   Configuring a System Device Driver Table.
                                                              (line  85)
* CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER: Configuring a System Device Driver Table.
                                                              (line  31)
* CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER: Configuring a System Device Driver Table.
                                                              (line  26)
* CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER: Configuring a System Device Driver Table.
                                                              (line  58)
* CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER: Configuring a System Device Driver Table.
                                                              (line  50)
* CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER: Configuring a System Device Driver Table.
                                                              (line  65)
* CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER: Configuring a System Device Driver Table.
                                                              (line  37)
* CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER: Configuring a System Device Driver Table.
                                                              (line  54)
* CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS: Configuring a System Device Driver Table.
                                                              (line  77)
* CONFIGURE_BSP_PREREQUISITE_DRIVERS:    Configuring a System Device Driver Table.
                                                              (line  70)
* CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS: Configuring a System Classic API Configuration.
                                                              (line  13)
* CONFIGURE_EXECUTIVE_RAM_WORK_AREA:     Configuring a System Basic System Information.
                                                              (line  13)
* CONFIGURE_EXTRA_TASK_STACKS:           Configuring a System Basic System Information.
                                                              (line 118)
* CONFIGURE_GNAT_RTEMS:                  Configuring a System Ada Tasks.
                                                              (line  10)
* CONFIGURE_HAS_OWN_CONFIGURATION_TABLE: Configuring a System Basic System Information.
                                                              (line   9)
* CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE: Configuring a System Device Driver Table.
                                                              (line  12)
* CONFIGURE_HAS_OWN_INIT_TASK_TABLE:     Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  17)
* CONFIGURE_HAS_OWN_MOUNT_TABLE:         Configuring a System Library Support Definitions.
                                                              (line  35)
* CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE: Configuring a System Multiprocessing Configuration.
                                                              (line  11)
* CONFIGURE_IDLE_TASK_BODY:              Configuring a System Idle Task Configuration.
                                                              (line   9)
* CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION: Configuring a System Idle Task Configuration.
                                                              (line  19)
* CONFIGURE_IDLE_TASK_STACK_SIZE:        Configuring a System Idle Task Configuration.
                                                              (line  14)
* CONFIGURE_INIT_TASK_ARGUMENTS:         Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  52)
* CONFIGURE_INIT_TASK_ATTRIBUTES:        Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  37)
* CONFIGURE_INIT_TASK_ENTRY_POINT:       Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  42)
* CONFIGURE_INIT_TASK_INITIAL_MODES:     Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  47)
* CONFIGURE_INIT_TASK_NAME:              Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  22)
* CONFIGURE_INIT_TASK_PRIORITY:          Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  32)
* CONFIGURE_INIT_TASK_STACK_SIZE:        Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  27)
* CONFIGURE_INTERRUPT_STACK_SIZE:        Configuring a System Basic System Information.
                                                              (line  55)
* CONFIGURE_ITRON_HAS_OWN_INIT_TASK_TABLE: Configuring a System ITRON Initialization Task Table Configuration.
                                                              (line  17)
* CONFIGURE_ITRON_INIT_TASK_ATTRIBUTES:  Configuring a System ITRON Initialization Task Table Configuration.
                                                              (line  27)
* CONFIGURE_ITRON_INIT_TASK_ENTRY_POINT: Configuring a System ITRON Initialization Task Table Configuration.
                                                              (line  22)
* CONFIGURE_ITRON_INIT_TASK_PRIORITY:    Configuring a System ITRON Initialization Task Table Configuration.
                                                              (line  31)
* CONFIGURE_ITRON_INIT_TASK_STACK_SIZE:  Configuring a System ITRON Initialization Task Table Configuration.
                                                              (line  36)
* CONFIGURE_ITRON_INIT_TASK_TABLE:       Configuring a System ITRON Initialization Task Table Configuration.
                                                              (line  11)
* CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS: Configuring a System Library Support Definitions.
                                                              (line  19)
* CONFIGURE_MALLOC_BSP_SUPPORTS_SBRK:    Configuring a System Library Support Definitions.
                                                              (line  13)
* CONFIGURE_MALLOC_STATISTICS:           Configuring a System Library Support Definitions.
                                                              (line   9)
* CONFIGURE_MAXIMUM_ADA_TASKS:           Configuring a System Ada Tasks.
                                                              (line  16)
* CONFIGURE_MAXIMUM_DEVICES:             Configuring a System Device Driver Table.
                                                              (line  22)
* CONFIGURE_MAXIMUM_DRIVERS:             Configuring a System Device Driver Table.
                                                              (line  19)
* CONFIGURE_MAXIMUM_FAKE_ADA_TASKS:      Configuring a System Ada Tasks.
                                                              (line  20)
* CONFIGURE_MAXIMUM_ITRON_EVENTFLAGS:    Configuring a System ITRON API Configuration.
                                                              (line  17)
* CONFIGURE_MAXIMUM_ITRON_FIXED_MEMORY_POOLS: Configuring a System ITRON API Configuration.
                                                              (line  35)
* CONFIGURE_MAXIMUM_ITRON_MAILBOXES:     Configuring a System ITRON API Configuration.
                                                              (line  21)
* CONFIGURE_MAXIMUM_ITRON_MEMORY_POOLS:  Configuring a System ITRON API Configuration.
                                                              (line  31)
* CONFIGURE_MAXIMUM_ITRON_MESSAGE_BUFFERS: Configuring a System ITRON API Configuration.
                                                              (line  24)
* CONFIGURE_MAXIMUM_ITRON_PORTS:         Configuring a System ITRON API Configuration.
                                                              (line  28)
* CONFIGURE_MAXIMUM_ITRON_SEMAPHORES:    Configuring a System ITRON API Configuration.
                                                              (line  13)
* CONFIGURE_MAXIMUM_ITRON_TASKS:         Configuring a System ITRON API Configuration.
                                                              (line  10)
* CONFIGURE_MAXIMUM_MESSAGE_QUEUES:      Configuring a System Classic API Configuration.
                                                              (line  26)
* CONFIGURE_MAXIMUM_PARTITIONS:          Configuring a System Classic API Configuration.
                                                              (line  30)
* CONFIGURE_MAXIMUM_PERIODS:             Configuring a System Classic API Configuration.
                                                              (line  42)
* CONFIGURE_MAXIMUM_PORTS:               Configuring a System Classic API Configuration.
                                                              (line  38)
* CONFIGURE_MAXIMUM_POSIX_BARRIERS:      Configuring a System POSIX API Configuration.
                                                              (line  45)
* CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES: Configuring a System POSIX API Configuration.
                                                              (line  16)
* CONFIGURE_MAXIMUM_POSIX_KEYS:          Configuring a System POSIX API Configuration.
                                                              (line  20)
* CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS: Configuring a System POSIX API Configuration.
                                                              (line  34)
* CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES: Configuring a System POSIX API Configuration.
                                                              (line  30)
* CONFIGURE_MAXIMUM_POSIX_MUTEXES:       Configuring a System POSIX API Configuration.
                                                              (line  13)
* CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS: Configuring a System POSIX API Configuration.
                                                              (line  26)
* CONFIGURE_MAXIMUM_POSIX_RWLOCKS:       Configuring a System POSIX API Configuration.
                                                              (line  51)
* CONFIGURE_MAXIMUM_POSIX_SEMAPHORES:    Configuring a System POSIX API Configuration.
                                                              (line  41)
* CONFIGURE_MAXIMUM_POSIX_SPINLOCKS:     Configuring a System POSIX API Configuration.
                                                              (line  48)
* CONFIGURE_MAXIMUM_POSIX_THREADS:       Configuring a System POSIX API Configuration.
                                                              (line  10)
* CONFIGURE_MAXIMUM_POSIX_TIMERS:        Configuring a System POSIX API Configuration.
                                                              (line  23)
* CONFIGURE_MAXIMUM_PRIORITY:            Configuring a System Basic System Information.
                                                              (line  38)
* CONFIGURE_MAXIMUM_REGIONS:             Configuring a System Classic API Configuration.
                                                              (line  34)
* CONFIGURE_MAXIMUM_SEMAPHORES:          Configuring a System Classic API Configuration.
                                                              (line  22)
* CONFIGURE_MAXIMUM_TASKS:               Configuring a System Classic API Configuration.
                                                              (line   9)
* CONFIGURE_MAXIMUM_TIMERS:              Configuring a System Classic API Configuration.
                                                              (line  18)
* CONFIGURE_MAXIMUM_USER_EXTENSIONS:     Configuring a System Classic API Configuration.
                                                              (line  46)
* CONFIGURE_MEMORY_OVERHEAD:             Configuring a System Basic System Information.
                                                              (line 114)
* CONFIGURE_MESSAGE_BUFFER_MEMORY:       Configuring a System Basic System Information.
                                                              (line  92)
* CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE:   Configuring a System Basic System Information.
                                                              (line  81)
* CONFIGURE_MICROSECONDS_PER_TICK:       Configuring a System Basic System Information.
                                                              (line  32)
* CONFIGURE_MINIMUM_TASK_STACK_SIZE:     Configuring a System Basic System Information.
                                                              (line  50)
* CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS:   Configuring a System Multiprocessing Configuration.
                                                              (line  23)
* CONFIGURE_MP_MAXIMUM_NODES:            Configuring a System Multiprocessing Configuration.
                                                              (line  20)
* CONFIGURE_MP_MAXIMUM_PROXIES:          Configuring a System Multiprocessing Configuration.
                                                              (line  27)
* CONFIGURE_MP_MPCI_TABLE_POINTER:       Configuring a System Multiprocessing Configuration.
                                                              (line  31)
* CONFIGURE_MP_NODE_NUMBER:              Configuring a System Multiprocessing Configuration.
                                                              (line  16)
* CONFIGURE_NUMBER_OF_TERMIOS_PORTS:     Configuring a System Library Support Definitions.
                                                              (line  30)
* CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE: Configuring a System POSIX Initialization Threads Table Configuration.
                                                              (line  17)
* CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT: Configuring a System POSIX Initialization Threads Table Configuration.
                                                              (line  22)
* CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE: Configuring a System POSIX Initialization Threads Table Configuration.
                                                              (line  27)
* CONFIGURE_POSIX_INIT_THREAD_TABLE:     Configuring a System POSIX Initialization Threads Table Configuration.
                                                              (line  11)
* CONFIGURE_RTEMS_INIT_TASKS_TABLE:      Configuring a System Classic API Initialization Tasks Table Configuration.
                                                              (line  11)
* CONFIGURE_STACK_CHECKER_ENABLED:       Configuring a System Library Support Definitions.
                                                              (line  60)
* CONFIGURE_TASK_STACK_ALLOCATOR:        Configuring a System Basic System Information.
                                                              (line  65)
* CONFIGURE_TASK_STACK_DEALLOCATOR:      Configuring a System Basic System Information.
                                                              (line  70)
* CONFIGURE_TERMIOS_DISABLED:            Configuring a System Library Support Definitions.
                                                              (line  25)
* CONFIGURE_TICKS_PER_TIMESLICE:         Configuring a System Basic System Information.
                                                              (line  35)
* CONFIGURE_UNIFIED_WORK_AREAS:          Configuring a System Basic System Information.
                                                              (line  18)
* CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM: Configuring a System Library Support Definitions.
                                                              (line  51)
* CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM: Configuring a System Library Support Definitions.
                                                              (line  42)
* CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY: Configuring a System Basic System Information.
                                                              (line  75)
* int16_t:                               RTEMS Data Types List of Data Types.
                                                              (line 132)
* int32_t:                               RTEMS Data Types List of Data Types.
                                                              (line 136)
* int64_t:                               RTEMS Data Types List of Data Types.
                                                              (line 141)
* int8_t:                                RTEMS Data Types List of Data Types.
                                                              (line 128)
* posix_api_configuration_table:         Configuring a System POSIX API Configuration Table.
                                                              (line  12)
* posix_initialization_threads_table:    Configuring a System POSIX API Configuration Table.
                                                              (line  12)
* rtems extensions table index:          User Extensions Manager TCB Extension Area.
                                                              (line  18)
* rtems_address:                         RTEMS Data Types List of Data Types.
                                                              (line   9)
* rtems_api_configuration_table:         Configuring a System RTEMS API Configuration Table.
                                                              (line  12)
* rtems_asr:                             RTEMS Data Types List of Data Types.
                                                              (line  12)
* rtems_asr_entry:                       RTEMS Data Types List of Data Types.
                                                              (line  14)
* rtems_attribute:                       RTEMS Data Types List of Data Types.
                                                              (line  17)
* rtems_boolean:                         RTEMS Data Types List of Data Types.
                                                              (line  21)
* rtems_build_name:                      Key Concepts Object Names.
                                                              (line  10)
* rtems_clock_get_options <1>:           Clock Manager CLOCK_GET - Get date and time information.
                                                              (line  39)
* rtems_clock_get_options:               Clock Manager Obtaining the Time.
                                                              (line  17)
* rtems_configuration_table:             Configuring a System Configuration Table.
                                                              (line  14)
* rtems_context:                         RTEMS Data Types List of Data Types.
                                                              (line  25)
* rtems_context_fp:                      RTEMS Data Types List of Data Types.
                                                              (line  28)
* rtems_device_driver:                   RTEMS Data Types List of Data Types.
                                                              (line  31)
* rtems_device_driver_entry:             RTEMS Data Types List of Data Types.
                                                              (line  34)
* rtems_device_major_number <1>:         I/O Manager Major and Minor Device Numbers.
                                                              (line  13)
* rtems_device_major_number:             RTEMS Data Types List of Data Types.
                                                              (line  37)
* rtems_device_minor_number <1>:         I/O Manager Major and Minor Device Numbers.
                                                              (line  13)
* rtems_device_minor_number:             RTEMS Data Types List of Data Types.
                                                              (line  40)
* rtems_double:                          RTEMS Data Types List of Data Types.
                                                              (line  43)
* rtems_driver_address_table:            Configuring a System Driver Address Table.
                                                              (line  15)
* rtems_event_set <1>:                   Event Manager Event Sets.
                                                              (line   6)
* rtems_event_set:                       RTEMS Data Types List of Data Types.
                                                              (line  48)
* rtems_extension <1>:                   User Extensions Manager TASK_CREATE Extension.
                                                              (line  12)
* rtems_extension:                       RTEMS Data Types List of Data Types.
                                                              (line  51)
* rtems_extensions_table:                User Extensions Manager Extension Sets.
                                                              (line  13)
* rtems_fatal_extension <1>:             User Extensions Manager FATAL Error Extension.
                                                              (line  12)
* rtems_fatal_extension:                 RTEMS Data Types List of Data Types.
                                                              (line  54)
* rtems_id <1>:                          RTEMS Data Types List of Data Types.
                                                              (line  57)
* rtems_id:                              Key Concepts Object IDs.
                                                              (line  11)
* rtems_initialization_tasks_table:      Configuring a System Initialization Task Table.
                                                              (line  17)
* rtems_interrupt_frame:                 RTEMS Data Types List of Data Types.
                                                              (line  60)
* rtems_interrupt_level:                 RTEMS Data Types List of Data Types.
                                                              (line  64)
* rtems_interval <1>:                    RTEMS Data Types List of Data Types.
                                                              (line  70)
* rtems_interval:                        Key Concepts Time.   (line  13)
* rtems_isr:                             RTEMS Data Types List of Data Types.
                                                              (line  74)
* rtems_isr_entry:                       RTEMS Data Types List of Data Types.
                                                              (line  77)
* rtems_mode:                            RTEMS Data Types List of Data Types.
                                                              (line  86)
* rtems_mp_packet_classes:               RTEMS Data Types List of Data Types.
                                                              (line  81)
* rtems_mpci_entry <1>:                  Multiprocessing Manager INITIALIZATION.
                                                              (line  12)
* rtems_mpci_entry:                      RTEMS Data Types List of Data Types.
                                                              (line  89)
* rtems_mpci_get_packet_entry:           RTEMS Data Types List of Data Types.
                                                              (line  91)
* rtems_mpci_initialization_entry:       RTEMS Data Types List of Data Types.
                                                              (line  94)
* rtems_mpci_receive_packet_entry:       RTEMS Data Types List of Data Types.
                                                              (line  97)
* rtems_mpci_return_packet_entry:        RTEMS Data Types List of Data Types.
                                                              (line 100)
* rtems_mpci_send_packet_entry:          RTEMS Data Types List of Data Types.
                                                              (line 103)
* rtems_mpci_table:                      RTEMS Data Types List of Data Types.
                                                              (line 106)
* rtems_multiprocessing_announce:        Multiprocessing Manager MULTIPROCESSING_ANNOUNCE - Announce the arrival of a packet.
                                                              (line   9)
* rtems_name:                            RTEMS Data Types List of Data Types.
                                                              (line 109)
* rtems_object_id_get_api:               Key Concepts Object ID Description.
                                                              (line  27)
* rtems_object_id_get_class:             Key Concepts Object ID Description.
                                                              (line  27)
* rtems_object_id_get_index:             Key Concepts Object ID Description.
                                                              (line  27)
* rtems_object_id_get_node:              Key Concepts Object ID Description.
                                                              (line  27)
* rtems_object_name:                     Key Concepts Object Names.
                                                              (line   6)
* rtems_option:                          RTEMS Data Types List of Data Types.
                                                              (line 114)
* rtems_packet_prefix:                   RTEMS Data Types List of Data Types.
                                                              (line 120)
* rtems_signal_set <1>:                  Signal Manager Signal Manager Definitions.
                                                              (line  14)
* rtems_signal_set:                      RTEMS Data Types List of Data Types.
                                                              (line 125)
* rtems_single:                          RTEMS Data Types List of Data Types.
                                                              (line 146)
* rtems_status_codes:                    RTEMS Data Types List of Data Types.
                                                              (line 151)
* rtems_task:                            RTEMS Data Types List of Data Types.
                                                              (line 156)
* rtems_task_argument:                   RTEMS Data Types List of Data Types.
                                                              (line 158)
* rtems_task_begin_extension <1>:        User Extensions Manager TASK_BEGIN Extension.
                                                              (line  11)
* rtems_task_begin_extension:            RTEMS Data Types List of Data Types.
                                                              (line 164)
* rtems_task_create_extension <1>:       User Extensions Manager TASK_CREATE Extension.
                                                              (line  12)
* rtems_task_create_extension:           RTEMS Data Types List of Data Types.
                                                              (line 167)
* rtems_task_delete_extension <1>:       User Extensions Manager TASK_DELETE Extension.
                                                              (line  12)
* rtems_task_delete_extension:           RTEMS Data Types List of Data Types.
                                                              (line 170)
* rtems_task_entry:                      RTEMS Data Types List of Data Types.
                                                              (line 173)
* rtems_task_exitted_extension <1>:      User Extensions Manager TASK_EXITTED Extension.
                                                              (line  10)
* rtems_task_exitted_extension:          RTEMS Data Types List of Data Types.
                                                              (line 177)
* rtems_task_mode:                       Task Manager Task Mode.
                                                              (line   6)
* rtems_task_priority <1>:               Task Manager Task Priority.
                                                              (line   6)
* rtems_task_priority:                   RTEMS Data Types List of Data Types.
                                                              (line 180)
* rtems_task_restart_extension <1>:      User Extensions Manager TASK_RESTART Extension.
                                                              (line  11)
* rtems_task_restart_extension:          RTEMS Data Types List of Data Types.
                                                              (line 183)
* rtems_task_set_priority:               Task Manager TASK_SET_PRIORITY - Set task priority.
                                                              (line   6)
* rtems_task_start_extension <1>:        User Extensions Manager TASK_START Extension.
                                                              (line  12)
* rtems_task_start_extension:            RTEMS Data Types List of Data Types.
                                                              (line 186)
* rtems_task_switch_extension <1>:       User Extensions Manager TASK_SWITCH Extension.
                                                              (line  12)
* rtems_task_switch_extension:           RTEMS Data Types List of Data Types.
                                                              (line 189)
* rtems_tcb:                             RTEMS Data Types List of Data Types.
                                                              (line 192)
* rtems_time_of_day <1>:                 RTEMS Data Types List of Data Types.
                                                              (line 195)
* rtems_time_of_day:                     Key Concepts Time.   (line  44)
* rtems_timer_service_routine:           RTEMS Data Types List of Data Types.
                                                              (line 198)
* rtems_timer_service_routine_entry:     RTEMS Data Types List of Data Types.
                                                              (line 201)
* rtems_vector_number <1>:               Interrupt Manager Processing an Interrupt.
                                                              (line  14)
* rtems_vector_number:                   RTEMS Data Types List of Data Types.
                                                              (line 205)
* uint16_t:                              RTEMS Data Types List of Data Types.
                                                              (line 212)
* uint32_t:                              RTEMS Data Types List of Data Types.
                                                              (line 217)
* uint64_t:                              RTEMS Data Types List of Data Types.
                                                              (line 222)
* uint8_t:                               RTEMS Data Types List of Data Types.
                                                              (line 208)
* uintptr_t:                             RTEMS Data Types List of Data Types.
                                                              (line 227)


File: ada_user.info,  Node: Concept Index,  Prev: Command and Variable Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* add memory to a region:                Region Manager REGION_EXTEND - Add memory to a region.
                                                               (line  6)
* announce arrival of package:           Multiprocessing Manager MULTIPROCESSING_ANNOUNCE - Announce the arrival of a packet.
                                                               (line  6)
* announce fatal error:                  Fatal Error Manager FATAL_ERROR_OCCURRED - Invoke the fatal error handler.
                                                               (line  6)
* aperiodic task, definition:            Rate Monotonic Manager Rate Monotonic Manager Definitions.
                                                               (line 20)
* ASR:                                   Signal Manager Signal Manager Definitions.
                                                               (line  6)
* ASR mode, building:                    Signal Manager Building an ASR Mode.
                                                               (line  6)
* ASR vs. ISR:                           Signal Manager A Comparison of ASRs and ISRs.
                                                               (line  6)
* asynchronous signal routine:           Signal Manager Signal Manager Definitions.
                                                               (line  6)
* barrier:                               Barrier Manager.      (line 13)
* binary semaphores:                     Semaphore Manager.    (line 13)
* Board Support Packages:                Board Support Packages.
                                                               (line 14)
* broadcast message to a queue:          Message Manager MESSAGE_QUEUE_BROADCAST - Broadcast N messages to a queue.
                                                               (line  6)
* BSP, definition:                       Board Support Packages Introduction.
                                                               (line  6)
* BSPs:                                  Board Support Packages.
                                                               (line 14)
* buffers, definition:                   Partition Manager Partition Manager Definitions.
                                                               (line  9)
* build object id from components:       Object Services BUILD_ID - Build Object Id From Components.
                                                               (line  6)
* build object name:                     Object Services BUILD_NAME - Build object name from characters.
                                                               (line  6)
* cancel a period:                       Rate Monotonic Manager RATE_MONOTONIC_CANCEL - Cancel a period.
                                                               (line  6)
* cancel a timer:                        Timer Manager TIMER_CANCEL - Cancel a timer.
                                                               (line  6)
* chain append a node:                   Chains Append a Node. (line  6)
* chain extract a node:                  Chains Extract a Node.
                                                               (line  6)
* chain get first node:                  Chains Get the First Node.
                                                               (line  6)
* chain get head:                        Chains Head.          (line  6)
* chain get tail:                        Chains Tail.          (line  6)
* chain initialize:                      Chains Initialize Chain With Nodes.
                                                               (line  6)
* chain initialize empty:                Chains Initialize Empty.
                                                               (line  6)
* chain insert a node:                   Chains Insert a Node. (line  6)
* chain is chain empty:                  Chains Is the Chain Empty.
                                                               (line  6)
* chain is node null:                    Chains Is Null Node ?.
                                                               (line  6)
* chain is node the first:               Chains Is this the First Node on the Chain ?.
                                                               (line  6)
* chain is node the head:                Chains Is this Node the Chain Head ?.
                                                               (line  6)
* chain is node the last:                Chains Is this the Last Node on the Chain ?.
                                                               (line  6)
* chain is node the tail:                Chains Is this Node the Chain Tail ?.
                                                               (line  6)
* chain iterate:                         Chains Iterating a Chain.
                                                               (line  6)
* chain only one node:                   Chains Does this Chain have only One Node ?.
                                                               (line  6)
* chains:                                Chains.               (line 13)
* chare are nodes equal:                 Chains Are Two Nodes Equal ?.
                                                               (line  6)
* clock:                                 Clock Manager.        (line 13)
* clock get uptime:                      Clock Manager CLOCK_GET_UPTIME - Get the time since boot.
                                                               (line  6)
* clock set nanoseconds extension:       Clock Manager CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler.
                                                               (line  6)
* clock tick:                            Clock Manager CLOCK_TICK - Announce a clock tick.
                                                               (line  6)
* close a device:                        I/O Manager IO_CLOSE - Close a device.
                                                               (line  6)
* communication and synchronization:     Key Concepts Communication and Synchronization.
                                                               (line  6)
* conclude current period:               Rate Monotonic Manager RATE_MONOTONIC_PERIOD - Conclude current/Start next period.
                                                               (line  6)
* confdefs.h:                            Configuring a System Automatic Generation of System Configuration.
                                                               (line 21)
* Configuration Table:                   Configuring a System Configuration Table.
                                                               (line  6)
* convert external to internal address:  Dual-Ported Memory Manager PORT_EXTERNAL_TO_INTERNAL - Convert external to internal address.
                                                               (line  6)
* convert internal to external address:  Dual-Ported Memory Manager PORT_INTERNAL_TO_EXTERNAL - Convert internal to external address.
                                                               (line  6)
* counting semaphores:                   Semaphore Manager.    (line 13)
* CPU Dependent Information Table:       Configuring a System CPU Dependent Information Table.
                                                               (line  6)
* create a barrier:                      Barrier Manager BARRIER_CREATE - Create a barrier.
                                                               (line  6)
* create a message queue:                Message Manager MESSAGE_QUEUE_CREATE - Create a queue.
                                                               (line  6)
* create a partition:                    Partition Manager PARTITION_CREATE - Create a partition.
                                                               (line  6)
* create a period:                       Rate Monotonic Manager RATE_MONOTONIC_CREATE - Create a rate monotonic period.
                                                               (line  6)
* create a port:                         Dual-Ported Memory Manager PORT_CREATE - Create a port.
                                                               (line  6)
* create a region:                       Region Manager REGION_CREATE - Create a region.
                                                               (line  6)
* create a semaphore:                    Semaphore Manager SEMAPHORE_CREATE - Create a semaphore.
                                                               (line  6)
* create a task:                         Task Manager TASK_CREATE - Create a task.
                                                               (line  6)
* create a timer:                        Timer Manager TIMER_CREATE - Create a timer.
                                                               (line  6)
* create an extension set:               User Extensions Manager EXTENSION_CREATE - Create a extension set.
                                                               (line  6)
* current task mode:                     Task Manager TASK_MODE - Change the current task mode.
                                                               (line  6)
* current task priority:                 Task Manager TASK_SET_PRIORITY - Set task priority.
                                                               (line  6)
* delay a task for an interval:          Task Manager TASK_WAKE_AFTER - Wake up after interval.
                                                               (line  6)
* delay a task until a wall time:        Task Manager TASK_WAKE_WHEN - Wake up when specified.
                                                               (line  6)
* delays:                                Clock Manager Delays. (line  6)
* delete a barrier:                      Barrier Manager BARRIER_DELETE - Delete a barrier.
                                                               (line  6)
* delete a message queue:                Message Manager MESSAGE_QUEUE_DELETE - Delete a queue.
                                                               (line  6)
* delete a partition:                    Partition Manager PARTITION_DELETE - Delete a partition.
                                                               (line  6)
* delete a period:                       Rate Monotonic Manager RATE_MONOTONIC_DELETE - Delete a rate monotonic period.
                                                               (line  6)
* delete a port:                         Dual-Ported Memory Manager PORT_DELETE - Delete a port.
                                                               (line  6)
* delete a region:                       Region Manager REGION_DELETE - Delete a region.
                                                               (line  6)
* delete a semaphore:                    Semaphore Manager SEMAPHORE_DELETE - Delete a semaphore.
                                                               (line  6)
* delete a timer:                        Timer Manager TIMER_DELETE - Delete a timer.
                                                               (line  6)
* delete an extension set:               User Extensions Manager EXTENSION_DELETE - Delete a extension set.
                                                               (line  6)
* deleting a task:                       Task Manager TASK_DELETE - Delete a task.
                                                               (line  6)
* device driver interface:               I/O Manager Device Driver Interface.
                                                               (line  6)
* Device Driver Table <1>:               Configuring a System Driver Address Table.
                                                               (line  6)
* Device Driver Table:                   I/O Manager Device Driver Table.
                                                               (line  6)
* device drivers:                        I/O Manager.          (line 13)
* device names:                          I/O Manager Device Names.
                                                               (line  6)
* disable interrupts:                    Interrupt Manager INTERRUPT_DISABLE - Disable Interrupts.
                                                               (line  6)
* disabling interrupts:                  Interrupt Manager Disabling of Interrupts by RTEMS.
                                                               (line  6)
* dispatching:                           Scheduling Concepts Dispatching Tasks.
                                                               (line  6)
* dual ported memory:                    Dual-Ported Memory Manager.
                                                               (line 13)
* dual ported memory, definition:        Dual-Ported Memory Manager Background.
                                                               (line  6)
* enable interrupts:                     Interrupt Manager INTERRUPT_ENABLE - Enable Interrupts.
                                                               (line  6)
* establish an ASR:                      Signal Manager SIGNAL_CATCH - Establish an ASR.
                                                               (line  6)
* establish an ISR:                      Interrupt Manager INTERRUPT_CATCH - Establish an ISR.
                                                               (line  6)
* event condition, building:             Event Manager Building an Event Set or Condition.
                                                               (line  6)
* event flag, definition:                Event Manager Event Sets.
                                                               (line  6)
* event set, building:                   Event Manager Building an Event Set or Condition.
                                                               (line  6)
* event set, definition:                 Event Manager Event Sets.
                                                               (line  6)
* events:                                Event Manager.        (line 13)
* extension set:                         User Extensions Manager Extension Sets.
                                                               (line  6)
* external addresses, definition:        Dual-Ported Memory Manager Background.
                                                               (line  6)
* fatal error detection:                 Fatal Error Manager Background.
                                                               (line  6)
* fatal error processing:                Fatal Error Manager Background.
                                                               (line  6)
* fatal error user extension:            Fatal Error Manager Background.
                                                               (line  6)
* fatal error, announce:                 Fatal Error Manager FATAL_ERROR_OCCURRED - Invoke the fatal error handler.
                                                               (line  6)
* fatal errors:                          Fatal Error Manager.  (line 13)
* fire a task-based timer at wall time:  Timer Manager TIMER_SERVER_FIRE_WHEN - Fire task-based timer when specified.
                                                               (line  6)
* fire a timer after an interval:        Timer Manager TIMER_FIRE_AFTER - Fire timer after interval.
                                                               (line  6)
* fire a timer at wall time:             Timer Manager TIMER_FIRE_WHEN - Fire timer when specified.
                                                               (line  6)
* fire task-based a timer after an interval: Timer Manager TIMER_SERVER_FIRE_AFTER - Fire task-based timer after interval.
                                                               (line  6)
* flash interrupts:                      Interrupt Manager INTERRUPT_FLASH - Flash Interrupts.
                                                               (line  6)
* floating point:                        Task Manager Floating Point Considerations.
                                                               (line  6)
* flush a semaphore:                     Semaphore Manager SEMAPHORE_FLUSH - Unblock all tasks waiting on a semaphore.
                                                               (line  6)
* flush messages on a queue:             Message Manager MESSAGE_QUEUE_FLUSH - Flush all messages on a queue.
                                                               (line  6)
* get buffer from partition:             Partition Manager PARTITION_GET_BUFFER - Get buffer from a partition.
                                                               (line  6)
* get class from object ID:              Key Concepts Object ID Description.
                                                               (line 27)
* get ID of a barrier:                   Barrier Manager BARRIER_IDENT - Get ID of a barrier.
                                                               (line  6)
* get ID of a message queue:             Message Manager MESSAGE_QUEUE_IDENT - Get ID of a queue.
                                                               (line  6)
* get ID of a partition:                 Partition Manager PARTITION_IDENT - Get ID of a partition.
                                                               (line  6)
* get ID of a period:                    Rate Monotonic Manager RATE_MONOTONIC_IDENT - Get ID of a period.
                                                               (line  6)
* get ID of a port:                      Dual-Ported Memory Manager PORT_IDENT - Get ID of a port.
                                                               (line  6)
* get ID of a region:                    Region Manager REGION_IDENT - Get ID of a region.
                                                               (line  6)
* get ID of a semaphore:                 Semaphore Manager SEMAPHORE_IDENT - Get ID of a semaphore.
                                                               (line  6)
* get ID of a task:                      Task Manager TASK_IDENT - Get ID of a task.
                                                               (line  6)
* get ID of an extension set:            User Extensions Manager EXTENSION_IDENT - Get ID of a extension set.
                                                               (line  6)
* get index from object ID:              Key Concepts Object ID Description.
                                                               (line 27)
* get name from id:                      Object Services OBJECT_GET_CLASSIC_NAME - Lookup name from id.
                                                               (line  6)
* get node from object ID:               Key Concepts Object ID Description.
                                                               (line 27)
* get number of pending messages:        Message Manager MESSAGE_QUEUE_GET_NUMBER_PENDING - Get number of messages pending on a queue.
                                                               (line  6)
* get object name as string:             Object Services OBJECT_GET_NAME - Obtain object name as string.
                                                               (line  6)
* get per-task variable:                 Task Manager TASK_VARIABLE_GET - Obtain value of a per task variable.
                                                               (line  6)
* get segment from region:               Region Manager REGION_GET_SEGMENT - Get segment from a region.
                                                               (line  6)
* get size of segment:                   Region Manager REGION_GET_SEGMENT_SIZE - Obtain size of a segment.
                                                               (line  6)
* get statistics of period:              Rate Monotonic Manager RATE_MONOTONIC_GET_STATISTICS - Obtain statistics from a period.
                                                               (line  6)
* get status of period:                  Rate Monotonic Manager RATE_MONOTONIC_GET_STATUS - Obtain status from a period.
                                                               (line  6)
* get task mode:                         Task Manager TASK_MODE - Change the current task mode.
                                                               (line  6)
* get task notepad entry:                Task Manager TASK_GET_NOTE - Get task notepad entry.
                                                               (line  6)
* get task preemption mode:              Task Manager TASK_MODE - Change the current task mode.
                                                               (line  6)
* get task priority:                     Task Manager TASK_SET_PRIORITY - Set task priority.
                                                               (line  6)
* global objects table:                  Multiprocessing Manager Global Object Table.
                                                               (line  6)
* global objects, definition:            Multiprocessing Manager Global Objects.
                                                               (line  6)
* heterogeneous multiprocessing:         Multiprocessing Manager Supporting Heterogeneous Environments.
                                                               (line  6)
* initialization tasks:                  Initialization Manager Initialization Tasks.
                                                               (line  6)
* Initialization Tasks Table:            Configuring a System Initialization Task Table.
                                                               (line  6)
* initialize a device driver:            I/O Manager IO_INITIALIZE - Initialize a device driver.
                                                               (line  6)
* initialize device drivers:             Initialization Manager INITIALIZE_DEVICE_DRIVERS - Initialize Device Drivers.
                                                               (line  6)
* initialize RTEMS:                      Initialization Manager INITIALIZE_START_MULTITASKING - Complete Initialization and Start Multitasking.
                                                               (line  6)
* initialize RTEMS before device drivers: Initialization Manager INITIALIZE_BEFORE_DRIVERS - Perform Initialization Before Device Drivers.
                                                               (line  6)
* initialize RTEMS data structures:      Initialization Manager INITIALIZE_DATA_STRUCTURES - Initialize RTEMS Data Structures.
                                                               (line  6)
* initiate the Timer Server:             Timer Manager TIMER_INITIATE_SERVER - Initiate server for task-based timers.
                                                               (line  6)
* install an ASR:                        Signal Manager SIGNAL_CATCH - Establish an ASR.
                                                               (line  6)
* install an ISR:                        Interrupt Manager INTERRUPT_CATCH - Establish an ISR.
                                                               (line  6)
* internal addresses, definition:        Dual-Ported Memory Manager Background.
                                                               (line  6)
* interrupt level, task:                 Task Manager Task Mode.
                                                               (line 50)
* interrupt levels:                      Interrupt Manager RTEMS Interrupt Levels.
                                                               (line  6)
* interrupt processing:                  Interrupt Manager Processing an Interrupt.
                                                               (line  6)
* IO Control:                            I/O Manager IO_CONTROL - Special device services.
                                                               (line  6)
* IO Manager:                            I/O Manager.          (line 13)
* is interrupt in progress:              Interrupt Manager INTERRUPT_IS_IN_PROGRESS - Is an ISR in Progress.
                                                               (line  6)
* is task suspended:                     Task Manager TASK_IS_SUSPENDED - Determine if a task is Suspended.
                                                               (line  6)
* ISR vs. ASR:                           Signal Manager A Comparison of ASRs and ISRs.
                                                               (line  6)
* iterate over all threads:              Task Manager ITERATE_OVER_ALL_THREADS - Iterate Over Tasks.
                                                               (line  6)
* lock a barrier:                        Barrier Manager BARRIER_OBTAIN - Acquire a barrier.
                                                               (line  6)
* lock a semaphore:                      Semaphore Manager SEMAPHORE_OBTAIN - Acquire a semaphore.
                                                               (line  6)
* lookup device major and minor number:  I/O Manager IO_LOOKUP_NAME - Lookup a device.
                                                               (line  6)
* major device number:                   I/O Manager Major and Minor Device Numbers.
                                                               (line  6)
* manual round robin:                    Scheduling Concepts Manual Round-Robin.
                                                               (line  6)
* memory management:                     Key Concepts Memory Management.
                                                               (line  6)
* message queue attributes:              Message Manager Building a Message Queue Attribute Set.
                                                               (line  6)
* message queues:                        Message Manager.      (line 13)
* messages:                              Message Manager.      (line 13)
* minor device number:                   I/O Manager Major and Minor Device Numbers.
                                                               (line  6)
* MPCI and remote operations:            Multiprocessing Manager Remote Operations.
                                                               (line  6)
* MPCI entry points:                     Multiprocessing Manager Multiprocessor Communications Interface Layer.
                                                               (line 31)
* MPCI, definition:                      Multiprocessing Manager Multiprocessor Communications Interface Layer.
                                                               (line 24)
* multiprocessing:                       Multiprocessing Manager.
                                                               (line 14)
* multiprocessing topologies:            Multiprocessing Manager Background.
                                                               (line 15)
* Multiprocessor Communications Interface Table: Configuring a System Multiprocessor Communications Interface Table.
                                                               (line  6)
* Multiprocessor Configuration Table:    Configuring a System Multiprocessor Configuration Table.
                                                               (line  6)
* mutual exclusion:                      Semaphore Manager.    (line 13)
* nanoseconds extension:                 Clock Manager CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler.
                                                               (line  6)
* nanoseconds time accuracy:             Clock Manager CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler.
                                                               (line  6)
* nodes, definition:                     Multiprocessing Manager Nodes.
                                                               (line  6)
* object ID:                             Key Concepts Object IDs.
                                                               (line 11)
* object ID composition:                 Key Concepts Object IDs.
                                                               (line 11)
* object manipulation:                   Object Services.      (line 13)
* object name:                           Key Concepts Object Names.
                                                               (line  6)
* objects:                               Key Concepts Objects. (line 12)
* obtain a barrier:                      Barrier Manager BARRIER_OBTAIN - Acquire a barrier.
                                                               (line  6)
* obtain a semaphore:                    Semaphore Manager SEMAPHORE_OBTAIN - Acquire a semaphore.
                                                               (line  6)
* obtain API from id:                    Object Services OBJECT_ID_GET_API - Obtain API from Id.
                                                               (line  6)
* obtain API name:                       Object Services OBJECT_GET_API_NAME - Obtain API Name.
                                                               (line  6)
* obtain buffer from partition:          Partition Manager PARTITION_GET_BUFFER - Get buffer from a partition.
                                                               (line  6)
* obtain class from object id:           Object Services OBJECT_ID_GET_CLASS - Obtain Class from Id.
                                                               (line  6)
* obtain class information:              Object Services OBJECT_GET_CLASS_INFORMATION - Obtain Class Information.
                                                               (line  6)
* obtain class name:                     Object Services OBJECT_GET_API_CLASS_NAME - Obtain Class Name.
                                                               (line  6)
* obtain ID of a barrier:                Barrier Manager BARRIER_IDENT - Get ID of a barrier.
                                                               (line  6)
* obtain ID of a partition:              Partition Manager PARTITION_IDENT - Get ID of a partition.
                                                               (line  6)
* obtain ID of a period:                 Rate Monotonic Manager RATE_MONOTONIC_IDENT - Get ID of a period.
                                                               (line  6)
* obtain ID of a port:                   Dual-Ported Memory Manager PORT_IDENT - Get ID of a port.
                                                               (line  6)
* obtain ID of a region:                 Region Manager REGION_IDENT - Get ID of a region.
                                                               (line  6)
* obtain ID of a semaphore:              Semaphore Manager SEMAPHORE_IDENT - Get ID of a semaphore.
                                                               (line  6)
* obtain ID of an extension set:         User Extensions Manager EXTENSION_IDENT - Get ID of a extension set.
                                                               (line  6)
* obtain ID of caller:                   Task Manager TASK_SELF - Obtain ID of caller.
                                                               (line  6)
* obtain index from object id:           Object Services OBJECT_ID_GET_INDEX - Obtain Index from Id.
                                                               (line  6)
* obtain maximum API value:              Object Services OBJECT_ID_API_MAXIMUM - Obtain Maximum API Value.
                                                               (line  6)
* obtain maximum class value:            Object Services OBJECT_API_MAXIMUM_CLASS - Obtain Maximum Class Value.
                                                               (line  6)
* obtain minimum API value:              Object Services OBJECT_ID_API_MINIMUM - Obtain Minimum API Value.
                                                               (line  6)
* obtain minimum class value:            Object Services OBJECT_API_MINIMUM_CLASS - Obtain Minimum Class Value.
                                                               (line  6)
* obtain name from id:                   Object Services OBJECT_GET_CLASSIC_NAME - Lookup name from id.
                                                               (line  6)
* obtain node from object id:            Object Services OBJECT_ID_GET_NODE - Obtain Node from Id.
                                                               (line  6)
* obtain object name as string:          Object Services OBJECT_GET_NAME - Obtain object name as string.
                                                               (line  6)
* obtain per-task variable:              Task Manager TASK_VARIABLE_GET - Obtain value of a per task variable.
                                                               (line  6)
* obtain seconds since epoch <1>:        Clock Manager CLOCK_GET_TICKS_PER_SECOND - Get ticks per second.
                                                               (line  6)
* obtain seconds since epoch:            Clock Manager CLOCK_GET_SECONDS_SINCE_EPOCH - Get seconds since epoch.
                                                               (line  6)
* obtain statistics of period:           Rate Monotonic Manager RATE_MONOTONIC_GET_STATISTICS - Obtain statistics from a period.
                                                               (line  6)
* obtain status of period:               Rate Monotonic Manager RATE_MONOTONIC_GET_STATUS - Obtain status from a period.
                                                               (line  6)
* obtain task mode:                      Task Manager TASK_MODE - Change the current task mode.
                                                               (line  6)
* obtain task priority:                  Task Manager TASK_SET_PRIORITY - Set task priority.
                                                               (line  6)
* obtain the ID of a timer:              Timer Manager TIMER_IDENT - Get ID of a timer.
                                                               (line  6)
* obtain the time of day <1>:            Clock Manager CLOCK_GET_TOD_TIMEVAL - Get date and time in timeval format.
                                                               (line  6)
* obtain the time of day <2>:            Clock Manager CLOCK_GET_TOD - Get date and time in TOD format.
                                                               (line  6)
* obtain the time of day:                Clock Manager CLOCK_GET - Get date and time information.
                                                               (line  6)
* obtain ticks since boot:               Clock Manager CLOCK_GET_TICKS_SINCE_BOOT - Get ticks since boot.
                                                               (line  6)
* obtaining class from object ID:        Key Concepts Object ID Description.
                                                               (line 27)
* obtaining index from object ID:        Key Concepts Object ID Description.
                                                               (line 27)
* obtaining node from object ID:         Key Concepts Object ID Description.
                                                               (line 27)
* open a devive:                         I/O Manager IO_OPEN - Open a device.
                                                               (line  6)
* partition attribute set, building:     Partition Manager Building a Partition Attribute Set.
                                                               (line  6)
* partition, definition:                 Partition Manager Partition Manager Definitions.
                                                               (line  6)
* partitions:                            Partition Manager.    (line 13)
* per task variables:                    Task Manager Per Task Variables.
                                                               (line  6)
* per-task variable <1>:                 Task Manager TASK_VARIABLE_DELETE - Remove per task variable.
                                                               (line  6)
* per-task variable:                     Task Manager TASK_VARIABLE_ADD - Associate per task variable.
                                                               (line  6)
* period initiation:                     Rate Monotonic Manager RATE_MONOTONIC_PERIOD - Conclude current/Start next period.
                                                               (line  6)
* period statistics report:              Rate Monotonic Manager RATE_MONOTONIC_REPORT_STATISTICS - Print period statistics report.
                                                               (line  6)
* periodic task, definition:             Rate Monotonic Manager Rate Monotonic Manager Definitions.
                                                               (line  6)
* periodic tasks:                        Rate Monotonic Manager.
                                                               (line 13)
* ports:                                 Dual-Ported Memory Manager.
                                                               (line 13)
* POSIX API Configuration Table:         Configuring a System POSIX API Configuration Table.
                                                               (line  6)
* preemption <1>:                        Scheduling Concepts Preemption.
                                                               (line  6)
* preemption:                            Task Manager Task Mode.
                                                               (line 21)
* prepend node:                          Chains Prepend a Node.
                                                               (line  6)
* print period statistics report:        Rate Monotonic Manager RATE_MONOTONIC_REPORT_STATISTICS - Print period statistics report.
                                                               (line  6)
* priority, task:                        Task Manager Task Priority.
                                                               (line  6)
* proxy, definition:                     Multiprocessing Manager Proxies.
                                                               (line  6)
* put message at front of queue:         Message Manager MESSAGE_QUEUE_URGENT - Put message at front of a queue.
                                                               (line  6)
* rate mononitonic tasks:                Rate Monotonic Manager.
                                                               (line 13)
* Rate Monotonic Scheduling Algorithm, definition: Rate Monotonic Manager Rate Monotonic Scheduling Algorithm.
                                                               (line  6)
* read from a device:                    I/O Manager IO_READ - Read from a device.
                                                               (line  6)
* receive event condition:               Event Manager EVENT_RECEIVE - Receive event condition.
                                                               (line  6)
* receive message from a queue:          Message Manager MESSAGE_QUEUE_RECEIVE - Receive message from a queue.
                                                               (line  6)
* region attribute set, building:        Region Manager Building an Attribute Set.
                                                               (line  6)
* region, add memory:                    Region Manager REGION_EXTEND - Add memory to a region.
                                                               (line  6)
* region, definition:                    Region Manager Region Manager Definitions.
                                                               (line  6)
* regions:                               Region Manager.       (line 13)
* register a device driver:              I/O Manager IO_REGISTER_DRIVER - Register a device driver.
                                                               (line  6)
* register device:                       I/O Manager IO_REGISTER_NAME - Register a device.
                                                               (line  6)
* release a barrier:                     Barrier Manager BARRIER_RELEASE - Release a barrier.
                                                               (line  6)
* release a semaphore:                   Semaphore Manager SEMAPHORE_RELEASE - Release a semaphore.
                                                               (line  6)
* reset a timer:                         Timer Manager TIMER_RESET - Reset an interval timer.
                                                               (line  6)
* reset statistics of all periods:       Rate Monotonic Manager RATE_MONOTONIC_RESET_ALL_STATISTICS - Reset statistics for all periods.
                                                               (line  6)
* reset statistics of period:            Rate Monotonic Manager RATE_MONOTONIC_RESET_STATISTICS - Reset statistics for a period.
                                                               (line  6)
* resize segment:                        Region Manager REGION_RESIZE_SEGMENT - Change size of a segment.
                                                               (line  6)
* restarting a task:                     Task Manager TASK_RESTART - Restart a task.
                                                               (line  6)
* resuming a task:                       Task Manager TASK_RESUME - Resume a task.
                                                               (line  6)
* return buffer to partitition:          Partition Manager PARTITION_RETURN_BUFFER - Return buffer to a partition.
                                                               (line  6)
* return segment to region:              Region Manager REGION_RETURN_SEGMENT - Return segment to a region.
                                                               (line  6)
* RMS Algorithm, definition:             Rate Monotonic Manager Rate Monotonic Scheduling Algorithm.
                                                               (line  6)
* RMS First Deadline Rule:               Rate Monotonic Manager First Deadline Rule.
                                                               (line  6)
* RMS Processor Utilization Rule:        Rate Monotonic Manager Processor Utilization Rule.
                                                               (line  6)
* RMS schedulability analysis:           Rate Monotonic Manager Schedulability Analysis.
                                                               (line 16)
* round robin scheduling:                Scheduling Concepts Timeslicing.
                                                               (line  6)
* RTEMS API Configuration Table:         Configuring a System RTEMS API Configuration Table.
                                                               (line  6)
* RTEMS Configuration Table:             Configuring a System Configuration Table.
                                                               (line  6)
* runtime driver registration:           I/O Manager Runtime Driver Registration.
                                                               (line  6)
* scheduling:                            Scheduling Concepts.  (line 12)
* scheduling mechanisms:                 Scheduling Concepts Scheduling Mechanisms.
                                                               (line 14)
* segment, definition:                   Region Manager Region Manager Definitions.
                                                               (line  6)
* semaphores:                            Semaphore Manager.    (line 13)
* send event set to a task:              Event Manager EVENT_SEND - Send event set to a task.
                                                               (line  6)
* send message to a queue:               Message Manager MESSAGE_QUEUE_SEND - Put message at rear of a queue.
                                                               (line  6)
* send signal set:                       Signal Manager SIGNAL_SEND - Send signal set to a task.
                                                               (line  6)
* set object name:                       Object Services OBJECT_SET_NAME - Set object name.
                                                               (line  6)
* set task mode:                         Task Manager TASK_MODE - Change the current task mode.
                                                               (line  6)
* set task notepad entry:                Task Manager TASK_SET_NOTE - Set task notepad entry.
                                                               (line  6)
* set task preemption mode:              Task Manager TASK_MODE - Change the current task mode.
                                                               (line  6)
* set task priority:                     Task Manager TASK_SET_PRIORITY - Set task priority.
                                                               (line  6)
* set the time of day:                   Clock Manager CLOCK_SET - Set date and time.
                                                               (line  9)
* shutdown RTEMS:                        Initialization Manager SHUTDOWN_EXECUTIVE - Shutdown RTEMS.
                                                               (line  6)
* signal set, building:                  Signal Manager Building a Signal Set.
                                                               (line  6)
* signals:                               Signal Manager.       (line 13)
* special device services:               I/O Manager IO_CONTROL - Special device services.
                                                               (line  6)
* sporadic task, definition:             Rate Monotonic Manager Rate Monotonic Manager Definitions.
                                                               (line 25)
* start current period:                  Rate Monotonic Manager RATE_MONOTONIC_PERIOD - Conclude current/Start next period.
                                                               (line  6)
* start multitasking:                    Initialization Manager INITIALIZE_START_MULTITASKING - Complete Initialization and Start Multitasking.
                                                               (line  6)
* starting a task:                       Task Manager TASK_START - Start a task.
                                                               (line  6)
* suspending a task:                     Task Manager TASK_SUSPEND - Suspend a task.
                                                               (line  6)
* task arguments:                        Task Manager Accessing Task Arguments.
                                                               (line  6)
* task attributes, building:             Task Manager Building a Task Attribute Set.
                                                               (line  6)
* task mode:                             Task Manager Task Mode.
                                                               (line  6)
* task mode, building:                   Task Manager Building a Mode and Mask.
                                                               (line  6)
* task priority <1>:                     Scheduling Concepts Task Priority and Scheduling.
                                                               (line  6)
* task priority:                         Task Manager Task Priority.
                                                               (line  6)
* task private data <1>:                 Task Manager TASK_VARIABLE_DELETE - Remove per task variable.
                                                               (line  6)
* task private data:                     Task Manager TASK_VARIABLE_ADD - Associate per task variable.
                                                               (line  6)
* task private variable <1>:             Task Manager TASK_VARIABLE_DELETE - Remove per task variable.
                                                               (line  6)
* task private variable:                 Task Manager TASK_VARIABLE_ADD - Associate per task variable.
                                                               (line  6)
* task prototype:                        Task Manager Accessing Task Arguments.
                                                               (line  6)
* task scheduling:                       Scheduling Concepts.  (line 12)
* task state transitions:                Scheduling Concepts Task State Transitions.
                                                               (line  6)
* task states:                           Task Manager Task States.
                                                               (line  6)
* task, definition:                      Task Manager Task Definition.
                                                               (line  6)
* tasks:                                 Task Manager.         (line 13)
* TCB extension area:                    User Extensions Manager TCB Extension Area.
                                                               (line  6)
* time:                                  Key Concepts Time.    (line  6)
* timeouts:                              Clock Manager Timeouts.
                                                               (line  6)
* timers:                                Timer Manager.        (line 13)
* timeslicing <1>:                       Scheduling Concepts Timeslicing.
                                                               (line  6)
* timeslicing <2>:                       Clock Manager Clock Tick and Timeslicing.
                                                               (line  6)
* timeslicing:                           Task Manager Task Mode.
                                                               (line 30)
* unblock all tasks waiting on a semaphore: Semaphore Manager SEMAPHORE_FLUSH - Unblock all tasks waiting on a semaphore.
                                                               (line  6)
* unlock a semaphore:                    Semaphore Manager SEMAPHORE_RELEASE - Release a semaphore.
                                                               (line  6)
* unregister a device driver:            I/O Manager IO_UNREGISTER_DRIVER - Unregister a device driver.
                                                               (line  6)
* uptime:                                Clock Manager CLOCK_GET_UPTIME - Get the time since boot.
                                                               (line  6)
* user extensions:                       User Extensions Manager.
                                                               (line 13)
* User Extensions Table:                 Configuring a System User Extensions Table.
                                                               (line  6)
* wait at a barrier:                     Barrier Manager BARRIER_RELEASE - Release a barrier.
                                                               (line  6)
* wake up after an interval:             Task Manager TASK_WAKE_AFTER - Wake up after interval.
                                                               (line  6)
* wake up at a wall time:                Task Manager TASK_WAKE_WHEN - Wake up when specified.
                                                               (line  6)
* write to a device:                     I/O Manager IO_WRITE - Write to a device.
                                                               (line  6)



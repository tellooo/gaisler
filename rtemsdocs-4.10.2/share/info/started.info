This is started.info, produced by makeinfo version 4.13 from
started.texi.

INFO-DIR-SECTION RTEMS On-Line Manual
START-INFO-DIR-ENTRY
* Getting Started with RTEMS: (started).
END-INFO-DIR-ENTRY


File: started.info,  Node: Introduction,  Next: Real-Time Embedded Systems,  Prev: Top,  Up: Top

1 Introduction
**************

* Menu:

* Real-Time Embedded Systems::
* Cross Development::
* Resources on the Internet::

The purpose of this document is to guide you through the process of
installing a GNU cross development environment to use with RTEMS.

   If you are already familiar with the concepts behind a cross
compiler and have a background in Unix, these instructions should
provide the bare essentials for performing a setup of the following
items:

   * GNU Cross Compilation Tools for RTEMS on your build-host system

   * RTEMS OS for the target

   * GDB Debugger

   The remainder of this chapter provides background information on
real-time embedded systems and cross development and an overview of
other resources of interest on the Internet.  If you are not familiar
with real-time embedded systems or the other areas, please read those
sections.  These sections will help familiarize you with the types of
systems RTEMS is designed to be used in and the cross development
process used when developing RTEMS applications.


File: started.info,  Node: Real-Time Embedded Systems,  Next: Cross Development,  Prev: Introduction,  Up: Introduction

1.1 Real-Time Embedded Systems
==============================

Real-time embedded systems are found in practically every facet of our
everyday lives.  Today's systems range from the common telephone,
automobile control systems, and kitchen appliances to complex air
traffic control systems, military weapon systems, and production line
control including robotics and automation. However, in the current
climate of rapidly changing technology, it is difficult to reach a
consensus on the definition of a real-time embedded system. Hardware
costs are continuing to rapidly decline while at the same time the
hardware is increasing in power and functionality.  As a result,
embedded systems that were not considered viable two years ago are
suddenly a cost effective solution. In this domain, it is not uncommon
for a single hardware configuration to employ a variety of
architectures and technologies. Therefore, we shall define an embedded
system as any computer system that is built into a larger system
consisting of multiple technologies such as digital and analog
electronics,  mechanical devices, and sensors.

   Even as hardware platforms become more powerful, most embedded
systems are critically dependent on the real-time software embedded in
the systems themselves.  Regardless of how efficiently the hardware
operates, the performance of the embedded real-time software determines
the success of the system.  As the complexity of the embedded hardware
platform grows, so does the size and complexity of the embedded
software. Software systems must routinely perform activities which were
only dreamed of a short time ago.  These large, complex, real-time
embedded applications now commonly contain one million lines of code or
more.

   Real-time embedded systems have a complex set of characteristics that
distinguish them from other software applications.  Real-time embedded
systems are driven by and must respond to real world events while
adhering to rigorous requirements imposed by the environment with which
they interact.  The correctness of the system depends not only on the
results of computations, but also on the time at which the results are
produced.  The most important and complex characteristic of real-time
application systems is that they must receive and respond to a set of
external stimuli within rigid and critical time constraints.

   A single real-time application can be composed of both soft and hard
real-time components. A typical example of a hard real-time system is a
nuclear reactor control system that must not only detect failures, but
must also respond quickly enough to prevent a meltdown. This
application also has soft real-time requirements because it may involve
a man-machine interface.  Providing an interactive input to the control
system is not as critical as setting off an alarm to indicate a failure
condition. However, the interactive system component must respond
within an acceptable time limit to allow the operator to interact
efficiently with the control system.


File: started.info,  Node: Cross Development,  Next: Resources on the Internet,  Prev: Real-Time Embedded Systems,  Up: Introduction

1.2 Cross Development
=====================

Today almost all real-time embedded software systems are developed in a
cross development environment using cross development tools. In the
cross development environment, software development activities are
typically performed on one computer system, the build-host system,
while the result of the development effort (produced by the cross
tools) is a software system that executes on the target platform. The
requirements for the target platform are usually incompatible and quite
often in direct conflict with the requirements for the build-host.
Moreover, the target hardware is often custom designed for a particular
project.  This means that the cross development toolset must allow the
developer to customize the tools to address target specific run-time
issues.  The toolset must have provisions for board dependent
initialization code, device drivers, and error handling code.

   The build-host computer is optimized to support the code development
cycle with support for code editors, compilers, and linkers requiring
large disk drives, user development windows, and multiple developer
connections.  Thus the build-host computer is typically a traditional
UNIX workstation such as those available from SUN or Silicon Graphics,
or a PC running either a version of MS-Windows or UNIX.  The build-host
system may also be required to execute office productivity applications
to allow the software developer to write  documentation, make
presentations, or track the project's progress using a project
management tool.  This necessitates that the build-host computer be
general purpose with resources such as a thirty-two or sixty-four bit
processor, large amounts of RAM, a  monitor, mouse, keyboard, hard and
floppy disk drives, CD-ROM drive, and a graphics card.  It is likely
that the system will be multimedia capable and have some networking
capability.

   Conversely, the target platform generally has limited traditional
computer resources.  The hardware is designed for the particular
functionality and requirements of the embedded system and optimized to
perform those tasks effectively.  Instead of hard drives and keyboards,
it is composed of sensors, relays, and stepper motors. The per-unit
cost of the target platform is typically a critical concern.  No
hardware component is included without being cost justified.  As a
result, the processor of the target system is often from a different
processor family than that of the build-host system and usually has
lower performance.  In addition to the processor families designed only
for use in embedded systems, there are versions of nearly every
general-purpose processor specifically tailored for real-time embedded
systems.  For example, many of the processors targeting the embedded
market do not include hardware floating point units, but do include
peripherals such as timers, serial controllers, or network interfaces.


File: started.info,  Node: Resources on the Internet,  Next: Online Tool Documentation,  Prev: Cross Development,  Up: Introduction

1.3 Resources on the Internet
=============================

* Menu:

* Online Tool Documentation::
* RTEMS Mailing List::
* CrossGCC Mailing List::
* GCC Mailing Lists::

This section describes various resources on the Internet which are of
use to RTEMS users.


File: started.info,  Node: Online Tool Documentation,  Next: RTEMS Mailing List,  Prev: Resources on the Internet,  Up: Resources on the Internet

1.3.1 Online Tool Documentation
-------------------------------

Each of the tools in the GNU development suite comes with documentation.
It is in the reader's and tool maintainers' interest that one read the
documentation before posting a problem to a mailing list or news group.
The RTEMS Project provides formatted documentation for the primary
tools in the cross development toolset including BINUTILS, GCC, NEWLIB,
and GDB with the pre-built versions of those tools.

   Much of the documentation is available at other sites on the
Internet.  The following is a list of URLs where one can find HTML
versions of the GNU manuals:

Free Software Foundation
     http://www.gnu.org/manual/manual.html
     (http://www.gnu.org/manual/manual.html)

Delorie Software
     http://www.delorie.com/gnu/docs (http://www.delorie.com/gnu/docs)



File: started.info,  Node: RTEMS Mailing List,  Next: CrossGCC Mailing List,  Prev: Online Tool Documentation,  Up: Resources on the Internet

1.3.2 RTEMS Mailing List
------------------------

rtems-users@rtems.com (mailto:rtems-users@rtems.com)

   This mailing list is dedicated to the discussion of issues related
to RTEMS, including GNAT/RTEMS.  If you have questions about RTEMS,
wish to make suggestions, or just want to pick up hints, this is a good
list to monitor.  Subscribe by sending an empty mail message to
rtems-users-subscribe@rtems.com
(mailto:rtems-users-subscribe@rtems.com).  Messages sent to
rtems-users@rtems.com (mailto:rtems-users@rtems.com) are posted to the
list.


File: started.info,  Node: CrossGCC Mailing List,  Next: GCC Mailing Lists,  Prev: RTEMS Mailing List,  Up: Resources on the Internet

1.3.3 CrossGCC Mailing List
---------------------------

crossgcc@sources.redhat.com (mailto:crossgcc@sources.redhat.com)

   This mailing list is dedicated to the use of the GNU tools in cross
development environments.  Most of the discussions focus on embedded
issues.  Information on subscribing to this mailing list is included in
the CrossGCC FAQ (http://www.objsw.com/CrossGCC/).

   The CrossGCC FAQ and Wiki are are available at
http://www.billgatliff.com (http://www.billgatliff.com).


File: started.info,  Node: GCC Mailing Lists,  Next: Requirements,  Prev: CrossGCC Mailing List,  Up: Resources on the Internet

1.3.4 GCC Mailing Lists
-----------------------

The GCC Project is hosted at http://gcc.gnu.org (http://gcc.gnu.org).
They maintain multiple mailing lists that are described at the web site
along with subscription information.


File: started.info,  Node: Requirements,  Next: Disk Space,  Prev: GCC Mailing Lists,  Up: Top

2 Requirements
**************

* Menu:

* Disk Space::
* General Host Software Requirements::
* Host Specific Notes::
* Archive and Build Directories::

This chapter describes the build-host system requirements and initial
steps in installing the GNU Cross Compiler Tools and RTEMS on a
build-host.


File: started.info,  Node: Disk Space,  Next: General Host Software Requirements,  Prev: Requirements,  Up: Requirements

2.1 Disk Space
==============

A fairly large amount of disk space is required to perform the build of
the GNU C/C++ Cross Compiler Tools for RTEMS. The following table may
help in assessing the amount of disk space required for your
installation:

     +------------------------------------+--------------------------+
     |              Component             |   Disk Space Required    |
     +------------------------------------+--------------------------+
     |        archive directory           |        55 Mbytes         |
     |        tools src unarchived        |       350 Mbytes         |
     |  each individual build directory   |     up to 750 Mbytes     |
     |     each installation directory    |      20-200 Mbytes       |
     +------------------------------------+--------------------------+

   It is important to understand that the above requirements only
address the GNU C/C++ Cross Compiler Tools themselves.  Adding
additional languages such as Fortran or Objective-C can increase the
size of the build and installation directories.  Also, the unarchived
source and build directories can be removed after the tools are
installed.

   After the tools themselves are installed, RTEMS must be built and
installed for each Board Support Package that you wish to use.  Thus
the precise amount of disk space required for each installation
directory depends highly on the number of RTEMS BSPs which are to be
installed.  If a single BSP is installed, then the additional size of
each install directory will tend to be in the 40-60 Mbyte range.

   There are a number of factors which must be taken into account in
order to estimate the amount of disk space required to build RTEMS
itself.  Attempting to build multiple BSPs in a single step increases
the disk space requirements.  Similarly enabling optional features
increases the build and install space requirements.  In particular,
enabling and building the RTEMS tests results in a significant increase
in build space requirements but since the tests are not installed has,
enabling them has no impact on installation requirements.


File: started.info,  Node: General Host Software Requirements,  Next: GCC,  Prev: Disk Space,  Up: Requirements

2.2 General Host Software Requirements
======================================

* Menu:

* GCC::
* GNU Make::
* GNU makeinfo Version Requirements::

The instructions in this manual should work on any computer running a
UNIX variant.  Some native GNU tools are used by this procedure
including:

   * GCC

   * GNU make

   * GNU makeinfo

   In addition, some native utilities may be deficient for building the
GNU tools.


File: started.info,  Node: GCC,  Next: GNU Make,  Prev: General Host Software Requirements,  Up: General Host Software Requirements

2.2.1 GCC
---------

Although RTEMS itself is intended to execute on an embedded target,
there is source code for some native programs included with the RTEMS
distribution.  Some of these programs are used to assist in the building
of RTEMS itself, while others are BSP specific tools.  Regardless, no
attempt has been made to compile these programs with a non-GNU compiler.


File: started.info,  Node: GNU Make,  Next: GNU makeinfo Version Requirements,  Prev: GCC,  Up: General Host Software Requirements

2.2.2 GNU Make
--------------

Both NEWLIB and RTEMS use GNU make specific features and can only be
built using GNU make.  Many systems include a make utility that is not
GNU make.  The safest way to meet this requirement is to ensure that
when you invoke the command `make', it is GNU make.  This can be
verified by attempting to print the GNU make version information:

     make --version

   If you have GNU make and another make on your system, it is common
to put the directory containing GNU make before the directory
containing other implementations of make.


File: started.info,  Node: GNU makeinfo Version Requirements,  Next: Host Specific Notes,  Prev: GNU Make,  Up: General Host Software Requirements

2.2.3 GNU makeinfo Version Requirements
---------------------------------------

In order to build gcc 2.9.x or newer versions, the GNU `makeinfo'
program installed on your system must be at least version 1.68.  The
appropriate version of `makeinfo' is distributed with `gcc'.

   The following demonstrates how to determine the version of `makeinfo'
on your machine:

     makeinfo --version


File: started.info,  Node: Host Specific Notes,  Next: Solaris 2.x,  Prev: GNU makeinfo Version Requirements,  Up: Requirements

2.3 Host Specific Notes
=======================

* Menu:

* Solaris 2.x::
* Linux::


File: started.info,  Node: Solaris 2.x,  Next: Linux,  Prev: Host Specific Notes,  Up: Host Specific Notes

2.3.1 Solaris 2.x
-----------------

The following problems have been reported by Solaris 2.x users:

   * The build scripts are written in "shell".  The program `/bin/sh'
     on Solaris 2.x is not robust enough to execute these scripts.  If
     you are on a Solaris 2.x host, then use the `/bin/ksh' or
     `/bin/bash' shell instead.

   * The native `patch' program is broken.  Install the GNU version.

   * The native `m4' program is deficient.  Install the GNU version.



File: started.info,  Node: Linux,  Next: Archive and Build Directories,  Prev: Solaris 2.x,  Up: Host Specific Notes

2.3.2 Linux
-----------

The following problems have been reported by Linux users:

   * Certain versions of GNU fileutils include a version of `install'
     which does not work properly.  Please perform the following test
     to see if you need to upgrade:

          install -c -d /tmp/foo/bar

     If this does not create the specified directories your install
     program will not install RTEMS properly.   You will need to upgrade
     to at least GNU fileutils version 3.16 to resolve this problem.



File: started.info,  Node: Archive and Build Directories,  Next: RPM Archive and Build Directory Format,  Prev: Linux,  Up: Requirements

2.4 Archive and Build Directories
=================================

* Menu:

* RPM Archive and Build Directory Format::
* Archive and Build Directory Format::

If you are using RPM or another packaging format that supports building
a package from source, then there is probably a directory structure
assumed by that packaging format.  Otherwise, you are free to use
whatever organization you like.  However, this document will use the
directory organization described in *note Archive and Build Directory
Format::.


File: started.info,  Node: RPM Archive and Build Directory Format,  Next: Archive and Build Directory Format,  Prev: Archive and Build Directories,  Up: Archive and Build Directories

2.4.1 RPM Archive and Build Directory Format
--------------------------------------------

For RPM, it is assumed that the following subdirectories are under a
root directory such as `/usr/src/redhat':

     BUILD
     RPMS
     SOURCES
     SPECS
     SRPMS

   For the purposes of this document, the RPM `SOURCES' directory is
the directory into which all tool source and patches are assumed to
reside.  The `BUILD' directory is where the actual build is performed
when building binaries from a source RPM.  The `SOURCES' and `BUILD'
are logically equivalent to the `archive' and `tools' directory
discussed in the next section.


File: started.info,  Node: Archive and Build Directory Format,  Next: Prebuilt Toolset Executables,  Prev: RPM Archive and Build Directory Format,  Up: Archive and Build Directories

2.4.2 Archive and Build Directory Format
----------------------------------------

When no packaging format requirements are present, the root directory
for the storage of source archives and patches as well as for building
the tools is up to the user.  The only concern is that there be enough
disk space to complete the build.  In this document, the following
organization will be used.

   Make an `archive' directory to contain the downloaded source code
and a `tools' directory to be used as a build directory.  The command
sequence to do this is shown below:

     mkdir archive
     mkdir tools

   This will result in an initial directory structure similar to the
one shown in the following figure:

     /whatever/prefix/you/choose/
             archive/
             tools/


File: started.info,  Node: Prebuilt Toolset Executables,  Next: RPMs,  Prev: Archive and Build Directory Format,  Up: Top

3 Prebuilt Toolset Executables
******************************

* Menu:

* RPMs::
* Zipped Tar Files::

Precompiled toolsets are available for Linux, Cygwin, FreeBSD, and
Solaris.  These are packaged in the following formats:

   * Linux - RPM

   * Cygwin - tar.bz2

   * Solaris - tar.bz2

   RPM is an acronym for the RPM Package Manager.  RPM is the native
package installer for many Linux distributions including RedHat, SuSE,
and Fedora.

   The prebuilt binaries are intended to be easy to install and the
instructions are similar regardless of the host environment.  There are
a few structural issues with the packaging of the RTEMS Cross Toolset
binaries that you need to be aware of.

  1. There are dependencies between the various packages.  This
     requires that certain packages be installed before others may be.
     Some packaging formats enforce this dependency.

  2. Some packages are target CPU family independent and shared across
     all target architectures.   These are referred to as "base"
     packages.

  3. Depending upon the version of GCC as well as the development host
     and target CPU combination, pre-built supplemental packages may be
     provided for Ada (gnat), Chill, Java (gcj), Fortran (g77), and
     Objective-C (objc).  These binaries are strictly optional.


   NOTE: Installing toolset binaries does not install RTEMS itself, only
the tools required to build RTEMS.  See *note Building RTEMS:: for the
next step in the process.


File: started.info,  Node: RPMs,  Next: Installing RPMs,  Prev: Prebuilt Toolset Executables,  Up: Prebuilt Toolset Executables

3.1 RPMs
========

* Menu:

* Installing RPMs::
* Determining Which RTEMS RPMs are Installed::
* Removing RPMs::

This section provides information on installing and removing RPMs.


File: started.info,  Node: Installing RPMs,  Next: Determining Which RTEMS RPMs are Installed,  Prev: RPMs,  Up: RPMs

3.1.1 Installing RPMs
---------------------

The following is a sample session illustrating the installation of a
C/C++ toolset targeting the SPARC architecture.

     rpm -U rtems-4.10-binutils-common-2.18.91-1.i386.rpm
     rpm -U rtems-4.10-sparc-rtems4.10-binutils-2.18.91-1.i386.rpm
     rpm -U rtems-4.10-gcc-common-4.3.2-3.i386.rpm
     rpm -U rtems-4.10-sparc-rtems4.10-newlib-1.16.0-3.i386.rpm
     rpm -U rtems-4.10-sparc-rtems4.10-gcc-4.3.2-3.i386.rpm
     rpm -U rtems-4.10-sparc-rtems4.10-gcc-c++-4.3.2-3.i386.rpm
     rpm -U rtems-4.10-gdb-common-6.8-3.i386.rpm
     rpm -U rtems-4.10-sparc-rtems4.10-gdb-6.8-3.i386.rpm

   Upon successful completion of the above command sequence, a C/C++
cross development toolset targeting the SPARC is installed in
`/opt/rtems-4.10'.  In order to use this toolset, the directory
`/opt/rtems-4.10/bin' must be included in your PATH.

   Once you have successfully installed the RPMs for BINUTILS, GCC,
NEWLIB, and GDB, then you may proceed directly to *note Building
RTEMS::.


File: started.info,  Node: Determining Which RTEMS RPMs are Installed,  Next: Removing RPMs,  Prev: Installing RPMs,  Up: RPMs

3.1.2 Determining Which RTEMS RPMs are Installed
------------------------------------------------

The following command will report which RTEMS RPMs are currently
installed:

     rpm -q -g RTEMS/4.10


File: started.info,  Node: Removing RPMs,  Next: Zipped Tar Files,  Prev: Determining Which RTEMS RPMs are Installed,  Up: RPMs

3.1.3 Removing RPMs
-------------------

The following is a sample session illustrating the removal of a C/C++
toolset targeting the SPARC architecture.

     rpm -e rtems-4.10-sparc-rtems4.10-gdb
     rpm -e rtems-4.10-gdb-common
     rpm -e rtems-4.10-sparc-rtems4.10-gcc-c++
     rpm -e rtems-4.10-sparc-rtems4.10-gcc
     rpm -e rtems-4.10-sparc-rtems4.10-newlib
     rpm -e rtems-4.10-gcc-common
     rpm -e rtems-4.10-sparc-rtems4.10-binutils
     rpm -e rtems-4.10-binutils-common

   NOTE:  If you have installed any RTEMS BSPs, then it is likely that
RPM will complain about not being able to remove everything.


File: started.info,  Node: Zipped Tar Files,  Next: Installing Zipped Tar Files,  Prev: Removing RPMs,  Up: Prebuilt Toolset Executables

3.2 Zipped Tar Files
====================

* Menu:

* Installing Zipped Tar Files::
* Removing Zipped Tar Files::

This section provides information on installing and removing Zipped Tar
Files (e.g .tar.gz or .tar.bz2).


File: started.info,  Node: Installing Zipped Tar Files,  Next: Removing Zipped Tar Files,  Prev: Zipped Tar Files,  Up: Zipped Tar Files

3.2.1 Installing Zipped Tar Files
---------------------------------

The following is a sample session illustrating the installation of a
C/C++ toolset targeting the SPARC architecture assuming that GNU tar is
installed as `tar' for a set of archive files compressed with GNU Zip
(gzip):

     cd /
     tar xzf rtems-4.10-binutils-common-2.18.91-1.tar.gz
     tar xzf rtems-4.10-sparc-rtems4.10-binutils-2.18.91-1.tar.gz
     tar xzf rtems-4.10-gcc-common-4.3.2-3.tar.gz
     tar xzf rtems-4.10-sparc-rtems4.10-gcc-4.3.2-3.tar.gz
     tar xzf rtems-4.10-sparc-rtems4.10-newlib-1.16.0-3.tar.gz
     tar xzf rtems-4.10-gdb-common-6.8-3.tar.gz
     tar xzf rtems-4.10-sparc-rtems4.10-gdb-6.8-3.tar.gz

   The following command set is the equivalent command sequence for the
same toolset assuming that is was compressed with GNU BZip (bzip2):

     cd /
     tar xjf rtems-4.10-binutils-common-2.18.91-1.tar.bz2
     tar xjf rtems-4.10-sparc-rtems4.10-binutils-2.18.91-1.tar.bz2
     tar xjf rtems-4.10-gcc-common-4.3.2-3.tar.bz2
     tar xjf rtems-4.10-sparc-rtems4.10-newlib-1.16.0-3.tar.bz2
     tar xjf rtems-4.10-sparc-rtems4.10-gcc-4.3.2-3.tar.bz2
     tar xjf rtems-4.10-gdb-common-6.8-3.tar.bz2
     tar xjf rtems-4.10-sparc-rtems4.10-gdb-6.8-3.tar.bz2

   Upon successful completion of the above command sequence, a C/C++
cross development toolset targeting the SPARC is installed in
`/opt/rtems-4.10'.  In order to use this toolset, the directory
`/opt/rtems-4.10' must be included in your PATH.


File: started.info,  Node: Removing Zipped Tar Files,  Next: Building the GNU Cross Compiler Toolset,  Prev: Installing Zipped Tar Files,  Up: Zipped Tar Files

3.2.2 Removing Zipped Tar Files
-------------------------------

There is no automatic way to remove the contents of a `tar.gz' or
`tar.bz2' once it is installed.  The contents of the directory
`/opt/rtems-4.10' can be removed but this will likely result in other
packages being removed as well.


File: started.info,  Node: Building the GNU Cross Compiler Toolset,  Next: Building BINUTILS GCC and NEWLIB,  Prev: Removing Zipped Tar Files,  Up: Top

4 Building the GNU Cross Compiler Toolset
*****************************************

* Menu:

* Building BINUTILS GCC and NEWLIB::
* Building the GNU Debugger GDB::
* Common Problems::

NOTE:  This chapter does NOT apply if you installed prebuilt toolset
executables for BINUTILS, GCC, NEWLIB, and GDB.  If you installed
prebuilt executables for all of those, proceed to *note Building
RTEMS::.  If you require a GDB with a special configuration to connect
to your target board, then proceed to *note Building the GNU Debugger
GDB:: for some advice.

   This chapter describes the steps required to acquire the source code
for a GNU cross compiler toolset, apply any required RTEMS specific
patches, compile that toolset and install it.

   It is recommended that when toolset binaries are available for your
particular host, that they be used.  Prebuilt binaries are much easier
to install.


File: started.info,  Node: Building BINUTILS GCC and NEWLIB,  Next: Obtain Source and Patches for BINUTILS GCC and NEWLIB,  Prev: Building the GNU Cross Compiler Toolset,  Up: Building the GNU Cross Compiler Toolset

4.1 Building BINUTILS GCC and NEWLIB
====================================

* Menu:

* Obtain Source and Patches for BINUTILS GCC and NEWLIB::
* Unarchiving the Tools::
* Applying RTEMS Patches::
* Compiling and Installing BINUTILS GCC and NEWLIB::

NOTE: This step is NOT required if prebuilt executables for BINUTILS,
GCC, and NEWLIB were installed.

   This section describes the process of building BINUTILS, GCC, and
NEWLIB using a variety of methods.  Included is information on
obtaining the source code and patches, applying patches, and building
and installing the tools using multiple methods.


File: started.info,  Node: Obtain Source and Patches for BINUTILS GCC and NEWLIB,  Next: Unarchiving the Tools,  Prev: Building BINUTILS GCC and NEWLIB,  Up: Building BINUTILS GCC and NEWLIB

4.1.1 Obtain Source and Patches for BINUTILS GCC and NEWLIB
-----------------------------------------------------------

NOTE: This step is required for all methods of building BINUTILS, GCC,
and NEWLIB.

   This section lists the components required to build BINUTILS, GCC,
and NEWLIB from source to target RTEMS.  These files should be placed
in your `archive' directory.  Included are the locations of each
component as well as any required RTEMS specific patches.

gcc-4.3.2
---------

         FTP Site:    ftp.gnu.org
         Directory:   /pub/gnu/gcc/gcc-4.3.2
         File:        gcc-4.3.2.tar.bz2
         URL:         ftp://ftp.gnu.org/pub/gnu/gcc/gcc-4.3.2/gcc-4.3.2.tar.bz2

binutils-2.18.91
----------------

         FTP Site:    ftp.gnu.org
         Directory:   /pub/gnu/binutils
         File:        binutils-2.18.91.tar.gz
         URL:         ftp://ftp.gnu.org/pub/gnu/binutils/binutils-2.18.91.tar.gz
If no patches are required, you can use a package manager provided by
your Linux distribution to install AUTOMAKE and AUTOCONF to avoid
building them from source.

newlib-1.16.0
-------------

         FTP Site:    sources.redhat.com
         Directory:   /pub/newlib
         File:        newlib-1.16.0.tar.gz
         URL:         ftp://sources.redhat.com/pub/newlib/newlib-1.16.0.tar.gz

RTEMS Specific Tool Patches and Scripts
---------------------------------------

         FTP Site:    ftp.rtems.com
         Directory:   /pub/rtems/SOURCES/4.10
         File:        newlib-1.16.0-rtems4.10-20080925.diff
         File:        gcc-4.3.2-rtems4.10-20080917.diff

   The individual components in the RTEMS Development Toolset are
updated independently of one another by their respective maintainers.
In addition, the patches which the RTEMS Project has determined are
necessary are subject to change as users report issues on individual
host and target platforms.  As a result, it is possible that the
versions listed in this document are NOT the latest ones available.
The latest patches for each tool are always available from RTEMS CVS on
the respective branch and should always be mirrored on the RTEMS ftp
site.  It is recommended that before building a toolset from source,
you verify you are using the latest patches.


File: started.info,  Node: Unarchiving the Tools,  Next: Applying RTEMS Patches,  Prev: Obtain Source and Patches for BINUTILS GCC and NEWLIB,  Up: Building BINUTILS GCC and NEWLIB

4.1.2 Unarchiving the Tools
---------------------------

NOTE: This step is required if building BINUTILS, GCC, and NEWLIB using
the procedure described in *note Using configure and make::.  It is NOT
required if using the procedure described in *note Using RPM to Build
BINUTILS GCC and NEWLIB::.

   GNU source distributions are archived using `tar' and compressed
using either `gzip' or `bzip'.  If compressed with `gzip', the
extension `.gz' is used.  If compressed with `bzip', the extension
`.bz2' is used.

   While in the `tools' directory, unpack the compressed tar files for
BINUTILS, GCC, and NEWLIB using the appropriate command based upon the
compression program used.

     cd tools
     tar xzf ../archive/TOOLNAME.tar.gz  # for gzip'ed tools
     tar xjf ../archive/TOOLNAME.tar.bz2 # for bzip'ed tools

   After the compressed tar files have been unpacked using the
appropriate commands, the following directories will have been created
under tools.

   * binutils-2.18.91

   * gcc-4.3.2

   * newlib-1.16.0

   The tree should look something like the following figure:

     /whatever/prefix/you/choose/
             archive/
                 gcc-4.3.2.tar.bz2
                 binutils-2.18.91.tar.gz
                 newlib-1.16.0.tar.gz
                 gcc-4.3.2-rtems4.10-20080917.diff
                 newlib-1.16.0-rtems4.10-20080925.diff
             tools/
                 binutils-2.18.91/
                 gcc-4.3.2/
                 newlib-1.16.0/


File: started.info,  Node: Applying RTEMS Patches,  Next: Compiling and Installing BINUTILS GCC and NEWLIB,  Prev: Unarchiving the Tools,  Up: Building BINUTILS GCC and NEWLIB

4.1.3 Applying RTEMS Patches
----------------------------

NOTE: This step is required if building BINUTILS, GCC, and NEWLIB using
the procedures described in *note Using configure and make::.  It is
NOT required if using the procedure described in *note Using RPM to
Build BINUTILS GCC and NEWLIB::.

   This section describes the process of applying the RTEMS patches to
GCC, NEWLIB, and BINUTILS.

Apply RTEMS Patch to GCC
------------------------

Apply the patch using the following command sequence:

     cd tools/gcc-4.3.2
     cat ../../archive/gcc-4.3.2-rtems4.10-20080917.diff | \
         patch -p1

   If the patch was compressed with the `gzip' program, it will have a
suffix of `.gz' and you should use `zcat' instead of `cat' as shown
above.  If the patch was compressed with the `gzip' program, it will
have a suffix of `.bz2' and you should use `bzcat' instead of `cat' as
shown above.

   Check to see if any of these patches have been rejected using the
following sequence: NOTE: If no patch is required for Autoconf and
Automake, you can use the standard package manager provided by your
Linux distribution to install them.  Of course, the versions provided
by your package manager should be the same that specified in
Makefile.am or better.

     cd tools/gcc-4.3.2
     find . -name "*.rej" -print

   If any files are found with the .rej extension, a patch has been
rejected.  This should not happen with a good patch file which is
properly applied.

Apply RTEMS Patch to binutils
-----------------------------

No RTEMS specific patches are required for binutils-2.18.91 to support
RTEMS 4.10.2.

Apply RTEMS Patch to newlib
---------------------------

Apply the patch using the following command sequence:

     cd tools/newlib-1.16.0
     cat ../../archive/newlib-1.16.0-rtems4.10-20080925.diff | \
         patch -p1

   If the patch was compressed with the `gzip' program, it will have a
suffix of `.gz' and you should use `zcat' instead of `cat' as shown
above.  If the patch was compressed with the `gzip' program, it will
have a suffix of `.bz2' and you should use `bzcat' instead of `cat' as
shown above.

   Check to see if any of these patches have been rejected using the
following sequence:

     cd tools/newlib-1.16.0
     find . -name "*.rej" -print

   If any files are found with the .rej extension, a patch has been
rejected.  This should not happen with a good patch file which is
properly applied.


File: started.info,  Node: Compiling and Installing BINUTILS GCC and NEWLIB,  Next: Using RPM to Build BINUTILS GCC and NEWLIB,  Prev: Applying RTEMS Patches,  Up: Building BINUTILS GCC and NEWLIB

4.1.4 Compiling and Installing BINUTILS GCC and NEWLIB
------------------------------------------------------

* Menu:

* Using RPM to Build BINUTILS GCC and NEWLIB::
* Using configure and make::

There are two supported methods to compile and install BINUTILS, GCC,
and NEWLIB:

   * RPM

   * direct invocation of `configure' and `make'

   Direct invocation of `configure' and `make' provides more control
and easier recovery from problems when building.


File: started.info,  Node: Using RPM to Build BINUTILS GCC and NEWLIB,  Next: Using configure and make,  Prev: Compiling and Installing BINUTILS GCC and NEWLIB,  Up: Compiling and Installing BINUTILS GCC and NEWLIB

4.1.4.1 Using RPM to Build BINUTILS GCC and NEWLIB
..................................................

NOTE:  The procedures described in the following sections must be
completed before this step:

   * *note Obtain Source and Patches for BINUTILS GCC and NEWLIB::

   RPM automatically unarchives the source and applies any needed
patches so you do NOT have to manually perform the procedures described
*note Unarchiving the Tools:: and *note Applying RTEMS Patches::.

   This section describes the process of building binutils, gcc, and
newlib using RPM.  RPM is a packaging format which can be used to
distribute binary files as well as to capture the procedure and source
code used to produce those binary files.  Before attempting to build
any RPM from source, it is necessary to ensure that all required source
and patches are in the `SOURCES' directory under the RPM root (probably
`/usr/src/redhat' or `/usr/local/src/redhat') on your machine.  This
procedure starts by installing the source RPMs as shown in the following
example:

     rpm -U rtems-4.10-i386-rtems4.10-binutils-2.18.91-1.src.rpm
     rpm -U rtems-4.10-i386-rtems4.10-gcc-4.3.2-3.src.rpm

   The RTEMS tool source RPMS are called "nosrc" to indicate that one or
more source files required to produce the RPMs are not present.  The
RTEMS source RPMs typically include all required patches, but do not
include the large `.tar.gz' or `.tgz' files for each component such as
BINUTILS, GCC, or NEWLIB.  These are shared by all RTEMS RPMs
regardless of target CPU and there was no reason to duplicate them.
You will have to get the required source archive files by hand and
place them in the `SOURCES' directory before attempting to build.  If
you forget to do this, RPM is smart - it will tell you what is missing.
To determine what is included or referenced by a particular RPM, use a
command like the following:

     $ rpm -q -l -p rtems-4.10-i386-rtems4.10-gcc-3.2.3-1.src.rpm
     gcc-3.2.3-rtems4.10-20030507a.diff
     rtems-4.10-i386-rtems4.7-gcc.spec
     newlib-1.11.0-rtems4.10-20030507.diff

   Notice that there are patch files (the `.diff' files) and a file
describing the build procedure and files produced (the `.spec' file),
but no source archives (the `*tar.*' files).  When installing this
source RPM (`rpm -U
rtems-4.10-i386-rtems4.10-gcc-newlib-gcc3.2.3newlib1.11.0-1.src.rpm'),
the `.spec' file is placed in the `SPECS' directory under the RPM root
directory, while the `*.diff' files are placed into the `SOURCES'
directory.

Configuring and Building BINUTILS using RPM
-------------------------------------------

The following example illustrates the invocation of RPM to build a new,
locally compiled, binutils binary RPM that matches the installed source
RPM.  This example assumes that all of the required source is installed.

     cd <RPM_ROOT_DIRECTORY>/SPECS
     rpm -bb i386-rtems4.10-binutils-2.18.91.spec

   If the build completes successfully, RPMS like the following will be
generated in a build-host architecture specific subdirectory of the
RPMS directory under the RPM root directory.

     rtems-4.10-binutils-common-2.18.91-1.i386.rpm
     rtems-4.10-i386-rtems4.10-binutils-2.18.91-1.i386.rpm

   NOTE: It may be necessary to remove the build tree in the `BUILD'
directory under the RPM root directory.

Configuring and Building GCC and NEWLIB using RPM
-------------------------------------------------

The following example illustrates the invocation of RPM to build a new,
locally compiled, set of GCC and NEWLIB binary RPMs that match the
installed source RPM.  It is also necessary to install the BINUTILS
RPMs and place them in your PATH.  This example assumes that all of the
required source is installed.

     cd <RPM_ROOT_DIRECTORY>/RPMS/i386
     rpm -U rtems-4.10-binutils-common-2.18.91-1.i386.rpm
     rpm -U rtems-4.10-i386-rtems4.10-binutils-2.18.91-1.i386.rpm
     export PATH=/opt/rtems-4.10/bin:$PATH
     cd <RPM_ROOT_DIRECTORY>/SPECS
     rpm -bb i386-rtems4.10-gcc-4.3.2-newlib-1.16.0.spec

   If the build completes successfully, a set of RPMS like the
following will be generated in a build-host architecture specific
subdirectory of the RPMS directory under the RPM root directory.

     rtems-4.10-gcc-common-4.3.2-3.i386.rpm
     rtems-4.10-i386-rtems4.10-newlib-1.16.0-3.i386.rpm
     rtems-4.10-i386-rtems4.10-gcc-4.3.2-3.i386.rpm
     rtems-4.10-i386-rtems4.10-gcc-c++-4.3.2-3.i386.rpm

   NOTE: Some targets do not support building all languages.

   NOTE: It may be necessary to remove the build tree in the `BUILD'
directory under the RPM root directory.


File: started.info,  Node: Using configure and make,  Next: Building the GNU Debugger GDB,  Prev: Using RPM to Build BINUTILS GCC and NEWLIB,  Up: Compiling and Installing BINUTILS GCC and NEWLIB

4.1.4.2 Using configure and make
................................

NOTE:  The procedures described in the following sections must be
completed before this step:

   * *note Obtain Source and Patches for BINUTILS GCC and NEWLIB::

   * *note Unarchiving the Tools::

   * *note Applying RTEMS Patches::

   This section describes the process of building binutils, gcc, and
newlib manually using `configure' and `make' directly.

Configuring and Building BINUTILS
---------------------------------

The following example illustrates the invocation of `configure' and
`make' to build and install binutils-2.18.91 for the sparc-rtems4.10
target:

     mkdir b-binutils
     cd b-binutils
     ../binutils-2.18.91/configure --target=sparc-rtems4.10 \
       --prefix=/opt/rtems-4.10
     make
     make install

   After binutils-2.18.91 is built and installed the build directory
`b-binutils' may be removed.

   For more information on the invocation of `configure', please refer
to the documentation for binutils-2.18.91 or invoke the
binutils-2.18.91 `configure' command with the `--help' option.

   NOTE: The shell PATH variable needs to be updated to include the path
the binutils user executables have  been installed in.  The directory
containing the executables is the prefix used above with `bin'
post-fixed.

     export PATH=/opt/rtems-4.10/bin:${PATH}

   Failure to have the binutils in the path will cause the GCC and
NEWLIB build to fail with an error message similar to:

     sparc-rtems4.10-ar: command not found

Configuring and Building GCC and NEWLIB
---------------------------------------

Before building gcc-4.3.2 and newlib-1.16.0, binutils-2.18.91 must be
installed and the directory containing those executables must be in
your PATH.

   The C Library is built as a subordinate component of gcc-4.3.2.
Because of this, the newlib-1.16.0 directory source must be available
inside the gcc-4.3.2 source tree.  This is normally accomplished using
a symbolic link as shown in this example:

     cd gcc-4.3.2
     ln -s ../newlib-1.16.0/newlib .

   The following example illustrates the invocation of `configure' and
`make' to build and install gcc-4.3.2 with only C and C++ support for
the sparc-rtems4.10 target:

     mkdir b-gcc
     cd b-gcc
     ../gcc-4.3.2/configure --target=sparc-rtems4.10 \
        --with-gnu-as --with-gnu-ld --with-newlib --verbose \
        --enable-threads --enable-languages="c,c++" \
        --prefix=/opt/rtems-4.10
     make all
     make info
     make install

   After gcc-4.3.2 is built and installed the build directory `b-gcc'
may be removed.

   For more information on the invocation of `configure', please refer
to the documentation for gcc-4.3.2 or invoke the gcc-4.3.2 `configure'
command with the As you will need to frequently run various commands in
the /opt/rtems-4.10/bin, you can update your `~/.bashrc' to include this
line. After doing that, don't forget to run
     source ~/.bashrc
   for the changes to take place.

   `--help' option.

Building GCC with Ada Support
-----------------------------

If you want a GCC toolset that includes support for Ada (e.g. GNAT),
there are some additional requirements on the host environment and
additional build steps to perform.  It is critical that you use the
same version of GCC/GNAT as the native compiler.  GNAT must be compiled
with an Ada compiler and when building a GNAT cross-compiler, it should
be the same version of GNAT itself.

   The build procedure is the same until the configure step.  A GCC
toolset with GNAT enabled requires that `ada' be included in the set of
enabled languages.  The following example illustrates the invocation of
`configure' and `make' to build and install gcc-4.3.2 with only C, C++,
and Ada support for the sparc-rtems4.10 target:

     mkdir b-gcc
     cd gcc-4.3.2/gcc/ada
     touch treeprs.ads [es]info.h nmake.ad[bs]
     cd ../../../b-gcc
     ../gcc-4.3.2/configure --target=sparc-rtems4.10 \
        --with-gnu-as --with-gnu-ld --with-newlib --verbose \
        --enable-threads --enable-languages="c,c++,ada" \
        --prefix=/opt/rtems-4.10
     make all
     make info
     make -C gcc cross-gnattools
     make -C gcc ada.all.cross
     make -C gcc GNATLIBCFLAGS="USER_SELECTED_CPU_CFLAGS" gnatlib
     make install

   After gcc-4.3.2 is built and installed the build directory `b-gcc'
may be removed.


File: started.info,  Node: Building the GNU Debugger GDB,  Next: Obtain Source and Patches for GDB,  Prev: Using configure and make,  Up: Building the GNU Cross Compiler Toolset

4.2 Building the GNU Debugger GDB
=================================

* Menu:

* Obtain Source and Patches for GDB::
* Unarchiving the GDB Distribution::
* Applying RTEMS Patch to GDB::
* Compiling and Installing the GNU Debugger GDB::

NOTE: This step is NOT required if prebuilt executables for the GNU
Debugger GDB were installed.

   The GNU Debugger GDB supports many configurations but requires some
means of communicating between the host computer and target board.
This communication can be via a serial port, Ethernet, BDM, or ROM
emulator.  The communication protocol can be the GDB remote protocol or
GDB can talk directly to a ROM monitor.  This setup is target board
specific.  The following configurations have been successfully used
with RTEMS applications:

   * BDM with ColdFire, 683xx, MPC860 CPUs

   * Motorola Mxxxbug found on M68xxx VME boards

   * Motorola PPCbug found on PowerPC VME, CompactPCI, and MTX boards

   * ARM based Cogent EDP7312

   * PC's using various Intel and AMD CPUs including i386, i486,
     Pentium and above, and Athlon

   * PowerPC Instruction Simulator in GDB (PSIM)

   * MIPS Instruction Simulator in GDB (JMR3904)

   * Sparc Instruction Simulator in GDB (SIS)

   * Sparc Instruction Simulator (TSIM)

   * DINK32 on various PowerPC boards

   GDB is currently RTEMS thread/task aware only if you are using the
remote debugging support via Ethernet.  These are configured using gdb
targets of the form CPU-RTEMS.  Note the capital RTEMS.

   It is recommended that when toolset binaries are available for your
particular host, that they be used.  Prebuilt binaries are much easier
to install but in the case of gdb may or may not include support for
your particular target board.


File: started.info,  Node: Obtain Source and Patches for GDB,  Next: Unarchiving the GDB Distribution,  Prev: Building the GNU Debugger GDB,  Up: Building the GNU Debugger GDB

4.2.1 Obtain Source and Patches for GDB
---------------------------------------

NOTE: This step is required for all methods of building GDB.

   This section lists the components required to build GDB from source
to target RTEMS.  These files should be placed in your `archive'
directory.  Included are the locations of each component as well as any
required RTEMS specific patches.

gdb-6.8
-------

         FTP Site:    ftp.gnu.org
         Directory:   /pub/gnu/gdb
         File:        gdb-6.8.tar.gz
         URL:         ftp://ftp.gnu.org/pub/gnu/gdb/gdb-6.8.tar.gz

RTEMS Specific Tool Patches and Scripts
---------------------------------------

         FTP Site:    ftp.rtems.com
         Directory:   /pub/rtems/SOURCES/4.10
         File:        gdb-6.8-rtems4.10-20080917.diff
         URL:         ftp://ftp.rtems.com/pub/rtems/SOURCES/gdb-6.8-rtems4.10-20080917.diff


File: started.info,  Node: Unarchiving the GDB Distribution,  Next: Applying RTEMS Patch to GDB,  Prev: Obtain Source and Patches for GDB,  Up: Building the GNU Debugger GDB

4.2.2 Unarchiving the GDB Distribution
--------------------------------------

Use the following commands to unarchive the GDB distribution:

     cd tools
     tar xzf ../archive/gdb-6.8.tar.gz

   The directory gdb-6.8 is created under the tools directory.


File: started.info,  Node: Applying RTEMS Patch to GDB,  Next: Compiling and Installing the GNU Debugger GDB,  Prev: Unarchiving the GDB Distribution,  Up: Building the GNU Debugger GDB

4.2.3 Applying RTEMS Patch to GDB
---------------------------------

Apply the patch using the following command sequence:

     cd tools/gdb-6.8
     cat archive/gdb-6.8-rtems4.10-20080917.diff | \
         patch -p1

   If the patch was compressed with the `gzip' program, it will have a
suffix of `.gz' and you should use `zcat' instead of `cat' as shown
above.  If the patch was compressed with the `gzip' program, it will
have a suffix of `.bz2' and you should use `bzcat' instead of `cat' as
shown above.

   Check to see if any of these patches have been rejected using the
following sequence:

     cd tools/gdb-6.8
     find . -name "*.rej" -print

   If any files are found with the .rej extension, a patch has been
rejected.  This should not happen with a good patch file.


File: started.info,  Node: Compiling and Installing the GNU Debugger GDB,  Next: Using RPM to Build GDB,  Prev: Applying RTEMS Patch to GDB,  Up: Building the GNU Debugger GDB

4.2.4 Compiling and Installing the GNU Debugger GDB
---------------------------------------------------

* Menu:

* Using RPM to Build GDB::
* Using the GDB configure Script Directly::

There are three methods of building the GNU Debugger:

   * RPM

   * direct invocation of `configure' and `make'

   Direct invocation of `configure' and `make' provides more control
and easier recovery from problems when building.


File: started.info,  Node: Using RPM to Build GDB,  Next: Using the GDB configure Script Directly,  Prev: Compiling and Installing the GNU Debugger GDB,  Up: Compiling and Installing the GNU Debugger GDB

4.2.4.1 Using RPM to Build GDB
..............................

This section describes the process of building binutils, gcc, and
newlib using RPM.  RPM is a packaging format which can be used to
distribute binary files as well as to capture the procedure and source
code used to produce those binary files.  Before attempting to build
any RPM from source, it is necessary to ensure that all required source
and patches are in the `SOURCES' directory under the RPM root (probably
`/usr/src/redhat' or `/usr/local/src/redhat') on your machine.  This
procedure starts by installing the source RPMs as shown in the following
example:

     rpm -U rtems-4.10-i386-rtems4.10-gdb-6.8-3.src.rpm

   Because RTEMS tool RPMS are called "nosrc" to indicate that one or
more source files required to produce the RPMs are not present.  The
RTEMS source GDB RPM does not include the large `.tar.gz' or `.tgz'
files for GDB.  This is shared by all RTEMS RPMs regardless of target
CPU and there was no reason to duplicate them.  You will have to get
the required source archive files by hand and place them in the
`SOURCES' directory before attempting to build.  If you forget to do
this, RPM is smart - it will tell you what is missing.  To determine
what is included or referenced by a particular RPM, use a command like
the following:

     $ rpm -q -l -p rtems-4.10-i386-rtems4.10-gdb-6.8-3.src.rpm
     gdb-6.8-rtems4.10-rtems4.10-20080917.diff
     gdb-6.8.tar.gz
     i386-rtems4.10-gdb-6.8.spec

   Notice that there is a patch file (the `.diff' file), a source
archive file (the `.tar.gz'), and a file describing the build procedure
and files produced (the `.spec' file).  The `.spec' file is placed in
the `SPECS' directory under the RPM root directory.

Configuring and Building GDB using RPM
--------------------------------------

The following example illustrates the invocation of RPM to build a new,
locally compiled, binutils binary RPM that matches the installed source
RPM.  This example assumes that all of the required source is installed.

     cd <RPM_ROOT_DIRECTORY>/SPECS
     rpm -bb i386-rtems4.10-gdb-6.8.spec

   If the build completes successfully, RPMS like the following will be
generated in a build-host architecture specific subdirectory of the
RPMS directory under the RPM root directory.

     rtems-4.10-gdb-common-6.8-3.i386.rpm
     rtems-4.10-i386-rtems4.10-gdb-6.8-3.i386.rpm

   NOTE: It may be necessary to remove the build tree in the `BUILD'
directory under the RPM root directory.


File: started.info,  Node: Using the GDB configure Script Directly,  Next: Common Problems,  Prev: Using RPM to Build GDB,  Up: Compiling and Installing the GNU Debugger GDB

4.2.4.2 Using the GDB configure Script Directly
...............................................

This section describes how to configure the GNU debugger for RTEMS
targets using `configure' and `make' directly.  The following example
illustrates the invocation of `configure' and `make' to build and
install gdb-6.8 for the m68k-rtems4.10 target:

     mkdir b-gdb
     cd b-gdb
     ../gdb-6.8/configure --target=m68k-rtems4.10 \
       --prefix=/opt/rtems-4.10
     make all
     make info
     make install

   For some configurations, it is necessary to specify extra options to
`configure' to enable and configure option components such as a
processor simulator.  The following is a list of configurations for
which there are extra options:

powerpc-rtems4.10
     `--enable-sim --enable-sim-powerpc --enable-sim-timebase
     --enable-sim-hardware'

sparc-rtems4.10
     `--enable-sim'


   After gdb-6.8 is built and installed the build directory `b-gdb' may
be removed.

   For more information on the invocation of `configure', please refer
to the documentation for gdb-6.8 or invoke the gdb-6.8 `configure'
command with the `--help' option.


File: started.info,  Node: Common Problems,  Next: Error Message Indicates Invalid Option to Assembler,  Prev: Using the GDB configure Script Directly,  Up: Building the GNU Cross Compiler Toolset

4.3 Common Problems
===================

* Menu:

* Error Message Indicates Invalid Option to Assembler::
* Error Messages Indicating Configuration Problems::


File: started.info,  Node: Error Message Indicates Invalid Option to Assembler,  Next: Error Messages Indicating Configuration Problems,  Prev: Common Problems,  Up: Common Problems

4.3.1 Error Message Indicates Invalid Option to Assembler
---------------------------------------------------------

If a message like this is printed then the new cross compiler is most
likely using the native assembler instead of the cross assembler or
vice-versa (native compiler using new cross assembler).  This can occur
for one of the following reasons:

   * Binutils Patch Improperly Applied

   * Binutils Not Built

   * Current Directory is in Your PATH


   If you are using binutils 2.9.1 or newer with certain older versions
of gcc, they do not agree on what the name of the newly generated cross
assembler is.  Older binutils called it `as.new' which became
`as.new.exe' under Windows.  This is not a valid file name, so `as.new'
is now called `as-new'.  By using the latest released tool versions and
RTEMS patches, this problem will be avoided.

   If binutils did not successfully build the cross assembler, then the
new cross gcc (`xgcc') used to build the libraries can not find it.
Make sure the build of the binutils succeeded.

   If you include the current directory in your PATH, then there is a
chance that the native compiler will accidentally use the new cross
assembler instead of the native one.  This usually indicates that "."
is before the standard system directories in your PATH.  As a general
rule, including "." in your PATH is a security risk and should be
avoided.  Remove "." from your PATH.

   NOTE:  In some environments, it may be difficult to remove "."
completely from your PATH.  In this case, make sure that "."  is after
the system directories containing "as" and "ld".


File: started.info,  Node: Error Messages Indicating Configuration Problems,  Next: Building RTEMS,  Prev: Error Message Indicates Invalid Option to Assembler,  Up: Common Problems

4.3.2 Error Messages Indicating Configuration Problems
------------------------------------------------------

If you see error messages like the following,

   * cannot configure libiberty

   * coff-emulation not found

   * etc.


   Then it is likely that one or more of your gnu tools is already
configured locally in its source tree.  You can check for this by
searching for the `config.status' file in the various tool source
trees.  The following command does this for the binutils source:

     find binutils-2.18.91 -name config.status -print

   The solution for this is to execute the command `make distclean' in
each of the GNU tools root source directory.  This should remove all
generated files including Makefiles.

   This situation usually occurs when you have previously built the
tool source for some non-RTEMS target.  The generated configuration
specific files are still in the source tree and the include path
specified during the RTEMS build accidentally picks up the previous
configuration.  The include path used is something like this:

     -I../../binutils-2.18.91/gcc -I/binutils-2.18.91/gcc/include -I.

   Note that the tool source directory is searched before the build
directory.

   This situation can be avoided entirely by never using the source
tree as the build directory.


File: started.info,  Node: Building RTEMS,  Next: Obtain the RTEMS Source Code,  Prev: Error Messages Indicating Configuration Problems,  Up: Top

5 Building RTEMS
****************

* Menu:

* Obtain the RTEMS Source Code::
* Unarchive the RTEMS Source::
* Obtaining the RTEMS Source from CVS::
* Add <INSTALL_POINT>/bin to Executable PATH::
* Verifying the Operation of the Cross Toolset::
* Building RTEMS for a Specific Target and BSP::


File: started.info,  Node: Obtain the RTEMS Source Code,  Next: Unarchive the RTEMS Source,  Prev: Building RTEMS,  Up: Building RTEMS

5.1 Obtain the RTEMS Source Code
================================

This section provides pointers to the RTEMS source code and Hello World
example program.  These files should be placed in your `archive'
directory.

RTEMS 4.10.2
------------

         FTP Site:    ftp.rtems.com
         Directory:   /pub/rtems/4.10.2
         File:        rtems-4.10.2.tar.bz2
         URL:         ftp://ftp.rtems.com/pub/rtems/4.10.2/rtems-4.10.2.tar.bz2

RTEMS Examples including Hello World
------------------------------------

         FTP Site:    ftp.rtems.com
         Directory:   /pub/rtems/4.10.2
         File:        examples-4.10.2.tar.bz2
         URL:         ftp://ftp.rtems.com/pub/rtems/4.10.2/examples-4.10.2.tar.bz2


File: started.info,  Node: Unarchive the RTEMS Source,  Next: Obtaining the RTEMS Source from CVS,  Prev: Obtain the RTEMS Source Code,  Up: Building RTEMS

5.2 Unarchive the RTEMS Source
==============================

Use the following command sequence to unpack the RTEMS source into the
tools directory:

     cd tools
     tar xjf ../archive/rtems-4.10.2.tar.bz2

   This creates the directory rtems-4.10.2.


File: started.info,  Node: Obtaining the RTEMS Source from CVS,  Next: Add <INSTALL_POINT>/bin to Executable PATH,  Prev: Unarchive the RTEMS Source,  Up: Building RTEMS

5.3 Obtaining the RTEMS Source from CVS
=======================================

Instead of downloading release tarballs you may choose to check out the
current RTEMS source from CVS. For details on accessing RTEMS CVS
repository consult
http://www.rtems.org/wiki/index.php/RTEMS_CVS_Repository
(http://www.rtems.org/wiki/index.php/RTEMS_CVS_Repository).  The steps
required to obtain the source code from CVS are usually like the
following:
     $ cvs -d :pserver:anoncvs@www.rtems.com:/usr1/CVS login
     Logging in to :pserver:anoncvs@www.rtems.com:2401/usr1/CVS
     CVS password:
     $ cvs -d :pserver:anoncvs@www.rtems.com:/usr1/CVS -z 9 co -P rtems  # for the main RTEMS source
     $ cvs -d :pserver:anoncvs@www.rtems.com:/usr1/CVS -z 9 co -P examples-v2  # for examples


File: started.info,  Node: Add <INSTALL_POINT>/bin to Executable PATH,  Next: Verifying the Operation of the Cross Toolset,  Prev: Obtaining the RTEMS Source from CVS,  Up: Building RTEMS

5.4 Add <INSTALL_POINT>/bin to Executable PATH
==============================================

In order to compile RTEMS, you must have the cross compilation toolset
in your search path.  It is important to have the RTEMS toolset first
in your path to ensure that you are using the intended version of all
tools.  The following command prepends the directory where the tools
were installed in a previous step:

     export PATH=<INSTALL_POINT>/bin:${PATH}

   NOTE:  The above command is in Bourne shell (`sh') syntax and should
work with the Korn (`ksh') and GNU Bourne Again Shell (`bash').  It
will not work with the C Shell (`csh') or derivatives of the C Shell.


File: started.info,  Node: Verifying the Operation of the Cross Toolset,  Next: Building RTEMS for a Specific Target and BSP,  Prev: Add <INSTALL_POINT>/bin to Executable PATH,  Up: Building RTEMS

5.5 Verifying the Operation of the Cross Toolset
================================================

In order to ensure that the cross-compiler is invoking the correct
subprograms (like `as' and `ld'), one can test assemble a small
program.  When in verbose mode, `gcc' prints out information showing
where it found the subprograms it invokes.  In a temporary working
directory, place the following function in a file named `f.c':

     int f( int x )
     {
       return x + 1;
     }

   Then assemble the file using a command similar to the following:

     m68k-rtems-gcc -v -S f.c

   Where `m68k-rtems-gcc' should be changed to match the installed name
of your cross compiler.  The result of this command will be a sequence
of output showing where the cross-compiler searched for and found its
subcomponents.  Verify that these paths correspond to your
<INSTALL_POINT>.

   Look at the created file `f.s' and verify that it is in fact for
your target processor.

   Then try to compile the file `f.c' directly to object code using a
command like the following:

     m68k-rtems-gcc -v -c f.c

   If this produces messages that indicate the assembly code is not
valid, then it is likely that you have fallen victim to one of the
problems described in *note Error Message Indicates Invalid Option to
Assembler:: Don't feel bad about this, one of the most common
installation errors is for the cross-compiler not to be able to find
the cross assembler and default to using the native `as'.  This can
result in very confusing error messages.


File: started.info,  Node: Building RTEMS for a Specific Target and BSP,  Next: Using the RTEMS configure Script Directly,  Prev: Verifying the Operation of the Cross Toolset,  Up: Building RTEMS

5.6 Building RTEMS for a Specific Target and BSP
================================================

* Menu:

* Using the RTEMS configure Script Directly::

This section describes how to configure and build RTEMS so that it is
specifically tailored for your BSP (Board Support Package) and the CPU
model it uses.  There is currently only one supported method to compile
and install RTEMS:

   * direct invocation of `configure' and `make'

   Direct invocation of `configure' and `make' provides more control
and easier recovery from problems when building.

   This section describes how to build RTEMS.


File: started.info,  Node: Using the RTEMS configure Script Directly,  Next: Building the Sample Applications,  Prev: Building RTEMS for a Specific Target and BSP,  Up: Building RTEMS for a Specific Target and BSP

5.6.1 Using the RTEMS configure Script Directly
-----------------------------------------------

Make a build directory under tools and build the RTEMS product in this
directory. The `../rtems-4.10.2/configure' command has numerous command
line arguments. These arguments are discussed in detail in
documentation that comes with the RTEMS distribution. A full list of
these arguments can be obtained by running `../rtems-4.10.2/configure
--help' If you followed the procedure described in the section *note
Unarchive the RTEMS Source::, these configuration options can be found
in the file tools/rtems-4.10.2/README.configure.

   NOTE: The GNAT/RTEMS run-time implementation is based on the POSIX
API.  Thus the RTEMS configuration for a GNAT/RTEMS environment MUST
include the `--enable-posix' flag.

   The following shows the command sequence required to configure,
compile, and install RTEMS with the POSIX API, FreeBSD TCP/IP, and C++
support disabled.  RTEMS will be built to target the
`BOARD_SUPPORT_PACKAGE' board.

     mkdir build-rtems
     cd build-rtems
     ../rtems-4.10.2/configure --target=<TARGET_CONFIGURATION> \
         --disable-posix --disable-networking --disable-cxx \
         --enable-rtemsbsp=<BOARD_SUPPORT_PACKAGE>\
         --prefix=<INSTALL_POINT>
     make all
     make install

   Where the list of currently supported <TARGET_CONFIGURATION>'s and
<BOARD_SUPPORT_PACKAGE>'s can be found in
tools/rtems-4.10.2/README.configure.

   <INSTALL_POINT> is typically the installation point for the tools
and defaults to `/opt/rtems-4.10'.

   BSP is a supported BSP for the selected CPU family.  The list of
supported BSPs may be found in the file
tools/rtems-4.10.2/README.configure in the RTEMS source tree.  If the
BSP parameter is not specified, then all supported BSPs for the
selected CPU family will be built.

   NOTE:  The POSIX API must be enabled to use GNAT/RTEMS.

   NOTE: The `make' utility used should be GNU make.


File: started.info,  Node: Building the Sample Applications,  Next: Set the Environment Variable RTEMS_MAKEFILE_PATH,  Prev: Using the RTEMS configure Script Directly,  Up: Top

6 Building the Sample Applications
**********************************

* Menu:

* Set the Environment Variable RTEMS_MAKEFILE_PATH::
* Executing the Sample Applications::
* C/C++ Sample Applications::
* Ada Sample Applications::
* Build the Sample Application::
* Application Executable::
* More Information on RTEMS Application Makefiles::

The RTEMS distribution includes a number of sample C, C++, Ada, and
networking applications.  This chapter will provide an overview of
those sample applications.


File: started.info,  Node: Set the Environment Variable RTEMS_MAKEFILE_PATH,  Next: Executing the Sample Applications,  Prev: Building the Sample Applications,  Up: Building the Sample Applications

6.1 Set the Environment Variable RTEMS_MAKEFILE_PATH
====================================================

The sample application sets use the RTEMS Application Makefiles.  This
requires that the environment variable `RTEMS_MAKEFILE_PATH' point to
the appropriate directory containing the installed RTEMS image built to
target your particular CPU and board support package combination.

     export RTEMS_MAKEFILE_PATH=<INSTALLATION_POINT>/<CPU>-rtems/<BOARD_SUPPORT_PACKAGE>

   Where <INSTALLATION_POINT> and <BOARD_SUPPORT_PACKAGE> are those
used when configuring and installing RTEMS.

   NOTE:  In release 4.0, BSPs were installed at
`<INSTALLATION_POINT>/rtems/<BOARD_SUPPORT_PACKAGE>'.  This was changed
to be more in compliance with GNU standards.

   NOTE: GNU make is the preferred `make' utility.  Other `make'
implementations may work but all testing is done with GNU make.

   If no errors are detected during the sample application build, it is
reasonable to assume that the build of the GNU Cross Compiler Tools for
RTEMS and RTEMS itself for the selected host and target combination was
done properly.


File: started.info,  Node: Executing the Sample Applications,  Next: C/C++ Sample Applications,  Prev: Set the Environment Variable RTEMS_MAKEFILE_PATH,  Up: Building the Sample Applications

6.2 Executing the Sample Applications
=====================================

How each sample application executable is downloaded to your target
board and executed is very dependent on the board you are using.  The
following is a list of commonly used BSPs classified by their RTEMS CPU
family and pointers to instructions on how to use them.  [NOTE: All
file names should be prepended with rtems-4.10.2/c/src/lib/libbsp.]

arm/edp7312
     The arm/edp7312 BSP is for the ARM7-based Cogent EDP7312 board.

c4x/c4xsim
     The c4x/c4xsim BSP is designed to execute on any member of the
     Texas Instruments C3x/C4x DSP family using only on-CPU peripherals
     for the console and timers.

i386/pc386
     See `i386/pc386/HOWTO'

i386/pc486
     The i386/pc386 BSP specially compiled for an i486-class CPU.

i386/pc586
     The i386/pc386 BSP specially compiled for a Pentium-class CPU.

i386/pc686
     The i386/pc386 BSP specially compiled for a Pentium II.

i386/pck6
     The i386/pc386 BSP specially compiled for an AMD K6.

m68k/gen68360
     This BSP is for a MC68360 CPU.  See `m68k/gen68360/README' for
     details.

m68k/mvme162
     See `m68k/mvme162/README'.

m68k/mvme167
     See `m68k/mvme167/README'.

mips/jmr3904
     This is a BSP for the Toshiba TX3904 evaluation board simulator
     included with `mipstx39-rtems-gdb'.  The BSP is located in
     `mips/jmr3904'.  The TX3904 is a MIPS R3000 class CPU with serial
     ports and timers integrated with the processor.  This BSP can be
     used with either real  hardware or with the simulator included with
     `mipstx39-rtems-gdb'.  An application can be run on the simulator
     by executing the following commands upon entering
     `mipstx39-rtems-gdb':

          target sim --board=jmr3904
          load
          run

powerpc/mcp750
     See `powerpc/motorola_shared/README'.

powerpc/mvme230x
     See `powerpc/motorola_shared/README.MVME2300'.

powerpc/psim
     This is a BSP for the PowerPC simulator included with
     `powerpc-rtems-gdb'.  The simulator is complicated to initialize
     by hand.  The user is referred to the script
     `powerpc/psim/tools/psim'.

sparc/erc32
     The ERC32 is a radiation hardened SPARC V7.  This BSP can be used
     with either real ERC32 hardware or with the simulator included
     with `sparc-rtems-gdb' (for this, you should configure RTEMS to
     use `sis' BSP).  An application can be run on the simulator by
     executing the following commands upon entering `sparc-rtems-gdb':

          target sim
          load
          run

     In case that you don't need a debugger, an application can be run
     by `spart-rtems-run'.


   RTEMS has many more BSPs and new BSPs for commercial boards and CPUs
with on-CPU peripherals are generally welcomed.


File: started.info,  Node: C/C++ Sample Applications,  Next: Ada Sample Applications,  Prev: Executing the Sample Applications,  Up: Building the Sample Applications

6.3 C/C++ Sample Applications
=============================

The C/C++ sample application set includes a number of simple
applications.  Some demonstrate some basic functionality in RTEMS such
as writing a file, closing it, and reading it back while others can
serve as starting points for RTEMS applications or libraries.  Start by
unarchiving them so you can peruse them.  Use a command similar to the
following to unarchive the sample applications:

     cd tools
     tar xjf ../archive/examples-VERSION.tgz

   The sample applications most likely to be of interest to you are:

   * hello_world_c - C Hello World application with a simple RTEMS
     configuration and an entry point not called `main()'.

   * simple_main - Very simple program starting at `main()' and
     shutting down RTEMS via `exit()' without any other operations.  It
     uses the default configuration inside RTEMS which is only intended
     to satisfy `autoconf' probes and extremely simple console-based
     applications.

   * libcpp - Simple C++ library for RTEMS showing how to build an
     application library written in C++.

   * psx_sched_report - POSIX Scheduler Reporter is a program that
     prints out some scheduler attributes of the RTEMS POSIX API.


   Each tests is found in a separate subdirectory and built using the
same command sequence.  The `hello_world_c' sample will be used as an
example.

Build the C Hello World Application
-----------------------------------

Use the following command to start the build of the sample hello world
application:

     cd hello_world_c
     make

   If the sample application has successfully been built, then the
application executable is placed in the following directory:

     hello_world_c/o-optimize/<filename>.exe

   The other C/C++ sample applications are built using a similar
procedure.


File: started.info,  Node: Ada Sample Applications,  Next: Build the Sample Application,  Prev: C/C++ Sample Applications,  Up: Building the Sample Applications

6.4 Ada Sample Applications
===========================

The Ada sample application set primarily includes a a simple Hello
World Ada program which can be used as a starting point for GNAT/RTEMS
applications.  Use the following command to unarchive the Ada sample
applications:

     cd tools
     tar xjf ../archive/ada-examples-4.10.2.tar.bz2

Create a BSP Specific Makefile
------------------------------

Currently, the procedure for building and linking an Ada application is
a bit more difficult than a C or C++ application.  This is certainly an
opportunity for a volunteer project.

   At this time, there is a

   Provided are example Makefiles for multiple BSPs.  Copy one of these
to the file Makefile.<BOARD_SUPPORT_PACKAGE> and edit it as appropriate
for your local configuration.

   Use the  <INSTALLATION_POINT> and <BOARD_SUPPORT_PACKAGE> specified
when configuring and installing RTEMS.


File: started.info,  Node: Build the Sample Application,  Next: Application Executable,  Prev: Ada Sample Applications,  Up: Building the Sample Applications

6.5 Build the Sample Application
================================

Use the following command to start the build of the sample application:

     cd tools/hello_world_ada
     make -f Makefile.<BOARD_SUPPORT_PACKAGE>

   NOTE: GNU make is the preferred `make' utility.  Other `make'
implementations may work but all testing is done with GNU make.

   If the BSP specific modifications to the Makefile were correct and
no errors are detected during the sample application build, it is
reasonable to assume that the build of the GNAT/RTEMS Cross Compiler
Tools for RTEMS and RTEMS itself for the selected host and target
combination was done properly.


File: started.info,  Node: Application Executable,  Next: More Information on RTEMS Application Makefiles,  Prev: Build the Sample Application,  Up: Building the Sample Applications

6.6 Application Executable
==========================

If the sample application has successfully been build, then the
application executable is placed in the following directory:

     tools/hello_world_ada/o-optimize/<filename>.exe

   How this executable is downloaded to the target board is very
dependent on the BOARD_SUPPORT_PACKAGE selected.


File: started.info,  Node: More Information on RTEMS Application Makefiles,  Next: Where To Go From Here,  Prev: Application Executable,  Up: Building the Sample Applications

6.7 More Information on RTEMS Application Makefiles
===================================================

These sample applications are examples of simple RTEMS applications
that use the RTEMS Application Makefile system.  This Makefile system
simplifies building RTEMS applications by providing Makefile templates
and capturing the configuration information used to build RTEMS
specific to your BSP.  Building an RTEMS application for different BSPs
is as simple as switching the setting of `RTEMS_MAKEFILE_PATH'.  This
Makefile system is described in the file `make/README'.


File: started.info,  Node: Where To Go From Here,  Next: Documentation Overview,  Prev: More Information on RTEMS Application Makefiles,  Up: Top

7 Where To Go From Here
***********************

* Menu:

* Documentation Overview::
* Writing an Application::

At this point, you should have successfully installed a GNU Cross
Compilation Tools for RTEMS on your host system as well as the RTEMS OS
for the target host.  You should have successfully linked the "hello
world" program. You may even have downloaded the executable to that
target and run it.  What do you do next?

   The answer is that it depends.  You may be interested in writing an
application that uses one of the multiple APIs supported by RTEMS.  You
may need to investigate the network or filesystem support in RTEMS.
The common thread is that you are largely finished with this manual and
ready to move on to others.

   Whether or not you decide to dive in now and write application code
or read some documentation first, this chapter is for you.  The first
section provides a quick roadmap of some of the RTEMS documentation.
The next section provides a brief overview of the RTEMS application
structure.


File: started.info,  Node: Documentation Overview,  Next: Writing an Application,  Prev: Where To Go From Here,  Up: Where To Go From Here

7.1 Documentation Overview
==========================

When writing RTEMS applications, you should find the following manuals
useful because they define the calling interface to many of the
services provided by RTEMS:

   * RTEMS Applications C User's Guide describes the Classic RTEMS API
     based on the RTEID specification.

   * RTEMS POSIX API User's Guide describes the RTEMS POSIX API that is
     based on the POSIX 1003.1b API.

   * RTEMS ITRON 3.0 API User's Guide describes the RTEMS
     implementation of the ITRON 3.0 API.

   * RTEMS Network Supplement provides information on the network
     services provided by RTEMS.


   In addition, the following manuals from the GNU Cross Compilation
Toolset include information on run-time services available.

   * Cygnus C Support Library describes the Standard C Library
     functionality provided by Newlib's libc.

   * Cygnus C Math Library describes the Standard C Math Library
     functionality provided by Newlib's libm.


   Finally, the RTEMS FAQ and mailing list archives are available at
`http://www.rtems.com'.

   There is a wealth of documentation available for RTEMS and the GNU
tools supporting it.  If you run into something that is not clear or
missing, bring it to our attention.

   Also, some of the RTEMS documentation is still under construction.
If you would like to contribute to this effort, please contact the
RTEMS Team at rtems-users@rtems.com (mailto:rtems-users@rtems.com).  If
you are interested in sponsoring the development of a new feature, BSP,
device driver, port of an existing library, etc., please contact one of
the RTEMS Service Providers listed at http://www.rtems.com/support.html
(http://www.rtems.com/support.html).


File: started.info,  Node: Writing an Application,  Next: Using MS-Windows as a Development Host,  Prev: Documentation Overview,  Up: Where To Go From Here

7.2 Writing an Application
==========================

From an application author's perspective, the structure of an RTEMS
application is very familiar.  In POSIX language, RTEMS provides a
single process, multi-threaded run-time environment.  However there are
two important things that are different from a standard UNIX hosted
program.

   First, the application developer must provide configuration
information for RTEMS.  This configuration information includes limits
on the maximum number of various OS resources available and networking
configuration among other things.  See the Configuring a System in the
RTEMS Applications C User's Guide for more details.

   Second, RTEMS applications may or may not start at `main()'.
Applications begin execution at one or more user configurable
application initialization tasks or threads.  It is possible to
configure an application to start with a single thread that whose entry
point is `main()'.

   Each API supported by RTEMS (Classic, POSIX, and ITRON) allows the
user to configure a set of one or more tasks that are created and
started automatically during RTEMS initialization.  The RTEMS Automatic
Configuration Generation (`confdefs.h') scheme can be used to easily
generate the configuration information for an application that starts
with a single initialization task.  By convention, unless overridden,
the default name of the initialization task varies based up API.

   * `Init' - single Classic API Initialization Task

   * `POSIX_Init' - single POSIX API Initialization Thread

   * `ITRON_Init' - single ITRON API Initialization Task

   Regardless of the API used, when the initialization task executes,
all non-networking device drivers are normally initialized, processor
interrupts are enabled, and any C++ global constructors have been run.
The initialization task then goes about its business of performing
application specific initialization which will include initializing the
networking subsystem if it is to be used.  The application
initialization may also involve creating tasks and other system
resources such as semaphores or message queues and allocating memory.
In the RTEMS examples and tests, the file `init.c' usually contains the
initialization task.  Although not required, in most of the examples,
the initialization task completes by deleting itself.

   As you begin to write RTEMS application code, you may be confused by
the range of alternatives.  Supporting multiple tasking APIs can make
the choices confusing.  Many application groups writing new code choose
one of the APIs as their primary API and only use services from the
others if nothing comparable is in their preferred one.  However, the
support for multiple APIs is a powerful feature when integrating code
from multiple sources.  You can write new code using POSIX services and
still use services written in terms of the other APIs.  Moreover, by
adding support for yet another API, one could provide the
infrastructure required to migrate from a legacy RTOS with a
non-standard API to an API like POSIX.


File: started.info,  Node: Using MS-Windows as a Development Host,  Next: Microsoft Windows Version Requirements,  Prev: Writing an Application,  Up: Top

Appendix A Using MS-Windows as a Development Host
*************************************************

* Menu:

* Microsoft Windows Version Requirements::
* Cygwin::
* MingGW::
* Text Editor::
* System Requirements::

This chapter discusses the installation of the GNU tool chain on a
computer running the Microsoft Windows operating system.

   This chapter was originally written by Geoffroy Montel
<g_montel@yahoo.com> (mailto:g_montel@yahoo.com) with input from David
Fiddes <D.J@fiddes.surfaid.org> (mailto:<D.J@fiddes.surfaid.org>).  It
was based upon his successful but unnecessarily painful efforts with
Cygwin beta versions.  Cygwin and this chapter have been updated
multiple times since those early days although their pioneering efforts
and input is still greatly appreciated.


File: started.info,  Node: Microsoft Windows Version Requirements,  Next: Cygwin,  Prev: Using MS-Windows as a Development Host,  Up: Using MS-Windows as a Development Host

A.1 Microsoft Windows Version Requirements
==========================================

RTEMS users report fewer problems when using Microsoft Windows XP or
newer.


File: started.info,  Node: Cygwin,  Next: MingGW,  Prev: Microsoft Windows Version Requirements,  Up: Using MS-Windows as a Development Host

A.2 Cygwin
==========

For RTEMS development, the recommended approach is to use Cygwin. Cygwin
is  available from http://www.cygwin.com (http://www.cygwin.com) .  The
primary issues reported by users of Cygwin is that it is slower on the
same hardware than a native GNU/Linux installation and strange issues
over carriage return/line feed inconsistencies between UNIX and Windows
environments.  However, there are a handful of other issues that may
turn up when using Cygwin as an RTEMS development environment.

   * There is no `cc' program by default.  The GNU configure scripts
     used by RTEMS require this to be present to work properly.  The
     solution is to link `gcc.exe' to `cc.exe' as follows:

          ln -s /bin/gcc.exe  /bin/cc.exe

   * Make sure `/bin/sh.exe' is GNU Bash.  Some Cygwin versions provide
     a light Bourne shell which is insufficient to build RTEMS.  To see
     which shell is installed as `/bin/sh.exe', execute the command
     `/bin/sh --version'.  If it looks similar to the following, then
     it is GNU Bash and you are OK:

          GNU bash, version 2.04.5(12)-release (i686-pc-cygwin)
          Copyright 1999 Free Software Foundation, Inc.

     If you get an error or it claims to be any other shell, you need
     to copy it to a fake name and copy `/bin/bash.exe' to
     `/bin/sh.exe':

          cd /bin
          mv sh.exe old_sh.exe
          cp bash.exe sh.exe

     The Bourne shell has to be present in `/bin' directory to run
     shell scripts properly.

   * Make sure you unarchive and build in a binary mounted filesystem
     (e.g. mounted with the `-b' option).  Otherwise, many confusing
     errors will result.

   * A user has reported that they needed to set `CYGWIN=ntsec' for
     chmod to work correctly, but had to set `CYGWIN=nontsec' for
     compile to work properly (otherwise there were complaints about
     permissions on a temporary file).

   * If you want to build the tools from source, you have the same
     options as UNIX users.

   * You may have to uncompress archives during this process.  You must
     NOT use `WinZip' or `PKZip'.  Instead the un-archiving process
     uses the GNU `zip' and `tar' programs as shown below:

          tar -xzvf archive.tgz

     `tar' is provided with Cygwin.



File: started.info,  Node: MingGW,  Next: Text Editor,  Prev: Cygwin,  Up: Using MS-Windows as a Development Host

A.3 MingGW
==========

You might consider choosing MinGW since it provides better perfomance.
There is a wiki entry on a MinGW RTEMS toolset installer available at
http://www.rtems.org/wiki/index.php/MinGW_Tools_for_Windows
(http://www.rtems.org/wiki/index.php/MinGW_Tools_for_Windows). Also,
there are prebuilt tools for different architectures available for
download at http://www.rtems.org/ftp/pub/rtems/mingw32
(http://www.rtems.org/ftp/pub/rtems/mingw32).


File: started.info,  Node: Text Editor,  Next: System Requirements,  Prev: MingGW,  Up: Using MS-Windows as a Development Host

A.4 Text Editor
===============

You absolutely have to use a text editor which can save files with Unix
format.  So do NOT use Notepad or Wordpad!  Basically, any more or less
advanced text editor is usually able to do that.  There is a number of
editors freely available that can be used.

   * Notepad++ has an interface familiar to Windows users and can be
     downloaded from http://notepad-plus-plus.org/
     (http://notepad-plus-plus.org/).

   * VIM (Vi IMproved) is available from http://www.vim.org/
     (http://www.vim.org/).  This editor has the very handy ability to
     easily read and write files in either DOS or UNIX style.

   * GNU Emacs is available for many platforms including MS-Windows.
     The official homepage is
     http://www.gnu.org/software/emacs/emacs.html
     (http://www.gnu.org/software/emacs/emacs.html).  The GNU Emacs on
     Windows NT and Windows 95/98 FAQ is at
     http://www.gnu.org/software/emacs/windows/ntemacs.html
     (http://www.gnu.org/software/emacs/windows/ntemacs.html).


   If you do accidentally end up with files having MS-DOS style line
termination, then you may have to convert them to Unix format for some
Cygwin programs to operate on them properly. The program `dos2unix' can
be used to put them back into Unix format as shown below:

     $ dos2unix XYZ
     Dos2Unix: Cleaning file XYZ ...


File: started.info,  Node: System Requirements,  Prev: Text Editor,  Up: Using MS-Windows as a Development Host

A.5 System Requirements
=======================

Although the finished cross-compiler is fairly easy on resources,
building it can take a significant amount of processing power and disk
space.  Luckily, desktop computers have progressed very far since this
guide was originally written so it is unlikely you will have any
problems.  Just do not use an old cast-off machine with < 1 GB RAM and
a 1 Ghz CPU.  Unless, of course, you enjoy waiting for things to
complete.

   The more disk space, the better. You need more if you are building
the GNU tools and the amount of disk space for binaries is obviously
directly dependent upon the number of CPUs you have cross toolsets
installed for.  In addition to the disk space requirements documented
earlier for tool building, you will also have to have enough space to
install the Cygwin environment.


File: started.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

started
*******

This is the online version of the Getting Started with RTEMS.

* Menu:

* Introduction::
* Requirements::
* Prebuilt Toolset Executables::
* Building the GNU Cross Compiler Toolset::
* Building RTEMS::
* Building the Sample Applications::
* Where To Go From Here::
* Using MS-Windows as a Development Host::



Tag Table:
Node: Introduction196
Node: Real-Time Embedded Systems1342
Node: Cross Development4497
Node: Resources on the Internet7573
Node: Online Tool Documentation7971
Node: RTEMS Mailing List8958
Node: CrossGCC Mailing List9652
Node: GCC Mailing Lists10284
Node: Requirements10644
Node: Disk Space11042
Node: General Host Software Requirements13278
Node: GCC13815
Node: GNU Make14326
Node: GNU makeinfo Version Requirements15028
Node: Host Specific Notes15572
Node: Solaris 2.x15788
Node: Linux16378
Node: Archive and Build Directories17009
Node: RPM Archive and Build Directory Format17666
Node: Archive and Build Directory Format18484
Node: Prebuilt Toolset Executables19454
Node: RPMs21062
Node: Installing RPMs21375
Node: Determining Which RTEMS RPMs are Installed22523
Node: Removing RPMs22856
Node: Zipped Tar Files23609
Node: Installing Zipped Tar Files23970
Node: Removing Zipped Tar Files25614
Node: Building the GNU Cross Compiler Toolset26074
Node: Building BINUTILS GCC and NEWLIB27122
Node: Obtain Source and Patches for BINUTILS GCC and NEWLIB27945
Node: Unarchiving the Tools30398
Node: Applying RTEMS Patches32063
Node: Compiling and Installing BINUTILS GCC and NEWLIB34687
Node: Using RPM to Build BINUTILS GCC and NEWLIB35346
Node: Using configure and make40171
Node: Building the GNU Debugger GDB44751
Node: Obtain Source and Patches for GDB46669
Node: Unarchiving the GDB Distribution47734
Node: Applying RTEMS Patch to GDB48171
Node: Compiling and Installing the GNU Debugger GDB49145
Node: Using RPM to Build GDB49744
Node: Using the GDB configure Script Directly52463
Node: Common Problems53792
Node: Error Message Indicates Invalid Option to Assembler54152
Node: Error Messages Indicating Configuration Problems55958
Node: Building RTEMS57455
Node: Obtain the RTEMS Source Code57898
Node: Unarchive the RTEMS Source58760
Node: Obtaining the RTEMS Source from CVS59176
Node: Add <INSTALL_POINT>/bin to Executable PATH60131
Node: Verifying the Operation of the Cross Toolset60990
Node: Building RTEMS for a Specific Target and BSP62734
Node: Using the RTEMS configure Script Directly63537
Node: Building the Sample Applications65716
Node: Set the Environment Variable RTEMS_MAKEFILE_PATH66401
Node: Executing the Sample Applications67721
Node: C/C++ Sample Applications70702
Node: Ada Sample Applications72715
Node: Build the Sample Application73785
Node: Application Executable74596
Node: More Information on RTEMS Application Makefiles75131
Node: Where To Go From Here75886
Node: Documentation Overview77067
Node: Writing an Application78937
Node: Using MS-Windows as a Development Host82164
Node: Microsoft Windows Version Requirements83109
Node: Cygwin83449
Node: MingGW85889
Node: Text Editor86468
Node: System Requirements87962
Node: Top88925

End Tag Table

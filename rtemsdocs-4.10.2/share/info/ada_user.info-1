This is ada_user.info, produced by makeinfo version 4.13 from
ada_user.texi.

INFO-DIR-SECTION RTEMS On-Line Manual
START-INFO-DIR-ENTRY
* RTEMS Ada User: (ada_user).          The Ada User's Guide
END-INFO-DIR-ENTRY


File: ada_user.info,  Node: List of Figures,  Next: Preface,  Prev: Top,  Up: Top

List of Figures
***************

* Menu:

* Figure    1.1: RTEMS ...:              fig:RTEMS-App-Arch.
* Figure    1.2: RTEMS Layered ...:      fig:rtems-layers.
* Figure    2.1: Thirty-Two Bit ...:     fig:Object-Id-32.
* Figure    2.2: Sixteen Bit ...:        fig:Object-Id-16.
* Figure    9.1: Valid Semaphore ...:    fig:semaphore-attributes.
* Figure   18.1: RTEMS Task States:      fig:RTEMS-Task-States.


File: ada_user.info,  Node: Preface,  Next: Overview,  Prev: List of Figures,  Up: Top

Preface
*******

In recent years, the cost required to develop a software product has
increased significantly while the target hardware costs have decreased.
Now a larger portion of money is expended in developing, using, and
maintaining software.  The trend in computing costs is the complete
dominance of software over hardware costs.  Because of this, it is
necessary that formal disciplines be established to increase the
probability that software is characterized by a high degree of
correctness, maintainability, and portability.  In addition, these
disciplines must promote practices that aid in the consistent and
orderly development of a software system within schedule and budgetary
constraints.  To be effective, these disciplines must adopt standards
which channel individual software efforts toward a common goal.

The push for standards in the software development field has been met
with various degrees of success.  The Microprocessor Operating Systems
Interfaces (MOSI) effort has experienced only limited success.  As
popular as the UNIX operating system has grown, the attempt to develop
a standard interface definition to allow portable application
development has only recently begun to produce the results needed in
this area.  Unfortunately, very little effort has been expended to
provide standards addressing the needs of the real-time community.
Several organizations have addressed this need during recent years.

The Real Time Executive Interface Definition (RTEID) was developed by
Motorola with technical input from Software Components Group.  RTEID
was adopted by the VMEbus International Trade Association (VITA) as a
baseline draft for their proposed standard multiprocessor, real-time
executive interface, Open Real-Time Kernel Interface Definition
(ORKID).  These two groups are currently working together with the IEEE
P1003.4 committee to insure that the functionality of their proposed
standards is adopted as the real-time extensions to POSIX.

This emerging standard defines an interface for the development of
real-time software to ease the writing of real-time application
programs that are directly portable across multiple real-time executive
implementations.  This interface includes both the source code
interfaces and run-time behavior as seen by a real-time application.
It does not include the details of how a kernel implements these
functions.  The standard's goal is to serve as a complete definition of
external interfaces so that application code that conforms to these
interfaces will execute properly in all real-time executive
environments.  With the use of a standards compliant executive,
routines that acquire memory blocks, create and manage message queues,
establish and use semaphores, and send and receive signals need not be
redeveloped for a different real-time environment as long as the new
environment is compliant with the standard.  Software developers need
only concentrate on the hardware dependencies of the real-time system.
Furthermore, most hardware dependencies for real-time applications can
be localized to the device drivers.

A compliant executive provides simple and flexible real-time
multiprocessing.  It easily lends itself to both tightly-coupled and
loosely-coupled configurations (depending on the system hardware
configuration).  Objects such as tasks, queues, events, signals,
semaphores, and memory blocks can be designated as global objects and
accessed by any task regardless of which processor the object and the
accessing task reside.

The acceptance of a standard for real-time executives will produce the
same advantages enjoyed from the push for UNIX standardization by
AT&T's System V Interface Definition and IEEE's POSIX efforts.  A
compliant multiprocessing executive will allow close coupling between
UNIX systems and real-time executives to provide the many benefits of
the UNIX development environment to be applied to real-time software
development.  Together they provide the necessary laboratory
environment to implement real-time, distributed, embedded systems using
a wide variety of computer architectures.

A study was completed in 1988, within the Research, Development, and
Engineering Center, U.S. Army Missile Command, which compared the
various aspects of the Ada programming language as they related to the
application of Ada code in distributed and/or multiple processing
systems.  Several critical conclusions were derived from the study.
These conclusions have a major impact on the way the Army develops
application software for embedded applications. These impacts apply to
both in-house software development and contractor developed software.

A conclusion of the analysis, which has been previously recognized by
other agencies attempting to utilize Ada in a distributed or
multiprocessing environment, is that the Ada programming language does
not adequately support multiprocessing.  Ada does provide a mechanism
for multi-tasking, however, this capability exists only for a single
processor system.  The language also does not have inherent
capabilities to access global named variables, flags or program code.
These critical features are essential in order for data to be shared
between processors.  However, these drawbacks do have workarounds which
are sometimes awkward and defeat the intent of software maintainability
and portability goals.

Another conclusion drawn from the analysis, was that the run time
executives being delivered with the Ada compilers were too slow and
inefficient to be used in modern missile systems.  A run time executive
is the core part of the run time system code, or operating system code,
that controls task scheduling, input/output management and memory
management.  Traditionally, whenever efficient executive (also known as
kernel) code was required by the application, the user developed
in-house software.  This software was usually written in assembly
language for optimization.

Because of this shortcoming in the Ada programming language, software
developers in research and development and contractors for project
managed systems, are mandated by technology to purchase and utilize
off-the-shelf third party kernel code.  The contractor, and eventually
the Government, must pay a licensing fee for every copy of the kernel
code used in an embedded system.

The main drawback to this development environment is that the
Government does not own, nor has the right to modify code contained
within the kernel.  V&V techniques in this situation are more difficult
than if the complete source code were available. Responsibility for
system failures due to faulty software is yet another area to be
resolved under this environment.

The Guidance and Control Directorate began a software development
effort to address these problems.  A project to develop an experimental
run time kernel was begun that will eliminate the major drawbacks of
the Ada programming language mentioned above. The Real Time Executive
for Multiprocessor Systems (RTEMS) provides full capabilities for
management of tasks, interrupts, time, and multiple processors in
addition to those features typical of generic operating systems.  The
code is Government owned, so no licensing fees are necessary.  RTEMS has
been implemented in both the Ada and C programming languages.  It has
been ported to the following processor families:

   * Altera NIOS II

   * Analog Devices Blackfin

   * Atmel AVR

   * ARM

   * Freescale (formerly Motorola) MC68xxx

   * Freescale (formerly Motorola) MC683xx

   * Freescale (formerly Motorola) ColdFire

   * Intel i386 and above

   * Lattice Semiconductor LM32

   * MIPS

   * PowerPC

   * Renesas (formerly Hitachi) SuperH

   * Renesas (formerly Hitachi) H8/300

   * Renesas M32C

   * Renesas M32R

   * SPARC

   * Texas Instruments C3x/C4x

Support for other processor families, including RISC, CISC, and DSP, is
planned.  Since almost all of RTEMS is written in a high level language,
ports to additional processor families require minimal effort.

RTEMS multiprocessor support is capable of handling either homogeneous
or heterogeneous systems.  The kernel automatically compensates for
architectural differences (byte swapping, etc.) between processors.
This allows a much easier transition from one processor family to
another without a major system redesign.

Since the proposed standards are still in draft form, RTEMS cannot and
does not claim compliance.  However, the status of the standard is
being carefully monitored to guarantee that RTEMS provides the
functionality specified in the standard.  Once approved, RTEMS will be
made compliant.

This document is a detailed users guide for a functionally compliant
real-time multiprocessor executive.  It describes the user interface
and run-time behavior of Release 4.10.2 of the Ada interface to RTEMS.


File: ada_user.info,  Node: Overview,  Next: Overview Introduction,  Prev: Preface,  Up: Top

1 Overview
**********

* Menu:

* Overview Introduction::
* Overview Real-time Application Systems::
* Overview Real-time Executive::
* Overview RTEMS Application Architecture::
* Overview RTEMS Internal Architecture::
* Overview User Customization and Extensibility::
* Overview Portability::
* Overview Memory Requirements::
* Overview Audience::
* Overview Conventions::
* Overview Manual Organization::


File: ada_user.info,  Node: Overview Introduction,  Next: Overview Real-time Application Systems,  Prev: Overview,  Up: Overview

1.1 Introduction
================

RTEMS, Real-Time Executive for Multiprocessor Systems, is a real-time
executive (kernel) which provides a high performance environment for
embedded military applications including the following features:

   * multitasking capabilities

   * homogeneous and heterogeneous multiprocessor systems

   * event-driven, priority-based, preemptive scheduling

   * optional rate monotonic scheduling

   * intertask communication and synchronization

   * priority inheritance

   * responsive interrupt management

   * dynamic memory allocation

   * high level of user configurability

This manual describes the usage of RTEMS for applications written in
the Ada programming language.  Those implementation details that are
processor dependent are provided in the Applications Supplement
documents.  A supplement document which addresses specific
architectural issues that affect RTEMS is provided for each processor
type that is supported.


File: ada_user.info,  Node: Overview Real-time Application Systems,  Next: Overview Real-time Executive,  Prev: Overview Introduction,  Up: Overview

1.2 Real-time Application Systems
=================================

Real-time application systems are a special class of computer
applications.  They have a complex set of characteristics that
distinguish them from other software problems.  Generally, they must
adhere to more rigorous requirements.  The correctness of the system
depends not only on the results of computations, but also on the time
at which the results are produced.  The most important and complex
characteristic of real-time application systems is that they must
receive and respond to a set of external stimuli within rigid and
critical time constraints referred to as deadlines.  Systems can be
buried by an avalanche of interdependent, asynchronous or cyclical
event streams.

Deadlines can be further characterized as either hard or soft based
upon the value of the results when produced after the deadline has
passed.  A deadline is hard if the results have no value or if their
use will result in a catastrophic event.  In contrast, results which
are produced after a soft deadline may have some value.

Another distinguishing requirement of real-time application systems is
the ability to coordinate or manage a large number of concurrent
activities. Since software is a synchronous entity, this presents
special problems.  One instruction follows another in a repeating
synchronous cycle.  Even though mechanisms have been developed to allow
for the processing of external asynchronous events, the software design
efforts required to process and manage these events and tasks are
growing more complicated.

The design process is complicated further by spreading this activity
over a set of processors instead of a single processor. The challenges
associated with designing and building real-time application systems
become very complex when multiple processors are involved.  New
requirements such as interprocessor communication channels and global
resources that must be shared between competing processors are
introduced.  The ramifications of multiple processors complicate each
and every characteristic of a real-time system.


File: ada_user.info,  Node: Overview Real-time Executive,  Next: Overview RTEMS Application Architecture,  Prev: Overview Real-time Application Systems,  Up: Overview

1.3 Real-time Executive
=======================

Fortunately, real-time operating systems or real-time executives serve
as a cornerstone on which to build the application system.  A real-time
multitasking executive allows an application to be cast into a set of
logical, autonomous processes or tasks which become quite manageable.
Each task is internally synchronous, but different tasks execute
independently, resulting in an asynchronous processing stream.  Tasks
can be dynamically paused for many reasons resulting in a different
task being allowed to execute for a period of time.  The executive also
provides an interface to other system components such as interrupt
handlers and device drivers.  System components may request the
executive to allocate and coordinate resources, and to wait for and
trigger synchronizing conditions.  The executive system calls
effectively extend the CPU instruction set to support efficient
multitasking.  By causing tasks to travel through well-defined state
transitions, system calls permit an application to demand-switch between
tasks in response to real-time events.

By proper grouping of responses to stimuli into separate tasks, a
system can now asynchronously switch between independent streams of
execution, directly responding to external stimuli as they occur.  This
allows the system design to meet critical performance specifications
which are typically measured by guaranteed response time and
transaction throughput.  The multiprocessor extensions of RTEMS provide
the features necessary to manage the extra requirements introduced by a
system distributed across several processors.  It removes the physical
barriers of processor boundaries from the world of the system designer,
enabling more critical aspects of the system to receive the required
attention. Such a system, based on an efficient real-time,
multiprocessor executive, is a more realistic model of the outside
world or environment for which it is designed.  As a result, the system
will always be more logical, efficient, and reliable.

By using the directives provided by RTEMS, the real-time applications
developer is freed from the problem of controlling and synchronizing
multiple tasks and processors.  In addition, one need not develop,
test, debug, and document routines to manage memory, pass messages, or
provide mutual exclusion.  The developer is then able to concentrate
solely on the application.  By using standard software components, the
time and cost required to develop sophisticated real-time applications
is significantly reduced.


File: ada_user.info,  Node: Overview RTEMS Application Architecture,  Next: Overview RTEMS Internal Architecture,  Prev: Overview Real-time Executive,  Up: Overview

1.4 RTEMS Application Architecture
==================================

One important design goal of RTEMS was to provide a bridge between two
critical layers of typical real-time systems.  As shown in the
following figure, RTEMS serves as a buffer between the project
dependent application code and the target hardware.  Most hardware
dependencies for real-time applications can be localized to the low
level device drivers.

           +-----------------------------------------------------------+
           |             Application Dependent Software                |
           |        +----------------------------------------+         |
           |        |    Standard Application Components     |         |
           |        |                          +-------------+---+     |
           |    +---+-----------+              |                 |     |
           |    | Board Support |              |      RTEMS      |     |
           |    |    Package    |              |                 |     |
           +----+---------------+--------------+-----------------+-----|
           |                      Target Hardware                      |
           +-----------------------------------------------------------+

Figure    1.1: RTEMS Application Architecture

The RTEMS I/O interface manager provides an efficient tool for
incorporating these hardware dependencies into the system while
simultaneously providing a general mechanism to the application code
that accesses them.  A well designed real-time system can benefit from
this architecture by building a rich library of standard application
components which can be used repeatedly in other real-time projects.


File: ada_user.info,  Node: Overview RTEMS Internal Architecture,  Next: Overview User Customization and Extensibility,  Prev: Overview RTEMS Application Architecture,  Up: Overview

1.5 RTEMS Internal Architecture
===============================

RTEMS can be viewed as a set of layered components that work in harmony
to provide a set of services to a real-time application system.  The
executive interface presented to the application is formed by grouping
directives into logical sets called resource managers.  Functions
utilized by multiple managers such as scheduling, dispatching, and
object management are provided in the executive core.  The executive
core depends on a small set of CPU dependent routines.  Together these
components provide a powerful run time environment that promotes the
development of efficient real-time application systems.  The following
figure illustrates this organization:

                +-----------------------------------------------+
                |          RTEMS Executive Interface            |
                +-----------------------------------------------+
                |                 RTEMS Core                    |
                +-----------------------------------------------+
                |              CPU Dependent Code               |
                +-----------------------------------------------+

Figure    1.2: RTEMS Layered Architecture

Subsequent chapters present a detailed description of the capabilities
provided by each of the following RTEMS managers:

   * initialization

   * task

   * interrupt

   * clock

   * timer

   * semaphore

   * message

   * event

   * signal

   * partition

   * region

   * dual ported memory

   * I/O

   * fatal error

   * rate monotonic

   * user extensions

   * multiprocessing


File: ada_user.info,  Node: Overview User Customization and Extensibility,  Next: Overview Portability,  Prev: Overview RTEMS Internal Architecture,  Up: Overview

1.6 User Customization and Extensibility
========================================

As thirty-two bit microprocessors have decreased in cost, they have
become increasingly common in a variety of embedded systems.  A wide
range of custom and general-purpose processor boards are based on
various thirty-two bit processors.  RTEMS was designed to make no
assumptions concerning the characteristics of individual microprocessor
families or of specific support hardware.  In addition, RTEMS allows
the system developer a high degree of freedom in customizing and
extending its features.

RTEMS assumes the existence of a supported microprocessor and
sufficient memory for both RTEMS and the real-time application.  Board
dependent components such as clocks, interrupt controllers, or I/O
devices can be easily integrated with RTEMS.  The customization and
extensibility features allow RTEMS to efficiently support as many
environments as possible.


File: ada_user.info,  Node: Overview Portability,  Next: Overview Memory Requirements,  Prev: Overview User Customization and Extensibility,  Up: Overview

1.7 Portability
===============

The issue of portability was the major factor in the creation of RTEMS.
Since RTEMS is designed to isolate the hardware dependencies in the
specific board support packages, the real-time application should be
easily ported to any other processor.  The use of RTEMS allows the
development of real-time applications which can be completely
independent of a particular microprocessor architecture.


File: ada_user.info,  Node: Overview Memory Requirements,  Next: Overview Audience,  Prev: Overview Portability,  Up: Overview

1.8 Memory Requirements
=======================

Since memory is a critical resource in many real-time embedded systems,
RTEMS was specifically designed to automatically leave out all services
that are not required from the run-time environment.  Features such as
networking, various fileystems, and many other features are completely
optional.  This allows the application designer the flexibility to
tailor RTEMS to most efficiently meet system requirements while still
satisfying even the most stringent memory constraints.  As a result,
the size of the RTEMS executive is application dependent.

RTEMS requires RAM to manage each instance of an RTEMS object that is
created.  Thus the more RTEMS objects an application needs, the more
memory that must be reserved.  See *note Configuring a System
Determining Memory Requirements:: for more details.

RTEMS utilizes memory for both code and data space.  Although RTEMS'
data space must be in RAM, its code space can be located in either ROM
or RAM.


File: ada_user.info,  Node: Overview Audience,  Next: Overview Conventions,  Prev: Overview Memory Requirements,  Up: Overview

1.9 Audience
============

This manual was written for experienced real-time software developers.
Although some background is provided, it is assumed that the reader is
familiar with the concepts of task management as well as intertask
communication and synchronization.  Since directives, user related data
structures, and examples are presented in Ada, a basic understanding of
the Ada programming language is required to fully understand the
material presented.  However, because of the similarity of the Ada and
C RTEMS implementations, users will find that the use and behavior of
the two implementations is very similar.  A working knowledge of the
target processor is helpful in understanding some of RTEMS' features.
A thorough understanding of the executive cannot be obtained without
studying the entire manual because many of RTEMS' concepts and features
are interrelated.  Experienced RTEMS users will find that the manual
organization facilitates its use as a reference document.


File: ada_user.info,  Node: Overview Conventions,  Next: Overview Manual Organization,  Prev: Overview Audience,  Up: Overview

1.10 Conventions
================

The following conventions are used in this manual:

   * Significant words or phrases as well as all directive names are
     printed in bold type.

   * Items in bold capital letters are constants defined by RTEMS.
     Each language interface provided by RTEMS includes a file
     containing the standard set of constants, data types, and record
     definitions which can be incorporated into the user application.

   * A number of type definitions are provided by RTEMS and can be
     found in rtems.h.

   * The characters "0x" preceding a number indicates that the number
     is in hexadecimal format.  Any other numbers are assumed to be in
     decimal format.


File: ada_user.info,  Node: Overview Manual Organization,  Next: Key Concepts,  Prev: Overview Conventions,  Up: Overview

1.11 Manual Organization
========================

This first chapter has presented the introductory and background
material for the RTEMS executive.  The remaining chapters of this
manual present a detailed description of RTEMS and the environment,
including run time behavior, it creates for the user.

A chapter is dedicated to each manager and provides a detailed
discussion of each RTEMS manager and the directives which it provides.
The presentation format for each directive includes the following
sections:

   * Calling sequence

   * Directive status codes

   * Description

   * Notes

The following provides an overview of the remainder of this manual:

Chapter 2
     Key Concepts: presents an introduction to the ideas which are
     common across multiple RTEMS managers.

Chapter 3:
     RTEMS Data Types: describes the fundamental data types shared by
     the services in the RTEMS Classic API.

Chapter 4:
     Initialization Manager: describes the functionality and directives
     provided by the Initialization Manager.

Chapter 5:
     Task Manager: describes the functionality and directives provided
     by the Task Manager.

Chapter 6:
     Interrupt Manager: describes the functionality and directives
     provided by the Interrupt Manager.

Chapter 7:
     Clock Manager: describes the functionality and directives provided
     by the Clock Manager.

Chapter 8:
     Timer Manager: describes the functionality and directives provided
     by the Timer Manager.

Chapter 9:
     Semaphore Manager: describes the functionality and directives
     provided by the Semaphore Manager.

Chapter 10:
     Message Manager: describes the functionality and directives
     provided by the Message Manager.

Chapter 11:
     Event Manager: describes the functionality and directives provided
     by the Event Manager.

Chapter 12:
     Signal Manager: describes the functionality and directives
     provided by the Signal Manager.

Chapter 13:
     Partition Manager: describes the functionality and directives
     provided by the Partition Manager.

Chapter 14:
     Region Manager: describes the functionality and directives
     provided by the Region Manager.

Chapter 15:
     Dual-Ported Memory Manager: describes the functionality and
     directives provided by the Dual-Ported Memory Manager.

Chapter 16:
     I/O Manager: describes the functionality and directives provided
     by the I/O Manager.

Chapter 17:
     Fatal Error Manager: describes the functionality and directives
     provided by the Fatal Error Manager.

Chapter 18:
     Scheduling Concepts: details the RTEMS scheduling algorithm and
     task state transitions.

Chapter 19:
     Rate Monotonic Manager: describes the functionality and directives
     provided by the Rate Monotonic Manager.

Chapter 20:
     Board Support Packages: defines the functionality required of
     user-supplied board support packages.

Chapter 21:
     User Extensions: shows the user how to extend RTEMS to incorporate
     custom features.

Chapter 22:
     Configuring a System: details the process by which one tailors
     RTEMS for a particular single-processor or multiprocessor
     application.

Chapter 23:
     Multiprocessing Manager: presents a conceptual overview of the
     multiprocessing capabilities provided by RTEMS as well as
     describing the Multiprocessing Communications Interface Layer and
     Multiprocessing Manager directives.

Chapter 24:
     Directive Status Codes: provides a definition of each of the
     directive status codes referenced in this manual.

Chapter 25:
     Example Application: provides a template for simple RTEMS
     applications.

Chapter 26:
     Glossary: defines terms used throughout this manual.



File: ada_user.info,  Node: Key Concepts,  Next: Key Concepts Introduction,  Prev: Overview Manual Organization,  Up: Top

2 Key Concepts
**************

* Menu:

* Key Concepts Introduction::
* Key Concepts Objects::
* Key Concepts Communication and Synchronization::
* Key Concepts Time::
* Key Concepts Memory Management::


File: ada_user.info,  Node: Key Concepts Introduction,  Next: Key Concepts Objects,  Prev: Key Concepts,  Up: Key Concepts

2.1 Introduction
================

The facilities provided by RTEMS are built upon a foundation of very
powerful concepts.  These concepts must be understood before the
application developer can efficiently utilize RTEMS.  The purpose of
this chapter is to familiarize one with these concepts.


File: ada_user.info,  Node: Key Concepts Objects,  Next: Key Concepts Object Names,  Prev: Key Concepts Introduction,  Up: Key Concepts

2.2 Objects
===========

* Menu:

* Key Concepts Object Names::
* Key Concepts Object IDs::
* Key Concepts Object ID Description::

RTEMS provides directives which can be used to dynamically create,
delete, and manipulate a set of predefined object types.  These types
include tasks, message queues, semaphores, memory regions, memory
partitions, timers, ports, and rate monotonic periods.  The
object-oriented nature of RTEMS encourages the creation of modular
applications built upon re-usable "building block" routines.

All objects are created on the local node as required by the
application and have an RTEMS assigned ID.  All objects have a
user-assigned name.  Although a relationship exists between an object's
name and its RTEMS assigned ID, the name and ID are not identical.
Object names are completely arbitrary and selected by the user as a
meaningful "tag" which may commonly reflect the object's use in the
application.  Conversely, object IDs are designed to facilitate
efficient object manipulation by the executive.


File: ada_user.info,  Node: Key Concepts Object Names,  Next: Key Concepts Object IDs,  Prev: Key Concepts Objects,  Up: Key Concepts Objects

2.2.1 Object Names
------------------

An object name is an unsigned thirty-two bit entity associated with the
object by the user.  The data type `rtems.name' is used to store object
names.

Although not required by RTEMS, object names are often composed of four
ASCII characters which help identify that object.  For example, a task
which causes a light to blink might be called "LITE".  The
`rtems.build_name' routine is provided to build an object name from
four ASCII characters.  The following example illustrates this:

     My_Name : RTEMS.Name;

     My_Name = RTEMS.Build_Name( 'L', 'I', 'T', 'E' );

However, it is not required that the application use ASCII characters
to build object names.  For example, if an application requires
one-hundred tasks, it would be difficult to assign meaningful ASCII
names to each task.  A more convenient approach would be to name them
the binary values one through one-hundred, respectively.


File: ada_user.info,  Node: Key Concepts Object IDs,  Next: Key Concepts Thirty-Two Object ID Format,  Prev: Key Concepts Object Names,  Up: Key Concepts Objects

2.2.2 Object IDs
----------------

* Menu:

* Key Concepts Thirty-Two Object ID Format::
* Key Concepts Sixteen Bit Object ID Format::

An object ID is a unique unsigned integer value which uniquely
identifies an object instance.  Object IDs are passed as arguments to
many directives in RTEMS and RTEMS translates the ID to an internal
object pointer. The efficient manipulation of object IDs is critical to
the performance of RTEMS services.  Because of this, there are two
object Id formats defined.  Each target architecture specifies which
format it will use.  There is a thirty-two bit format which is used for
most of the supported architectures and supports multiprocessor
configurations.  There is also a simpler sixteen bit format which is
appropriate for smaller target architectures and does not support
multiprocessor configurations.


File: ada_user.info,  Node: Key Concepts Thirty-Two Object ID Format,  Next: Key Concepts Sixteen Bit Object ID Format,  Prev: Key Concepts Object IDs,  Up: Key Concepts Object IDs

2.2.2.1 Thirty-Two Object ID Format
...................................

The thirty-two bit format for an object ID is composed of four parts:
API, object class, node, and index.  The data type `rtems.id' is used
to store object IDs.

          31      27 26   24 23          16 15                             0
          +---------+-------+--------------+-------------------------------+
          |         |       |              |                               |
          |  Class  |  API  |     Node     |             Index             |
          |         |       |              |                               |
          +---------+-------+--------------+-------------------------------+

Figure    2.1: Thirty-Two Bit Object Id

The most significant five bits are the object class.  The next three
bits indicate the API to which the object class belongs.  The next
eight bits (16-23) are the number of the node on which this object was
created.  The node number is always one (1) in a single processor
system.  The least significant sixteen bits form an identifier within a
particular object type.  This identifier, called the object index,
ranges in value from 1 to the maximum number of objects configured for
this object type.


File: ada_user.info,  Node: Key Concepts Sixteen Bit Object ID Format,  Next: Key Concepts Object ID Description,  Prev: Key Concepts Thirty-Two Object ID Format,  Up: Key Concepts Object IDs

2.2.2.2 Sixteen Bit Object ID Format
....................................

The sixteen bit format for an object ID is composed of three parts: API,
object class, and index.  The data type `rtems.id' is used to store
object IDs.

          15      11 10    8 7            0
          +---------+-------+--------------+
          |         |       |              |
          |  Class  |  API  |    Index     |
          |         |       |              |
          +---------+-------+--------------+

Figure    2.2: Sixteen Bit Object Id

The sixteen-bit format is designed to be as similar as possible to the
thrity-two bit format.  The differences are limited to the eliminatation
of the node field and reduction of the index field from sixteen-bits to
8-bits.  Thus the sixteen bit format only supports up to 255 object
instances per API/Class combination and single processor systems.  As
this format is typically utilized by sixteen-bit processors with
limited address space, this is more than enough object instances.


File: ada_user.info,  Node: Key Concepts Object ID Description,  Next: Key Concepts Communication and Synchronization,  Prev: Key Concepts Sixteen Bit Object ID Format,  Up: Key Concepts Objects

2.2.3 Object ID Description
---------------------------

The components of an object ID make it possible to quickly locate any
object in even the most complicated multiprocessor system.  Object ID's
are associated with an object by RTEMS when the object is created and
the corresponding ID is returned by the appropriate object create
directive.  The object ID is required as input to all directives
involving objects, except those which create an object or obtain the ID
of an object.

The object identification directives can be used to dynamically obtain
a particular object's ID given its name.  This mapping is accomplished
by searching the name table associated with this object type.  If the
name is non-unique, then the ID associated with the first occurrence of
the name will be returned to the application.  Since object IDs are
returned when the object is created, the object identification
directives are not necessary in a properly designed single processor
application.

In addition, services are provided to portably examine the
subcomponents of an RTEMS ID.  These services are described in detail
later in this manual but are prototyped as follows:

     uint32_t rtems_object_id_get_api( rtems_id );
     uint32_t rtems_object_id_get_class( rtems_id );
     uint32_t rtems_object_id_get_node( rtems_id );
     uint32_t rtems_object_id_get_index( rtems_id );

An object control block is a data structure defined by RTEMS which
contains the information necessary to manage a particular object type.
For efficiency reasons, the format of each object type's control block
is different.  However, many of the fields are similar in function.
The number of each type of control block is application dependent and
determined by the values specified in the user's Configuration Table.
An object control block is allocated at object create time and freed
when the object is deleted.  With the exception of user extension
routines, object control blocks are not directly manipulated by user
applications.


File: ada_user.info,  Node: Key Concepts Communication and Synchronization,  Next: Key Concepts Time,  Prev: Key Concepts Object ID Description,  Up: Key Concepts

2.3 Communication and Synchronization
=====================================

In real-time multitasking applications, the ability for cooperating
execution threads to communicate and synchronize with each other is
imperative.  A real-time executive should provide an application with
the following capabilities:

   * Data transfer between cooperating tasks

   * Data transfer between tasks and ISRs

   * Synchronization of cooperating tasks

   * Synchronization of tasks and ISRs

Most RTEMS managers can be used to provide some form of communication
and/or synchronization.  However, managers dedicated specifically to
communication and synchronization provide well established mechanisms
which directly map to the application's varying needs.  This level of
flexibility allows the application designer to match the features of a
particular manager with the complexity of communication and
synchronization required.  The following managers were specifically
designed for communication and synchronization:

   * Semaphore

   * Message Queue

   * Event

   * Signal

The semaphore manager supports mutual exclusion involving the
synchronization of access to one or more shared user resources.  Binary
semaphores may utilize the optional priority inheritance algorithm to
avoid the problem of priority inversion.  The message manager supports
both communication and synchronization, while the event manager
primarily provides a high performance synchronization mechanism.  The
signal manager supports only asynchronous communication and is
typically used for exception handling.


File: ada_user.info,  Node: Key Concepts Time,  Next: Key Concepts Memory Management,  Prev: Key Concepts Communication and Synchronization,  Up: Key Concepts

2.4 Time
========

The development of responsive real-time applications requires an
understanding of how RTEMS maintains and supports time-related
operations.  The basic unit of time in RTEMS is known as a tick.  The
frequency of clock ticks is completely application dependent and
determines the granularity and accuracy of all interval and calendar
time operations.

By tracking time in units of ticks, RTEMS is capable of supporting
interval timing functions such as task delays, timeouts, timeslicing,
the delayed execution of timer service routines, and the rate monotonic
scheduling of tasks.  An interval is defined as a number of ticks
relative to the current time.  For example, when a task delays for an
interval of ten ticks, it is implied that the task will not execute
until ten clock ticks have occurred.  All intervals are specified using
data type `rtems.interval'.

A characteristic of interval timing is that the actual interval period
may be a fraction of a tick less than the interval requested.  This
occurs because the time at which the delay timer is set up occurs at
some time between two clock ticks.  Therefore, the first countdown tick
occurs in less than the complete time interval for a tick.  This can be
a problem if the clock granularity is large.

The rate monotonic scheduling algorithm is a hard real-time scheduling
methodology.  This methodology provides rules which allows one to
guarantee that a set of independent periodic tasks will always meet
their deadlines - even under transient overload conditions.  The rate
monotonic manager provides directives built upon the Clock Manager's
interval timer support routines.

Interval timing is not sufficient for the many applications which
require that time be kept in wall time or true calendar form.
Consequently, RTEMS maintains the current date and time.  This allows
selected time operations to be scheduled at an actual calendar date and
time.  For example, a task could request to delay until midnight on New
Year's Eve before lowering the ball at Times Square.  The data type
`rtems.time_of_day' is used to specify calendar time in RTEMS services.
*Note Time and Date Data Structures: Clock Manager Time and Date Data
Structures.  

Obviously, the directives which use intervals or wall time cannot
operate without some external mechanism which provides a periodic clock
tick.  This clock tick is typically provided by a real time clock or
counter/timer device.


File: ada_user.info,  Node: Key Concepts Memory Management,  Next: RTEMS Data Types,  Prev: Key Concepts Time,  Up: Key Concepts

2.5 Memory Management
=====================

RTEMS memory management facilities can be grouped into two classes:
dynamic memory allocation and address translation.  Dynamic memory
allocation is required by applications whose memory requirements vary
through the application's course of execution.  Address translation is
needed by applications which share memory with another CPU or an
intelligent Input/Output processor.  The following RTEMS managers
provide facilities to manage memory:

   * Region

   * Partition

   * Dual Ported Memory

RTEMS memory management features allow an application to create simple
memory pools of fixed size buffers and/or more complex memory pools of
variable size segments.  The partition manager provides directives to
manage and maintain pools of fixed size entities such as resource
control blocks.  Alternatively, the region manager provides a more
general purpose memory allocation scheme that supports variable size
blocks of memory which are dynamically obtained and freed by the
application.  The dual-ported memory manager provides executive support
for address translation between internal and external dual-ported RAM
address space.


File: ada_user.info,  Node: RTEMS Data Types,  Next: RTEMS Data Types Introduction,  Prev: Key Concepts Memory Management,  Up: Top

3 RTEMS Data Types
******************

* Menu:

* RTEMS Data Types Introduction::
* RTEMS Data Types List of Data Types::


File: ada_user.info,  Node: RTEMS Data Types Introduction,  Next: RTEMS Data Types List of Data Types,  Prev: RTEMS Data Types,  Up: RTEMS Data Types

3.1 Introduction
================

This chapter contains a complete list of the RTEMS primitive data types
in alphabetical order.  This is intended to be an overview and the user
is encouraged to look at the appropriate chapters in the manual for
more information about the usage of the various data types.


File: ada_user.info,  Node: RTEMS Data Types List of Data Types,  Next: Initialization Manager,  Prev: RTEMS Data Types Introduction,  Up: RTEMS Data Types

3.2 List of Data Types
======================

The following is a complete list of the RTEMS primitive data types in
alphabetical order:

   * `rtems.address' is the data type used to manage addresses.  It is
     equivalent to the System.Address data type.

   * `rtems.asr' is the return type for an RTEMS ASR.

   * `rtems.asr_entry' is the address of the entry point to an RTEMS
     ASR.

   * `rtems.attribute' is the data type used to manage the attributes
     for RTEMS objects.  It is primarily used as an argument to object
     create routines to specify characteristics of the new object.

   * `rtems.boolean' may only take on the values of `TRUE' and `FALSE'.

     This type is deprecated. Use "bool" instead.

   * `rtems.context' is the CPU dependent data structure used to manage
     the integer and system register portion of each task's context.

   * `rtems.context_fp' is the CPU dependent data structure used to
     manage the floating point portion of each task's context.

   * `rtems.device_driver' is the return type for a RTEMS device driver
     routine.

   * `rtems.device_driver_entry' is the entry point to a RTEMS device
     driver routine.

   * `rtems.device_major_number' is the data type used to manage device
     major numbers.

   * `rtems.device_minor_number' is the data type used to manage device
     minor numbers.

   * `rtems.double' is the RTEMS data type that corresponds to double
     precision floating point on the target hardware.

     This type is deprecated. Use "double" instead.

   * `rtems.event_set' is the data type used to manage and manipulate
     RTEMS event sets with the Event Manager.

   * `rtems.extension' is the return type for RTEMS user extension
     routines.

   * `rtems.fatal_extension' is the entry point for a fatal error user
     extension handler routine.

   * `rtems.id' is the data type used to manage and manipulate RTEMS
     object IDs.

   * `rtems.interrupt_frame' is the data structure that defines the
     format of the interrupt stack frame as it appears to a user ISR.
     This data structure may not be defined on all ports.

   * `rtems.interrupt_level' is the data structure used with the
     `rtems.interrupt_disable', `rtems.interrupt_enable', and
     `rtems.interrupt_flash' routines.  This data type is CPU dependent
     and usually corresponds to the contents of the processor register
     containing the interrupt mask level.

   * `rtems.interval' is the data type used to manage and manipulate
     time intervals.  Intervals are non-negative integers used to
     measure the length of time in clock ticks.

   * `rtems.isr' is the return type of a function implementing an RTEMS
     ISR.

   * `rtems.isr_entry' is the address of the entry point to an RTEMS
     ISR.  It is equivalent to the entry point of the function
     implementing the ISR.

   * `rtems.mp_packet_classes' is the enumerated type which specifies
     the categories of multiprocessing messages.  For example, one of
     the classes is for messages that must be processed by the Task
     Manager.

   * `rtems.mode' is the data type used to manage and dynamically
     manipulate the execution mode of an RTEMS task.

   * `rtems.mpci_entry' is the return type of an RTEMS MPCI routine.

   * `rtems.mpci_get_packet_entry' is the address of the entry point to
     the get packet routine for an MPCI implementation.

   * `rtems.mpci_initialization_entry' is the address of the entry
     point to the initialization routine for an MPCI implementation.

   * `rtems.mpci_receive_packet_entry' is the address of the entry
     point to the receive packet routine for an MPCI implementation.

   * `rtems.mpci_return_packet_entry' is the address of the entry point
     to the return packet routine for an MPCI implementation.

   * `rtems.mpci_send_packet_entry' is the address of the entry point
     to the send packet routine for an MPCI implementation.

   * `rtems.mpci_table' is the data structure containing the
     configuration information for an MPCI.

   * `rtems.name' is the data type used to contain the name of a
     Classic API object.  It is an unsigned thirty-two bit integer
     which can be treated as a numeric value or initialized using
     `rtems.build_name' to contain four ASCII characters.

   * `rtems.option' is the data type used to specify which behavioral
     options the caller desires.  It is commonly used with potentially
     blocking directives to specify whether the caller is willing to
     block or return immediately with an error indicating that the
     resource was not available.

   * `rtems.packet_prefix' is the data structure that defines the first
     bytes in every packet sent between nodes in an RTEMS
     multiprocessor system.  It contains routing information that is
     expected to be used by the MPCI layer.

   * `rtems.signal_set' is the data type used to manage and manipulate
     RTEMS signal sets with the Signal Manager.

   * `int8_t' is the C99 data type that corresponds to signed eight bit
     integers.  This data type is defined by RTEMS in a manner that
     ensures it is portable across different target processors.

   * `int16_t' is the C99 data type that corresponds to signed sixteen
     bit integers.  This data type is defined by RTEMS in a manner that
     ensures it is portable across different target processors.

   * `int32_t' is the C99 data type that corresponds to signed
     thirty-two bit integers.  This data type is defined by RTEMS in a
     manner that ensures it is portable across different target
     processors.

   * `int64_t' is the C99 data type that corresponds to signed
     sixty-four bit integers.  This data type is defined by RTEMS in a
     manner that ensures it is portable across different target
     processors.

   * `rtems.single' is the RTEMS data type that corresponds to single
     precision floating point on the target hardware.

     This type is deprecated. Use "float" instead.

   * `rtems.status_codes' is the return type for most RTEMS services.
     This is an enumerated type of approximately twenty-five values.
     In general, when a service returns a particular status code, it
     indicates that a very specific error condition has occurred.

   * `rtems.task' is the return type for an RTEMS Task.

   * `rtems.task_argument' is the data type for the argument passed to
     each RTEMS task. In RTEMS 4.7 and older, this is an unsigned
     thirty-two bit integer.  In RTEMS 4.8 and newer, this is based
     upon the C99 type `uintptr_t' which is guaranteed to be an integer
     large enough to hold a pointer on the target architecture.

   * `rtems.task_begin_extension' is the entry point for a task
     beginning execution user extension handler routine.

   * `rtems.task_create_extension' is the entry point for a task
     creation execution user extension handler routine.

   * `rtems.task_delete_extension' is the entry point for a task
     deletion user extension handler routine.

   * `rtems.task_entry' is the address of the entry point to an RTEMS
     ASR.  It is equivalent to the entry point of the function
     implementing the ASR.

   * `rtems.task_exitted_extension' is the entry point for a task
     exitted user extension handler routine.

   * `rtems.task_priority' is the data type used to manage and
     manipulate task priorities.

   * `rtems.task_restart_extension' is the entry point for a task
     restart user extension handler routine.

   * `rtems.task_start_extension' is the entry point for a task start
     user extension handler routine.

   * `rtems.task_switch_extension' is the entry point for a task
     context switch user extension handler routine.

   * `rtems.tcb' is the data structure associated with each task in an
     RTEMS system.

   * `rtems.time_of_day' is the data structure used to manage and
     manipulate calendar time in RTEMS.

   * `rtems.timer_service_routine' is the return type for an RTEMS
     Timer Service Routine.

   * `rtems.timer_service_routine_entry' is the address of the entry
     point to an RTEMS TSR.  It is equivalent to the entry point of the
     function implementing the TSR.

   * `rtems.vector_number' is the data type used to manage and
     manipulate interrupt vector numbers.

   * `uint8_t' is the C99 data type that corresponds to unsigned eight
     bit integers.  This data type is defined by RTEMS in a manner that
     ensures it is portable across different target processors.

   * `uint16_t' is the C99 data type that corresponds to unsigned
     sixteen bit integers.  This data type is defined by RTEMS in a
     manner that ensures it is portable across different target
     processors.

   * `uint32_t' is the C99 data type that corresponds to unsigned
     thirty-two bit integers.  This data type is defined by RTEMS in a
     manner that ensures it is portable across different target
     processors.

   * `uint64_t' is the C99 data type that corresponds to unsigned
     sixty-four bit integers.  This data type is defined by RTEMS in a
     manner that ensures it is portable across different target
     processors.

   * `uintptr_t' is the C99 data type that corresponds to the unsigned
     integer type that is of sufficient size to represent addresses as
     unsigned integers.  This data type is defined by RTEMS in a manner
     that ensures it is portable across different target processors.



File: ada_user.info,  Node: Initialization Manager,  Next: Initialization Manager Introduction,  Prev: RTEMS Data Types List of Data Types,  Up: Top

4 Initialization Manager
************************

* Menu:

* Initialization Manager Introduction::
* Initialization Manager Background::
* Initialization Manager Operations::
* Initialization Manager Directives::


File: ada_user.info,  Node: Initialization Manager Introduction,  Next: Initialization Manager Background,  Prev: Initialization Manager,  Up: Initialization Manager

4.1 Introduction
================

The Initialization Manager is responsible for initiating and shutting
down RTEMS.  Initiating RTEMS involves creating and starting all
configured initialization tasks, and for invoking the initialization
routine for each user-supplied device driver.  In a multiprocessor
configuration, this manager also initializes the interprocessor
communications layer.  The directives provided by the Initialization
Manager are:

   * `rtems.initialize_data_structures' - Initialize RTEMS Data
     Structures

   * `rtems.initialize_before_drivers' - Perform Initialization Before
     Device Drivers

   * `rtems.initialize_device_drivers' - Initialize Device Drivers

   * `rtems.initialize_start_multitasking' - Complete Initialization
     and Start Multitasking

   * `rtems.shutdown_executive' - Shutdown RTEMS


File: ada_user.info,  Node: Initialization Manager Background,  Next: Initialization Manager Initialization Tasks,  Prev: Initialization Manager Introduction,  Up: Initialization Manager

4.2 Background
==============

* Menu:

* Initialization Manager Initialization Tasks::
* Initialization Manager System Initialization::
* Initialization Manager The Idle Task::
* Initialization Manager Initialization Manager Failure::


File: ada_user.info,  Node: Initialization Manager Initialization Tasks,  Next: Initialization Manager System Initialization,  Prev: Initialization Manager Background,  Up: Initialization Manager Background

4.2.1 Initialization Tasks
--------------------------

Initialization task(s) are the mechanism by which RTEMS transfers
initial control to the user's application.  Initialization tasks differ
from other application tasks in that they are defined in the User
Initialization Tasks Table and automatically created and started by
RTEMS as part of its initialization sequence.  Since the initialization
tasks are scheduled using the same algorithm as all other RTEMS tasks,
they must be configured at a priority and mode which will ensure that
they will complete execution before other application tasks execute.
Although there is no upper limit on the number of initialization tasks,
an application is required to define at least one.

A typical initialization task will create and start the static set of
application tasks.  It may also create any other objects used by the
application.  Initialization tasks which only perform initialization
should delete themselves upon completion to free resources for other
tasks.  Initialization tasks may transform themselves into a "normal"
application task.  This transformation typically involves changing
priority and execution mode.  RTEMS does not automatically delete the
initialization tasks.


File: ada_user.info,  Node: Initialization Manager System Initialization,  Next: Initialization Manager The Idle Task,  Prev: Initialization Manager Initialization Tasks,  Up: Initialization Manager Background

4.2.2 System Initialization
---------------------------

System Initialization begins with board reset and continues through
RTEMS initialization, initialization of all device drivers, and
eventually a context switch to the first user task.  Remember, that
interrupts are disabled during initialization and the initialization
thread is not a task in any sense and the user should be very careful
during initialzation.

The BSP must ensure that the there is enough stack space reserved for
the initialization "thread" to successfully execute the initialization
routines for all device drivers and, in multiprocessor configurations,
the Multiprocessor Communications Interface Layer initialization
routine.


File: ada_user.info,  Node: Initialization Manager The Idle Task,  Next: Initialization Manager Initialization Manager Failure,  Prev: Initialization Manager System Initialization,  Up: Initialization Manager Background

4.2.3 The Idle Task
-------------------

The Idle Task is the lowest priority task in a system and executes only
when no other task is ready to execute.  This default implementation of
this task consists of an infinite loop. RTEMS allows the Idle Task body
to be replaced by a CPU specific implementation, a BSP specific
implementation or an application specific implementation.

The Idle Task is preemptible and WILL be preempted when any other task
is made ready to execute.  This characteristic is critical to the
overall behavior of any application.


File: ada_user.info,  Node: Initialization Manager Initialization Manager Failure,  Next: Initialization Manager Operations,  Prev: Initialization Manager The Idle Task,  Up: Initialization Manager Background

4.2.4 Initialization Manager Failure
------------------------------------

The `rtems.fatal_error_occurred' directive will be invoked from
`rtems.initialize_executive' for any of the following reasons:

   * If either the Configuration Table or the CPU Dependent Information
     Table is not provided.

   * If the starting address of the RTEMS RAM Workspace, supplied by
     the application in the Configuration Table, is NULL or is not
     aligned on a four-byte boundary.

   * If the size of the RTEMS RAM Workspace is not large enough to
     initialize and configure the system.

   * If the interrupt stack size specified is too small.

   * If multiprocessing is configured and the node entry in the
     Multiprocessor Configuration Table is not between one and the
     maximum_nodes entry.

   * If a multiprocessor system is being configured and no
     Multiprocessor Communications Interface is specified.

   * If no user initialization tasks are configured.  At least one
     initialization task must be configured to allow RTEMS to pass
     control to the application at the end of the executive
     initialization sequence.

   * If any of the user initialization tasks cannot be created or
     started successfully.

A discussion of RTEMS actions when a fatal error occurs may be found
*note Fatal Error Manager Announcing a Fatal Error::.


File: ada_user.info,  Node: Initialization Manager Operations,  Next: Initialization Manager Initializing RTEMS,  Prev: Initialization Manager Initialization Manager Failure,  Up: Initialization Manager

4.3 Operations
==============

* Menu:

* Initialization Manager Initializing RTEMS::
* Initialization Manager Shutting Down RTEMS::


File: ada_user.info,  Node: Initialization Manager Initializing RTEMS,  Next: Initialization Manager Shutting Down RTEMS,  Prev: Initialization Manager Operations,  Up: Initialization Manager Operations

4.3.1 Initializing RTEMS
------------------------

The Initialization Manager directives are called by the Board Support
Package framework as part of its initialization sequence.  RTEMS
assumes that the Board Support Package successfully completed its
initialization activities.  These directives initialize RTEMS by
performing the following actions:

   * Initializing internal RTEMS variables;

   * Allocating system resources;

   * Creating and starting the Idle Task;

   * Initialize all device drivers;

   * Creating and starting the user initialization task(s); and

   * Initiating multitasking.

The initialization directives MUST be called in the proper sequence
before any blocking directives may be used.  The services in this
manager should be invoked just once per application and in precisely
the following order:

   * `rtems.initialize_data_structures'

   * `rtems.initialize_before_drivers'

   * `rtems.initialize_device_drivers'

   * `rtems.initialize_start_multitasking'

It is recommended that the Board Support Package use the provided
framework which will invoke these services as part of the executing the
function `boot_card' in the file `c/src/lib/libbsp/shared/bootcard.c'.
This framework will also assist in allocating memory to the RTEMS
Workspace and C Program Heap and initializing the C Library.

The effect of calling any blocking RTEMS directives before
`rtems.initialize_start_multitasking' is unpredictable but guaranteed
to be bad.  After the directive `rtems.initialize_data_structures' is
invoked, it is permissible to allocate RTEMS objects and perform
non-blocking operations.  But the user should be distinctly aware that
multitasking is not available yet and they are NOT executing in a task
context.

Many of RTEMS actions during initialization are based upon the contents
of the Configuration Table.  For more information regarding the format
and contents of this table, please refer to the chapter *note
Configuring a System::.

The final step in the initialization sequence is the initiation of
multitasking.  When the scheduler and dispatcher are enabled, the
highest priority, ready task will be dispatched to run.  Control will
not be returned to the Board Support Package after multitasking is
enabled until the `rtems.shutdown_executive' directive is called.  This
directive is called as a side-effect of POSIX calls including `exit'.


File: ada_user.info,  Node: Initialization Manager Shutting Down RTEMS,  Next: Initialization Manager Directives,  Prev: Initialization Manager Initializing RTEMS,  Up: Initialization Manager Operations

4.3.2 Shutting Down RTEMS
-------------------------

The `rtems.shutdown_executive' directive is invoked by the application
to end multitasking and return control to the board support package.
The board support package resumes execution at the code immediately
following the invocation of the `rtems.initialize_start_multitasking'
directive.


File: ada_user.info,  Node: Initialization Manager Directives,  Next: Initialization Manager INITIALIZE_DATA_STRUCTURES - Initialize RTEMS Data Structures,  Prev: Initialization Manager Shutting Down RTEMS,  Up: Initialization Manager

4.4 Directives
==============

* Menu:

* Initialization Manager INITIALIZE_DATA_STRUCTURES - Initialize RTEMS Data Structures::
* Initialization Manager INITIALIZE_BEFORE_DRIVERS - Perform Initialization Before Device Drivers::
* Initialization Manager INITIALIZE_DEVICE_DRIVERS - Initialize Device Drivers::
* Initialization Manager INITIALIZE_START_MULTITASKING - Complete Initialization and Start Multitasking::
* Initialization Manager SHUTDOWN_EXECUTIVE - Shutdown RTEMS::

This section details the Initialization Manager's directives.  A
subsection is dedicated to each of this manager's directives and
describes the calling sequence, related constants, usage, and status
codes.


File: ada_user.info,  Node: Initialization Manager INITIALIZE_DATA_STRUCTURES - Initialize RTEMS Data Structures,  Next: Initialization Manager INITIALIZE_BEFORE_DRIVERS - Perform Initialization Before Device Drivers,  Prev: Initialization Manager Directives,  Up: Initialization Manager Directives

4.4.1 INITIALIZE_DATA_STRUCTURES - Initialize RTEMS Data Structures
-------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive is called when the Board Support Package has completed
its basic initialization and allows RTEMS to initialize the application
environment based upon the information in the Configuration Table, User
Initialization Tasks Table, Device Driver Table, User Extension Table,
Multiprocessor Configuration Table, and the Multiprocessor
Communications Interface (MPCI) Table.  This directive returns to the
caller after completing the basic RTEMS initialization.

NOTES:
------

The Initialization Manager directives must be used in the proper
sequence and invokved only once in the life of an application.

This directive must be invoked with interrupts disabled.  Interrupts
should be disabled as early as possible in the initialization sequence
and remain disabled until the first context switch.


File: ada_user.info,  Node: Initialization Manager INITIALIZE_BEFORE_DRIVERS - Perform Initialization Before Device Drivers,  Next: Initialization Manager INITIALIZE_DEVICE_DRIVERS - Initialize Device Drivers,  Prev: Initialization Manager INITIALIZE_DATA_STRUCTURES - Initialize RTEMS Data Structures,  Up: Initialization Manager Directives

4.4.2 INITIALIZE_BEFORE_DRIVERS - Perform Initialization Before Device Drivers
------------------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive is called by the Board Support Package as the second
step in initializing RTEMS.  This directive performs initialization
that must occur between basis RTEMS data structure initialization and
device driver initialization.  In particular, in a multiprocessor
configuration, this directive will create the MPCI Server Task.  This
directive returns to the caller after completing the basic RTEMS
initialization.

NOTES:
------

The Initialization Manager directives must be used in the proper
sequence and invokved only once in the life of an application.

This directive must be invoked with interrupts disabled.  Interrupts
should be disabled as early as possible in the initialization sequence
and remain disabled until the first context switch.


File: ada_user.info,  Node: Initialization Manager INITIALIZE_DEVICE_DRIVERS - Initialize Device Drivers,  Next: Initialization Manager INITIALIZE_START_MULTITASKING - Complete Initialization and Start Multitasking,  Prev: Initialization Manager INITIALIZE_BEFORE_DRIVERS - Perform Initialization Before Device Drivers,  Up: Initialization Manager Directives

4.4.3 INITIALIZE_DEVICE_DRIVERS - Initialize Device Drivers
-----------------------------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive is called by the Board Support Package as the third step
in initializing RTEMS.  This directive initializes all statically
configured device drivers and performs all RTEMS initialization which
requires device drivers to be initialized.

In a multiprocessor configuration, this service will initialize the
Multiprocessor Communications Interface (MPCI) and synchronize with the
other nodes in the system.

After this directive is executed, control will be returned to the Board
Support Package framework.

NOTES:
------

The Initialization Manager directives must be used in the proper
sequence and invokved only once in the life of an application.

This directive must be invoked with interrupts disabled.  Interrupts
should be disabled as early as possible in the initialization sequence
and remain disabled until the first context switch.


File: ada_user.info,  Node: Initialization Manager INITIALIZE_START_MULTITASKING - Complete Initialization and Start Multitasking,  Next: Initialization Manager SHUTDOWN_EXECUTIVE - Shutdown RTEMS,  Prev: Initialization Manager INITIALIZE_DEVICE_DRIVERS - Initialize Device Drivers,  Up: Initialization Manager Directives

4.4.4 INITIALIZE_START_MULTITASKING - Complete Initialization and Start Multitasking
------------------------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive is called after the other Initialization Manager
directives have successfully completed.  This directive initiates
multitasking and performs a context switch to the first user
application task and enables interrupts as a side-effect of that
context switch.

NOTES:
------

This directive DOES NOT RETURN to the caller until the
`rtems.shutdown_executive' is invoked.

This directive causes all nodes in the system to verify that certain
configuration parameters are the same as those of the local node.  If
an inconsistency is detected, then a fatal error is generated.


File: ada_user.info,  Node: Initialization Manager SHUTDOWN_EXECUTIVE - Shutdown RTEMS,  Next: Task Manager,  Prev: Initialization Manager INITIALIZE_START_MULTITASKING - Complete Initialization and Start Multitasking,  Up: Initialization Manager Directives

4.4.5 SHUTDOWN_EXECUTIVE - Shutdown RTEMS
-----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Shutdown_Executive(
       Status : in     RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive is called when the application wishes to shutdown RTEMS
and return control to the board support package.  The board support
package resumes execution at the code immediately following the
invocation of the `rtems.initialize_executive' directive.

NOTES:
------

This directive MUST be the last RTEMS directive invoked by an
application and it DOES NOT RETURN to the caller.

This directive should not be invoked until the executive has
successfully completed initialization.


File: ada_user.info,  Node: Task Manager,  Next: Task Manager Introduction,  Prev: Initialization Manager SHUTDOWN_EXECUTIVE - Shutdown RTEMS,  Up: Top

5 Task Manager
**************

* Menu:

* Task Manager Introduction::
* Task Manager Background::
* Task Manager Operations::
* Task Manager Directives::


File: ada_user.info,  Node: Task Manager Introduction,  Next: Task Manager Background,  Prev: Task Manager,  Up: Task Manager

5.1 Introduction
================

The task manager provides a comprehensive set of directives to create,
delete, and administer tasks.  The directives provided by the task
manager are:

   * `rtems.task_create' - Create a task

   * `rtems.task_ident' - Get ID of a task

   * `rtems.task_self' - Obtain ID of caller

   * `rtems.task_start' - Start a task

   * `rtems.task_restart' - Restart a task

   * `rtems.task_delete' - Delete a task

   * `rtems.task_suspend' - Suspend a task

   * `rtems.task_resume' - Resume a task

   * `rtems.task_is_suspended' - Determine if a task is suspended

   * `rtems.task_set_priority' - Set task priority

   * `rtems.task_mode' - Change current task's mode

   * `rtems.task_get_note' - Get task notepad entry

   * `rtems.task_set_note' - Set task notepad entry

   * `rtems.task_wake_after' - Wake up after interval

   * `rtems.task_wake_when' - Wake up when specified

   * `rtems.iterate_over_all_threads' - Iterate Over Tasks

   * `rtems.task_variable_add' - Associate per task variable

   * `rtems.task_variable_get' - Obtain value of a a per task variable

   * `rtems.task_variable_delete' - Remove per task variable


File: ada_user.info,  Node: Task Manager Background,  Next: Task Manager Task Definition,  Prev: Task Manager Introduction,  Up: Task Manager

5.2 Background
==============

* Menu:

* Task Manager Task Definition::
* Task Manager Task Control Block::
* Task Manager Task States::
* Task Manager Task Priority::
* Task Manager Task Mode::
* Task Manager Accessing Task Arguments::
* Task Manager Floating Point Considerations::
* Task Manager Per Task Variables::
* Task Manager Building a Task Attribute Set::
* Task Manager Building a Mode and Mask::


File: ada_user.info,  Node: Task Manager Task Definition,  Next: Task Manager Task Control Block,  Prev: Task Manager Background,  Up: Task Manager Background

5.2.1 Task Definition
---------------------

Many definitions of a task have been proposed in computer literature.
Unfortunately, none of these definitions encompasses all facets of the
concept in a manner which is operating system independent.  Several of
the more common definitions are provided to enable each user to select a
definition which best matches their own experience and understanding of
the task concept:

   * a "dispatchable" unit.

   * an entity to which the processor is allocated.

   * an atomic unit of a real-time, multiprocessor system.

   * single threads of execution which concurrently compete for
     resources.

   * a sequence of closely related computations which can execute
     concurrently with other computational sequences.


From RTEMS' perspective, a task is the smallest thread of execution
which can compete on its own for system resources.  A task is
manifested by the existence of a task control block (TCB).


File: ada_user.info,  Node: Task Manager Task Control Block,  Next: Task Manager Task States,  Prev: Task Manager Task Definition,  Up: Task Manager Background

5.2.2 Task Control Block
------------------------

The Task Control Block (TCB) is an RTEMS defined data structure which
contains all the information that is pertinent to the execution of a
task.  During system initialization, RTEMS reserves a TCB for each task
configured.  A TCB is allocated upon creation of the task and is
returned to the TCB free list upon deletion of the task.

The TCB's elements are modified as a result of system calls made by the
application in response to external and internal stimuli.  TCBs are the
only RTEMS internal data structure that can be accessed by an
application via user extension routines.  The TCB contains a task's
name, ID, current priority, current and starting states, execution
mode, set of notepad locations, TCB user extension pointer, scheduling
control structures, as well as data required by a blocked task.

A task's context is stored in the TCB when a task switch occurs.  When
the task regains control of the processor, its context is restored from
the TCB.  When a task is restarted, the initial state of the task is
restored from the starting context area in the task's TCB.


File: ada_user.info,  Node: Task Manager Task States,  Next: Task Manager Task Priority,  Prev: Task Manager Task Control Block,  Up: Task Manager Background

5.2.3 Task States
-----------------

A task may exist in one of the following five states:

   * executing - Currently scheduled to the CPU

   * ready - May be scheduled to the CPU

   * blocked - Unable to be scheduled to the CPU

   * dormant - Created task that is not started

   * non-existent - Uncreated or deleted task

An active task may occupy the executing, ready, blocked or dormant
state, otherwise the task is considered non-existent.  One or more
tasks may be active in the system simultaneously.  Multiple tasks
communicate, synchronize, and compete for system resources with each
other via system calls.  The multiple tasks appear to execute in
parallel, but actually each is dispatched to the CPU for periods of
time determined by the RTEMS scheduling algorithm.  The scheduling of a
task is based on its current state and priority.


File: ada_user.info,  Node: Task Manager Task Priority,  Next: Task Manager Task Mode,  Prev: Task Manager Task States,  Up: Task Manager Background

5.2.4 Task Priority
-------------------

A task's priority determines its importance in relation to the other
tasks executing on the same processor.  RTEMS supports 255 levels of
priority ranging from 1 to 255.  The data type `rtems.task_priority' is
used to store task priorities.

Tasks of numerically smaller priority values are more important tasks
than tasks of numerically larger priority values.  For example, a task
at priority level 5 is of higher privilege than a task at priority
level 10.  There is no limit to the number of tasks assigned to the
same priority.

Each task has a priority associated with it at all times.  The initial
value of this priority is assigned at task creation time.  The priority
of a task may be changed at any subsequent time.

Priorities are used by the scheduler to determine which ready task will
be allowed to execute.  In general, the higher the logical priority of
a task, the more likely it is to receive processor execution time.


File: ada_user.info,  Node: Task Manager Task Mode,  Next: Task Manager Accessing Task Arguments,  Prev: Task Manager Task Priority,  Up: Task Manager Background

5.2.5 Task Mode
---------------

A task's execution mode is a combination of the following four
components:

   * preemption

   * ASR processing

   * timeslicing

   * interrupt level

It is used to modify RTEMS' scheduling process and to alter the
execution environment of the task.  The data type `rtems.task_mode' is
used to manage the task execution mode.

The preemption component allows a task to determine when control of the
processor is relinquished.  If preemption is disabled
(`RTEMS.NO_PREEMPT'), the task will retain control of the processor as
long as it is in the executing state - even if a higher priority task
is made ready.  If preemption is enabled (`RTEMS.PREEMPT')  and a
higher priority task is made ready, then the processor will be taken
away from the current task immediately and given to the higher priority
task.

The timeslicing component is used by the RTEMS scheduler to determine
how the processor is allocated to tasks of equal priority.  If
timeslicing is enabled (`RTEMS.TIMESLICE'), then RTEMS will limit the
amount of time the task can execute before the processor is allocated
to another ready task of equal priority. The length of the timeslice is
application dependent and specified in the Configuration Table.  If
timeslicing is disabled (`RTEMS.NO_TIMESLICE'), then the task will be
allowed to execute until a task of higher priority is made ready.  If
`RTEMS.NO_PREEMPT' is selected, then the timeslicing component is
ignored by the scheduler.

The asynchronous signal processing component is used to determine when
received signals are to be processed by the task.  If signal processing
is enabled (`RTEMS.ASR'), then signals sent to the task will be
processed the next time the task executes.  If signal processing is
disabled (`RTEMS.NO_ASR'), then all signals received by the task will
remain posted until signal processing is enabled.  This component
affects only tasks which have established a routine to process
asynchronous signals.

The interrupt level component is used to determine which interrupts
will be enabled when the task is executing.  `RTEMS.INTERRUPT_LEVEL(n)'
specifies that the task will execute at interrupt level n.

   * `RTEMS.PREEMPT' - enable preemption (default)

   * `RTEMS.NO_PREEMPT' - disable preemption

   * `RTEMS.NO_TIMESLICE' - disable timeslicing (default)

   * `RTEMS.TIMESLICE' - enable timeslicing

   * `RTEMS.ASR' - enable ASR processing (default)

   * `RTEMS.NO_ASR' - disable ASR processing

   * `RTEMS.INTERRUPT_LEVEL(0)' - enable all interrupts (default)

   * `RTEMS.INTERRUPT_LEVEL(n)' - execute at interrupt level n

The set of default modes may be selected by specifying the
`RTEMS.DEFAULT_MODES' constant.


File: ada_user.info,  Node: Task Manager Accessing Task Arguments,  Next: Task Manager Floating Point Considerations,  Prev: Task Manager Task Mode,  Up: Task Manager Background

5.2.6 Accessing Task Arguments
------------------------------

All RTEMS tasks are invoked with a single argument which is specified
when they are started or restarted.  The argument is commonly used to
communicate startup information to the task.  The simplest manner in
which to define a task which accesses it argument is:

     procedure User_Task (
       Argument : in    RTEMS.Task_Argument_Ptr
     );

Application tasks requiring more information may view this single
argument as an index into an array of parameter blocks.


File: ada_user.info,  Node: Task Manager Floating Point Considerations,  Next: Task Manager Per Task Variables,  Prev: Task Manager Accessing Task Arguments,  Up: Task Manager Background

5.2.7 Floating Point Considerations
-----------------------------------

Creating a task with the `RTEMS.FLOATING_POINT' attribute flag results
in additional memory being allocated for the TCB to store the state of
the numeric coprocessor during task switches.  This additional memory is
NOT allocated for `RTEMS.NO_FLOATING_POINT' tasks. Saving and restoring
the context of a `RTEMS.FLOATING_POINT' task takes longer than that of
a `RTEMS.NO_FLOATING_POINT' task because of the relatively large amount
of time required for the numeric coprocessor to save or restore its
computational state.

Since RTEMS was designed specifically for embedded military applications
which are floating point intensive, the executive is optimized to avoid
unnecessarily saving and restoring the state of the numeric coprocessor.
The state of the numeric coprocessor is only saved when a
`RTEMS.FLOATING_POINT' task is dispatched and that task was not the
last task to utilize the coprocessor.  In a system with only one
`RTEMS.FLOATING_POINT' task, the state of the numeric coprocessor will
never be saved or restored.

Although the overhead imposed by `RTEMS.FLOATING_POINT' tasks is
minimal, some applications may wish to completely avoid the overhead
associated with `RTEMS.FLOATING_POINT' tasks and still utilize a
numeric coprocessor.  By preventing a task from being preempted while
performing a sequence of floating point operations, a
`RTEMS.NO_FLOATING_POINT' task can utilize the numeric coprocessor
without incurring the overhead of a `RTEMS.FLOATING_POINT' context
switch.  This approach also avoids the allocation of a floating point
context area.  However, if this approach is taken by the application
designer, NO tasks should be created as `RTEMS.FLOATING_POINT' tasks.
Otherwise, the floating point context will not be correctly maintained
because RTEMS assumes that the state of the numeric coprocessor will
not be altered by `RTEMS.NO_FLOATING_POINT' tasks.

If the supported processor type does not have hardware floating
capabilities or a standard numeric coprocessor, RTEMS will not provide
built-in support for hardware floating point on that processor.  In this
case, all tasks are considered `RTEMS.NO_FLOATING_POINT' whether
created as `RTEMS.FLOATING_POINT' or `RTEMS.NO_FLOATING_POINT' tasks.
A floating point emulation software library must be utilized for
floating point operations.

On some processors, it is possible to disable the floating point unit
dynamically.  If this capability is supported by the target processor,
then RTEMS will utilize this capability to enable the floating point
unit only for tasks which are created with the `RTEMS.FLOATING_POINT'
attribute.  The consequence of a `RTEMS.NO_FLOATING_POINT' task
attempting to access the floating point unit is CPU dependent but will
generally result in an exception condition.


File: ada_user.info,  Node: Task Manager Per Task Variables,  Next: Task Manager Building a Task Attribute Set,  Prev: Task Manager Floating Point Considerations,  Up: Task Manager Background

5.2.8 Per Task Variables
------------------------

Per task variables are used to support global variables whose value may
be unique to a task. After indicating that a variable should be treated
as private (i.e. per-task) the task can access and modify the variable,
but the modifications will not appear to other tasks, and other tasks'
modifications to that variable will not affect the value seen by the
task.  This is accomplished by saving and restoring the variable's
value each time a task switch occurs to or from the calling task.

The value seen by other tasks, including those which have not added the
variable to their set and are thus accessing the variable as a common
location shared among tasks, can not be affected by a task once it has
added a variable to its local set.  Changes made to the variable by
other tasks will not affect the value seen by a task which has added the
variable to its private set.

This feature can be used when a routine is to be spawned repeatedly as
several independent tasks.  Although each task will have its own stack,
and thus separate stack variables, they will all share the same static
and global variables.  To make a variable not shareable (i.e. a
"global" variable that is specific to a single task), the tasks can call
`rtems_task_variable_add' to make a separate copy of the variable for
each task, but all at the same physical address.

Task variables increase the context switch time to and from the tasks
that own them so it is desirable to minimize the number of task
variables.  One efficient method is to have a single task variable that
is a pointer to a dynamically allocated structure containing the task's
private "global" data.

A critical point with per-task variables is that each task must
separately request that the same global variable is per-task private.


File: ada_user.info,  Node: Task Manager Building a Task Attribute Set,  Next: Task Manager Building a Mode and Mask,  Prev: Task Manager Per Task Variables,  Up: Task Manager Background

5.2.9 Building a Task Attribute Set
-----------------------------------

In general, an attribute set is built by a bitwise OR of the desired
components.  The set of valid task attribute components is listed below:

   * `RTEMS.NO_FLOATING_POINT' - does not use coprocessor (default)

   * `RTEMS.FLOATING_POINT' - uses numeric coprocessor

   * `RTEMS.LOCAL' - local task (default)

   * `RTEMS.GLOBAL' - global task

Attribute values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each attribute appears exactly once in the component list.  A component
listed as a default is not required to appear in the component list,
although it is a good programming practice to specify default
components.  If all defaults are desired, then
`RTEMS.DEFAULT_ATTRIBUTES' should be used.

This example demonstrates the attribute_set parameter needed to create
a local task which utilizes the numeric coprocessor.  The attribute_set
parameter could be `RTEMS.FLOATING_POINT' or `RTEMS.LOCAL or
RTEMS.FLOATING_POINT'.  The attribute_set parameter can be set to
`RTEMS.FLOATING_POINT' because `RTEMS.LOCAL' is the default for all
created tasks.  If the task were global and used the numeric
coprocessor, then the attribute_set parameter would be `RTEMS.GLOBAL or
RTEMS.FLOATING_POINT'.


File: ada_user.info,  Node: Task Manager Building a Mode and Mask,  Next: Task Manager Operations,  Prev: Task Manager Building a Task Attribute Set,  Up: Task Manager Background

5.2.10 Building a Mode and Mask
-------------------------------

In general, a mode and its corresponding mask is built by a bitwise OR
of the desired components.  The set of valid mode constants and each
mode's corresponding mask constant is listed below:

   * `RTEMS.PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and enables
     preemption

   * `RTEMS.NO_PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and disables
     preemption

   * `RTEMS.NO_TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and
     disables timeslicing

   * `RTEMS.TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and enables
     timeslicing

   * `RTEMS.ASR' is masked by `RTEMS.ASR_MASK' and enables ASR
     processing

   * `RTEMS.NO_ASR' is masked by `RTEMS.ASR_MASK' and disables ASR
     processing

   * `RTEMS.INTERRUPT_LEVEL(0)' is masked by `RTEMS.INTERRUPT_MASK' and
     enables all interrupts

   * `RTEMS.INTERRUPT_LEVEL(n)' is masked by `RTEMS.INTERRUPT_MASK' and
     sets interrupts level n

Mode values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each mode appears exactly once in the component list.  A mode component
listed as a default is not required to appear in the mode component
list, although it is a good programming practice to specify default
components.  If all defaults are desired, the mode
`RTEMS.DEFAULT_MODES' and the mask `RTEMS.ALL_MODE_MASKS' should be
used.

The following example demonstrates the mode and mask parameters used
with the `rtems.task_mode' directive to place a task at interrupt level
3 and make it non-preemptible.  The mode should be set to
`RTEMS.INTERRUPT_LEVEL(3)  or RTEMS.NO_PREEMPT' to indicate the desired
preemption mode and interrupt level, while the mask parameter should be
set to `RTEMS.INTERRUPT_MASK or RTEMS.NO_PREEMPT_MASK' to indicate that
the calling task's interrupt level and preemption mode are being
altered.


File: ada_user.info,  Node: Task Manager Operations,  Next: Task Manager Creating Tasks,  Prev: Task Manager Building a Mode and Mask,  Up: Task Manager

5.3 Operations
==============

* Menu:

* Task Manager Creating Tasks::
* Task Manager Obtaining Task IDs::
* Task Manager Starting and Restarting Tasks::
* Task Manager Suspending and Resuming Tasks::
* Task Manager Delaying the Currently Executing Task::
* Task Manager Changing Task Priority::
* Task Manager Changing Task Mode::
* Task Manager Notepad Locations::
* Task Manager Task Deletion::


File: ada_user.info,  Node: Task Manager Creating Tasks,  Next: Task Manager Obtaining Task IDs,  Prev: Task Manager Operations,  Up: Task Manager Operations

5.3.1 Creating Tasks
--------------------

The `rtems.task_create' directive creates a task by allocating a task
control block, assigning the task a user-specified name, allocating it
a stack and floating point context area, setting a user-specified
initial priority, setting a user-specified initial mode, and assigning
it a task ID.  Newly created tasks are initially placed in the dormant
state.  All RTEMS tasks execute in the most privileged mode of the
processor.


File: ada_user.info,  Node: Task Manager Obtaining Task IDs,  Next: Task Manager Starting and Restarting Tasks,  Prev: Task Manager Creating Tasks,  Up: Task Manager Operations

5.3.2 Obtaining Task IDs
------------------------

When a task is created, RTEMS generates a unique task ID and assigns it
to the created task until it is deleted.  The task ID may be obtained
by either of two methods.  First, as the result of an invocation of the
`rtems.task_create' directive, the task ID is stored in a user provided
location.  Second, the task ID may be obtained later using the
`rtems.task_ident' directive.  The task ID is used by other directives
to manipulate this task.


File: ada_user.info,  Node: Task Manager Starting and Restarting Tasks,  Next: Task Manager Suspending and Resuming Tasks,  Prev: Task Manager Obtaining Task IDs,  Up: Task Manager Operations

5.3.3 Starting and Restarting Tasks
-----------------------------------

The `rtems.task_start' directive is used to place a dormant task in the
ready state.  This enables the task to compete, based on its current
priority, for the processor and other system resources.  Any actions,
such as suspension or change of priority, performed on a task prior to
starting it are nullified when the task is started.

With the `rtems.task_start' directive the user specifies the task's
starting address and argument.  The argument is used to communicate
some startup information to the task.  As part of this directive, RTEMS
initializes the task's stack based upon the task's initial execution
mode and start address.  The starting argument is passed to the task in
accordance with the target processor's calling convention.

The `rtems.task_restart' directive restarts a task at its initial
starting address with its original priority and execution mode, but
with a possibly different argument.  The new argument may be used to
distinguish between the original invocation of the task and subsequent
invocations.  The task's stack and control block are modified to
reflect their original creation values.  Although references to
resources that have been requested are cleared, resources allocated by
the task are NOT automatically returned to RTEMS.  A task cannot be
restarted unless it has previously been started (i.e. dormant tasks
cannot be restarted).  All restarted tasks are placed in the ready
state.


File: ada_user.info,  Node: Task Manager Suspending and Resuming Tasks,  Next: Task Manager Delaying the Currently Executing Task,  Prev: Task Manager Starting and Restarting Tasks,  Up: Task Manager Operations

5.3.4 Suspending and Resuming Tasks
-----------------------------------

The `rtems.task_suspend' directive is used to place either the caller or
another task into a suspended state.  The task remains suspended until
a `rtems.task_resume' directive is issued.  This implies that a task
may be suspended as well as blocked waiting either to acquire a
resource or for the expiration of a timer.

The `rtems.task_resume' directive is used to remove another task from
the suspended state. If the task is not also blocked, resuming it will
place it in the ready state, allowing it to once again compete for the
processor and resources.  If the task was blocked as well as suspended,
this directive clears the suspension and leaves the task in the blocked
state.

Suspending a task which is already suspended or resuming a task which
is not suspended is considered an error.  The `rtems.task_is_suspended'
can be used to determine if a task is currently suspended.


File: ada_user.info,  Node: Task Manager Delaying the Currently Executing Task,  Next: Task Manager Changing Task Priority,  Prev: Task Manager Suspending and Resuming Tasks,  Up: Task Manager Operations

5.3.5 Delaying the Currently Executing Task
-------------------------------------------

The `rtems.task_wake_after' directive creates a sleep timer which
allows a task to go to sleep for a specified interval.  The task is
blocked until the delay interval has elapsed, at which time the task is
unblocked.  A task calling the `rtems.task_wake_after' directive with a
delay interval of `RTEMS.YIELD_PROCESSOR' ticks will yield the
processor to any other ready task of equal or greater priority and
remain ready to execute.

The `rtems.task_wake_when' directive creates a sleep timer which allows
a task to go to sleep until a specified date and time.  The calling
task is blocked until the specified date and time has occurred, at
which time the task is unblocked.


File: ada_user.info,  Node: Task Manager Changing Task Priority,  Next: Task Manager Changing Task Mode,  Prev: Task Manager Delaying the Currently Executing Task,  Up: Task Manager Operations

5.3.6 Changing Task Priority
----------------------------

The `rtems.task_set_priority' directive is used to obtain or change the
current priority of either the calling task or another task.  If the
new priority requested is `RTEMS.CURRENT_PRIORITY' or the task's actual
priority, then the current priority will be returned and the task's
priority will remain unchanged.  If the task's priority is altered,
then the task will be scheduled according to its new priority.

The `rtems.task_restart' directive resets the priority of a task to its
original value.


File: ada_user.info,  Node: Task Manager Changing Task Mode,  Next: Task Manager Notepad Locations,  Prev: Task Manager Changing Task Priority,  Up: Task Manager Operations

5.3.7 Changing Task Mode
------------------------

The `rtems.task_mode' directive is used to obtain or change the current
execution mode of the calling task.  A task's execution mode is used to
enable preemption, timeslicing, ASR processing, and to set the task's
interrupt level.

The `rtems.task_restart' directive resets the mode of a task to its
original value.


File: ada_user.info,  Node: Task Manager Notepad Locations,  Next: Task Manager Task Deletion,  Prev: Task Manager Changing Task Mode,  Up: Task Manager Operations

5.3.8 Notepad Locations
-----------------------

RTEMS provides sixteen notepad locations for each task.  Each notepad
location may contain a note consisting of four bytes of information.
RTEMS provides two directives, `rtems.task_set_note' and
`rtems.task_get_note', that enable a user to access and change the
notepad locations.  The `rtems.task_set_note' directive enables the user
to set a task's notepad entry to a specified note.  The
`rtems.task_get_note' directive allows the user to obtain the note
contained in any one of the sixteen notepads of a specified task.


File: ada_user.info,  Node: Task Manager Task Deletion,  Next: Task Manager Directives,  Prev: Task Manager Notepad Locations,  Up: Task Manager Operations

5.3.9 Task Deletion
-------------------

RTEMS provides the `rtems.task_delete' directive to allow a task to
delete itself or any other task.  This directive removes all RTEMS
references to the task, frees the task's control block, removes it from
resource wait queues, and deallocates its stack as well as the optional
floating point context.  The task's name and ID become inactive at this
time, and any subsequent references to either of them is invalid.  In
fact, RTEMS may reuse the task ID for another task which is created
later in the application.

Unexpired delay timers (i.e. those used by `rtems.task_wake_after' and
`rtems.task_wake_when') and timeout timers associated with the task are
automatically deleted, however, other resources dynamically allocated
by the task are NOT automatically returned to RTEMS.  Therefore, before
a task is deleted, all of its dynamically allocated resources should be
deallocated by the user.  This may be accomplished by instructing the
task to delete itself rather than directly deleting the task.  Other
tasks may instruct a task to delete itself by sending a "delete self"
message, event, or signal, or by restarting the task with special
arguments which instruct the task to delete itself.


File: ada_user.info,  Node: Task Manager Directives,  Next: Task Manager TASK_CREATE - Create a task,  Prev: Task Manager Task Deletion,  Up: Task Manager

5.4 Directives
==============

* Menu:

* Task Manager TASK_CREATE - Create a task::
* Task Manager TASK_IDENT - Get ID of a task::
* Task Manager TASK_SELF - Obtain ID of caller::
* Task Manager TASK_START - Start a task::
* Task Manager TASK_RESTART - Restart a task::
* Task Manager TASK_DELETE - Delete a task::
* Task Manager TASK_SUSPEND - Suspend a task::
* Task Manager TASK_RESUME - Resume a task::
* Task Manager TASK_IS_SUSPENDED - Determine if a task is Suspended::
* Task Manager TASK_SET_PRIORITY - Set task priority::
* Task Manager TASK_MODE - Change the current task mode::
* Task Manager TASK_GET_NOTE - Get task notepad entry::
* Task Manager TASK_SET_NOTE - Set task notepad entry::
* Task Manager TASK_WAKE_AFTER - Wake up after interval::
* Task Manager TASK_WAKE_WHEN - Wake up when specified::
* Task Manager ITERATE_OVER_ALL_THREADS - Iterate Over Tasks::
* Task Manager TASK_VARIABLE_ADD - Associate per task variable::
* Task Manager TASK_VARIABLE_GET - Obtain value of a per task variable::
* Task Manager TASK_VARIABLE_DELETE - Remove per task variable::

This section details the task manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Task Manager TASK_CREATE - Create a task,  Next: Task Manager TASK_IDENT - Get ID of a task,  Prev: Task Manager Directives,  Up: Task Manager Directives

5.4.1 TASK_CREATE - Create a task
---------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Create (
        Name             : in     RTEMS.Name;
        Initial_Priority : in     RTEMS.Task_Priority;
        Stack_Size       : in     RTEMS.Unsigned32;
        Initial_Modes    : in     RTEMS.Mode;
        Attribute_Set    : in     RTEMS.Attribute;
        ID               :    out RTEMS.ID;
        Result           :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task created successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - invalid task name
`RTEMS.INVALID_PRIORITY' - invalid task priority
`RTEMS.MP_NOT_CONFIGURED' - multiprocessing not configured
`RTEMS.TOO_MANY' - too many tasks created
`RTEMS.UNSATISFIED' - not enough memory for stack/FP context
`RTEMS.TOO_MANY' - too many global objects

DESCRIPTION:
------------

This directive creates a task which resides on the local node.  It
allocates and initializes a TCB, a stack, and an optional floating
point context area.  The mode parameter contains values which sets the
task's initial execution mode.  The `RTEMS.FLOATING_POINT' attribute
should be specified if the created task is to use a numeric
coprocessor.  For performance reasons, it is recommended that tasks not
using the numeric coprocessor should specify the
`RTEMS.NO_FLOATING_POINT' attribute.  If the `RTEMS.GLOBAL' attribute
is specified, the task can be accessed from remote nodes.  The task id,
returned in id, is used in other task related directives to access the
task.  When created, a task is placed in the dormant state and can only
be made ready to execute using the directive `rtems.task_start'.

NOTES:
------

This directive will not cause the calling task to be preempted.

Valid task priorities range from a high of 1 to a low of 255.

If the requested stack size is less than the configured minimum stack
size, then RTEMS will use the configured minimum as the stack size for
this task.  In addition to being able to specify the task stack size as
a integer, there are two constants which may be specified:

   * `RTEMS.MINIMUM_STACK_SIZE' is the minimum stack size RECOMMENDED
     for use on this processor.  This value is selected by the RTEMS
     developers conservatively to minimize the risk of blown stacks for
     most user applications.  Using this constant when specifying the
     task stack size, indicates that the stack size will be at least
     `RTEMS.MINIMUM_STACK_SIZE' bytes in size.  If the user configured
     minimum stack size is larger than the recommended minimum, then it
     will be used.

   * `RTEMS.CONFIGURED_MINIMUM_STACK_SIZE' indicates that this task is
     to be created with a stack size of the minimum stack size that was
     configured by the application.  If not explicitly configured by
     the application, the default configured minimum stack size is the
     processor dependent value `RTEMS.MINIMUM_STACK_SIZE'.  Since this
     uses the configured minimum stack size value, you may get a stack
     size that is smaller or larger than the recommended minimum.  This
     can be used to provide large stacks for all tasks on complex
     applications or small stacks on applications that are trying to
     conserve memory.


Application developers should consider the stack usage of the device
drivers when calculating the stack size required for tasks which
utilize the driver.

The following task attribute constants are defined by RTEMS:

   * `RTEMS.NO_FLOATING_POINT' - does not use coprocessor (default)

   * `RTEMS.FLOATING_POINT' - uses numeric coprocessor

   * `RTEMS.LOCAL' - local task (default)

   * `RTEMS.GLOBAL' - global task

The following task mode constants are defined by RTEMS:

   * `RTEMS.PREEMPT' - enable preemption (default)

   * `RTEMS.NO_PREEMPT' - disable preemption

   * `RTEMS.NO_TIMESLICE' - disable timeslicing (default)

   * `RTEMS.TIMESLICE' - enable timeslicing

   * `RTEMS.ASR' - enable ASR processing (default)

   * `RTEMS.NO_ASR' - disable ASR processing

   * `RTEMS.INTERRUPT_LEVEL(0)' - enable all interrupts (default)

   * `RTEMS.INTERRUPT_LEVEL(n)' - execute at interrupt level n

The interrupt level portion of the task execution mode supports a
maximum of 256 interrupt levels.  These levels are mapped onto the
interrupt levels actually supported by the target processor in a
processor dependent fashion.

Tasks should not be made global unless remote tasks must interact with
them.  This avoids the system overhead incurred by the creation of a
global task.  When a global task is created, the task's name and id
must be transmitted to every node in the system for insertion in the
local copy of the global object table.

The total number of global objects, including tasks, is limited by the
maximum_global_objects field in the Configuration Table.


File: ada_user.info,  Node: Task Manager TASK_IDENT - Get ID of a task,  Next: Task Manager TASK_SELF - Obtain ID of caller,  Prev: Task Manager TASK_CREATE - Create a task,  Up: Task Manager Directives

5.4.2 TASK_IDENT - Get ID of a task
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Ident (
        Name   : in     RTEMS.Name;
        Node   : in     RTEMS.Node;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task identified successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - invalid task name
`RTEMS.INVALID_NODE' - invalid node id

DESCRIPTION:
------------

This directive obtains the task id associated with the task name
specified in name.  A task may obtain its own id by specifying
`RTEMS.SELF' or its own task name in name.  If the task name is not
unique, then the task id returned will match one of the tasks with that
name.  However, this task id is not guaranteed to correspond to the
desired task.  The task id, returned in id, is used in other task
related directives to access the task.

NOTES:
------

This directive will not cause the running task to be preempted.

If node is `RTEMS.SEARCH_ALL_NODES', all nodes are searched with the
local node being searched first.  All other nodes are searched with the
lowest numbered node searched first.

If node is a valid node number which does not represent the local node,
then only the tasks exported by the designated node are searched.

This directive does not generate activity on remote nodes.  It accesses
only the local copy of the global object table.


File: ada_user.info,  Node: Task Manager TASK_SELF - Obtain ID of caller,  Next: Task Manager TASK_START - Start a task,  Prev: Task Manager TASK_IDENT - Get ID of a task,  Up: Task Manager Directives

5.4.3 TASK_SELF - Obtain ID of caller
-------------------------------------

CALLING SEQUENCE:
-----------------

     function Task_Self return RTEMS.ID;

DIRECTIVE STATUS CODES:
-----------------------

Returns the object Id of the calling task.

DESCRIPTION:
------------

This directive returns the Id of the calling task.

NOTES:
------

If called from an interrupt service routine, this directive will return
the Id of the interrupted task.


File: ada_user.info,  Node: Task Manager TASK_START - Start a task,  Next: Task Manager TASK_RESTART - Restart a task,  Prev: Task Manager TASK_SELF - Obtain ID of caller,  Up: Task Manager Directives

5.4.4 TASK_START - Start a task
-------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Start (
        ID          : in     RTEMS.ID;
        Entry_Point : in     RTEMS.Task_Entry;
        Argument    : in     RTEMS.Task_Argument;
        Result      :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - ask started successfully
`RTEMS.INVALID_ADDRESS' - invalid task entry point
`RTEMS.INVALID_ID' - invalid task id
`RTEMS.INCORRECT_STATE' - task not in the dormant state
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - cannot start remote task

DESCRIPTION:
------------

This directive readies the task, specified by `id', for execution based
on the priority and execution mode specified when the task was created.
The starting address of the task is given in `entry_point'.  The task's
starting argument is contained in argument.  This argument can be a
single value or used as an index into an array of parameter blocks.
The type of this numeric argument is an unsigned integer type with the
property that any valid pointer to void can be converted to this type
and then converted back to a pointer to void.  The result will compare
equal to the original pointer.

NOTES:
------

The calling task will be preempted if its preemption mode is enabled
and the task being started has a higher priority.

Any actions performed on a dormant task such as suspension or change of
priority are nullified when the task is initiated via the
`rtems.task_start' directive.


File: ada_user.info,  Node: Task Manager TASK_RESTART - Restart a task,  Next: Task Manager TASK_DELETE - Delete a task,  Prev: Task Manager TASK_START - Start a task,  Up: Task Manager Directives

5.4.5 TASK_RESTART - Restart a task
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Restart (
        ID       : in     RTEMS.ID;
        Argument : in     RTEMS.Task_Argument;
        Result   :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task restarted successfully
`RTEMS.INVALID_ID' - task id invalid
`RTEMS.INCORRECT_STATE' - task never started
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - cannot restart remote task

DESCRIPTION:
------------

This directive resets the task specified by id to begin execution at
its original starting address.  The task's priority and execution mode
are set to the original creation values.  If the task is currently
blocked, RTEMS automatically makes the task ready.  A task can be
restarted from any state, except the dormant state.

The task's starting argument is contained in argument.  This argument
can be a single value or an index into an array of parameter blocks.
The type of this numeric argument is an unsigned integer type with the
property that any valid pointer to void can be converted to this type
and then converted back to a pointer to void.  The result will compare
equal to the original pointer.  This new argument may be used to
distinguish between the initial `rtems.task_start' of the task and any
ensuing calls to `rtems.task_restart' of the task.  This can be
beneficial in deleting a task.  Instead of deleting a task using the
`rtems.task_delete' directive, a task can delete another task by
restarting that task, and allowing that task to release resources back
to RTEMS and then delete itself.

NOTES:
------

If id is `RTEMS.SELF', the calling task will be restarted and will not
return from this directive.

The calling task will be preempted if its preemption mode is enabled
and the task being restarted has a higher priority.

The task must reside on the local node, even if the task was created
with the `RTEMS.GLOBAL' option.


File: ada_user.info,  Node: Task Manager TASK_DELETE - Delete a task,  Next: Task Manager TASK_SUSPEND - Suspend a task,  Prev: Task Manager TASK_RESTART - Restart a task,  Up: Task Manager Directives

5.4.6 TASK_DELETE - Delete a task
---------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task restarted successfully
`RTEMS.INVALID_ID' - task id invalid
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - cannot restart remote task

DESCRIPTION:
------------

This directive deletes a task, either the calling task or another task,
as specified by id.  RTEMS stops the execution of the task and reclaims
the stack memory, any allocated delay or timeout timers, the TCB, and,
if the task is `RTEMS.FLOATING_POINT', its floating point context area.
RTEMS does not reclaim the following resources: region segments,
partition buffers, semaphores, timers, or rate monotonic periods.

NOTES:
------

A task is responsible for releasing its resources back to RTEMS before
deletion.  To insure proper deallocation of resources, a task should
not be deleted unless it is unable to execute or does not hold any
RTEMS resources.  If a task holds RTEMS resources, the task should be
allowed to deallocate its resources before deletion.  A task can be
directed to release its resources and delete itself by restarting it
with a special argument or by sending it a message, an event, or a
signal.

Deletion of the current task (`RTEMS.SELF') will force RTEMS to select
another task to execute.

When a global task is deleted, the task id must be transmitted to every
node in the system for deletion from the local copy of the global
object table.

The task must reside on the local node, even if the task was created
with the `RTEMS.GLOBAL' option.


File: ada_user.info,  Node: Task Manager TASK_SUSPEND - Suspend a task,  Next: Task Manager TASK_RESUME - Resume a task,  Prev: Task Manager TASK_DELETE - Delete a task,  Up: Task Manager Directives

5.4.7 TASK_SUSPEND - Suspend a task
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Suspend (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task restarted successfully
`RTEMS.INVALID_ID' - task id invalid
`RTEMS.ALREADY_SUSPENDED' - task already suspended

DESCRIPTION:
------------

This directive suspends the task specified by id from further execution
by placing it in the suspended state.  This state is additive to any
other blocked state that the task may already be in.  The task will not
execute again until another task issues the `rtems.task_resume'
directive for this task and any blocked state has been removed.

NOTES:
------

The requesting task can suspend itself by specifying `RTEMS.SELF' as id.
In this case, the task will be suspended and a successful return code
will be returned when the task is resumed.

Suspending a global task which does not reside on the local node will
generate a request to the remote node to suspend the specified task.

If the task specified by id is already suspended, then the
`RTEMS.ALREADY_SUSPENDED' status code is returned.


File: ada_user.info,  Node: Task Manager TASK_RESUME - Resume a task,  Next: Task Manager TASK_IS_SUSPENDED - Determine if a task is Suspended,  Prev: Task Manager TASK_SUSPEND - Suspend a task,  Up: Task Manager Directives

5.4.8 TASK_RESUME - Resume a task
---------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Resume (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task restarted successfully
`RTEMS.INVALID_ID' - task id invalid
`RTEMS.INCORRECT_STATE' - task not suspended

DESCRIPTION:
------------

This directive removes the task specified by id from the suspended
state.  If the task is in the ready state after the suspension is
removed, then it will be scheduled to run.  If the task is still in a
blocked state after the suspension is removed, then it will remain in
that blocked state.

NOTES:
------

The running task may be preempted if its preemption mode is enabled and
the local task being resumed has a higher priority.

Resuming a global task which does not reside on the local node will
generate a request to the remote node to resume the specified task.

If the task specified by id is not suspended, then the
`RTEMS.INCORRECT_STATE' status code is returned.


File: ada_user.info,  Node: Task Manager TASK_IS_SUSPENDED - Determine if a task is Suspended,  Next: Task Manager TASK_SET_PRIORITY - Set task priority,  Prev: Task Manager TASK_RESUME - Resume a task,  Up: Task Manager Directives

5.4.9 TASK_IS_SUSPENDED - Determine if a task is Suspended
----------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Is_Suspended (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task is NOT suspended
`RTEMS.ALREADY_SUSPENDED' - task is currently suspended
`RTEMS.INVALID_ID' - task id invalid
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - not supported on remote tasks

DESCRIPTION:
------------

This directive returns a status code indicating whether or not the
specified task is currently suspended.

NOTES:
------

This operation is not currently supported on remote tasks.


File: ada_user.info,  Node: Task Manager TASK_SET_PRIORITY - Set task priority,  Next: Task Manager TASK_MODE - Change the current task mode,  Prev: Task Manager TASK_IS_SUSPENDED - Determine if a task is Suspended,  Up: Task Manager Directives

5.4.10 TASK_SET_PRIORITY - Set task priority
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Set_Priority (
        ID           : in     RTEMS.ID;
        New_Priority : in     RTEMS.Task_Priority;
        Old_Priority :    out RTEMS.Task_Priority;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task priority set successfully
`RTEMS.INVALID_ID' - invalid task id
`RTEMS.INVALID_ADDRESS' - invalid return argument pointer
`RTEMS.INVALID_PRIORITY' - invalid task priority

DESCRIPTION:
------------

This directive manipulates the priority of the task specified by id.
An id of `RTEMS.SELF' is used to indicate the calling task.  When
new_priority is not equal to `RTEMS.CURRENT_PRIORITY', the specified
task's previous priority is returned in old_priority.  When
new_priority is `RTEMS.CURRENT_PRIORITY', the specified task's current
priority is returned in old_priority.  Valid priorities range from a
high of 1 to a low of 255.

NOTES:
------

The calling task may be preempted if its preemption mode is enabled and
it lowers its own priority or raises another task's priority.

Setting the priority of a global task which does not reside on the
local node will generate a request to the remote node to change the
priority of the specified task.

If the task specified by id is currently holding any binary semaphores
which use the priority inheritance algorithm, then the task's priority
cannot be lowered immediately.  If the task's priority were lowered
immediately, then priority inversion results.  The requested lowering
of the task's priority will occur when the task has released all
priority inheritance binary semaphores.  The task's priority can be
increased regardless of the task's use of priority inheritance binary
semaphores.


File: ada_user.info,  Node: Task Manager TASK_MODE - Change the current task mode,  Next: Task Manager TASK_GET_NOTE - Get task notepad entry,  Prev: Task Manager TASK_SET_PRIORITY - Set task priority,  Up: Task Manager Directives

5.4.11 TASK_MODE - Change the current task mode
-----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Mode (
        Mode_Set          : in     RTEMS.Mode;
        Mask              : in     RTEMS.Mode;
        Previous_Mode_Set : in     RTEMS.Mode;
        Result            :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task mode set successfully
`RTEMS.INVALID_ADDRESS' - `previous_mode_set' is NULL

DESCRIPTION:
------------

This directive manipulates the execution mode of the calling task.  A
task's execution mode enables and disables preemption, timeslicing,
asynchronous signal processing, as well as specifying the current
interrupt level.  To modify an execution mode, the mode class(es) to be
changed must be specified in the mask parameter and the desired mode(s)
must be specified in the mode parameter.

NOTES:
------

The calling task will be preempted if it enables preemption and a
higher priority task is ready to run.

Enabling timeslicing has no effect if preemption is disabled.  For a
task to be timesliced, that task must have both preemption and
timeslicing enabled.

A task can obtain its current execution mode, without modifying it, by
calling this directive with a mask value of `RTEMS.CURRENT_MODE'.

To temporarily disable the processing of a valid ASR, a task should
call this directive with the `RTEMS.NO_ASR' indicator specified in mode.

The set of task mode constants and each mode's corresponding mask
constant is provided in the following table:

   * `RTEMS.PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and enables
     preemption

   * `RTEMS.NO_PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and disables
     preemption

   * `RTEMS.NO_TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and
     disables timeslicing

   * `RTEMS.TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and enables
     timeslicing

   * `RTEMS.ASR' is masked by `RTEMS.ASR_MASK' and enables ASR
     processing

   * `RTEMS.NO_ASR' is masked by `RTEMS.ASR_MASK' and disables ASR
     processing

   * `RTEMS.INTERRUPT_LEVEL(0)' is masked by `RTEMS.INTERRUPT_MASK' and
     enables all interrupts

   * `RTEMS.INTERRUPT_LEVEL(n)' is masked by `RTEMS.INTERRUPT_MASK' and
     sets interrupts level n



File: ada_user.info,  Node: Task Manager TASK_GET_NOTE - Get task notepad entry,  Next: Task Manager TASK_SET_NOTE - Set task notepad entry,  Prev: Task Manager TASK_MODE - Change the current task mode,  Up: Task Manager Directives

5.4.12 TASK_GET_NOTE - Get task notepad entry
---------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Get_Note (
        ID      : in     RTEMS.ID;
        Notepad : in     RTEMS.Notepad_Index;
        Note    :    out RTEMS.Unsigned32;
        Result  :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - note obtained successfully
`RTEMS.INVALID_ADDRESS' - `note' is NULL
`RTEMS.INVALID_ID' - invalid task id
`RTEMS.INVALID_NUMBER' - invalid notepad location

DESCRIPTION:
------------

This directive returns the note contained in the notepad location of
the task specified by id.

NOTES:
------

This directive will not cause the running task to be preempted.

If id is set to `RTEMS.SELF', the calling task accesses its own notepad.

The sixteen notepad locations can be accessed using the constants
`RTEMS.NOTEPAD_0' through `RTEMS.NOTEPAD_15'.

Getting a note of a global task which does not reside on the local node
will generate a request to the remote node to obtain the notepad entry
of the specified task.


File: ada_user.info,  Node: Task Manager TASK_SET_NOTE - Set task notepad entry,  Next: Task Manager TASK_WAKE_AFTER - Wake up after interval,  Prev: Task Manager TASK_GET_NOTE - Get task notepad entry,  Up: Task Manager Directives

5.4.13 TASK_SET_NOTE - Set task notepad entry
---------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Set_Note (
        ID      : in     RTEMS.ID;
        Notepad : in     RTEMS.Notepad_Index;
        Note    : in     RTEMS.Unsigned32;
        Result  :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - task's note set successfully
`RTEMS.INVALID_ID' - invalid task id
`RTEMS.INVALID_NUMBER' - invalid notepad location

DESCRIPTION:
------------

This directive sets the notepad entry for the task specified by id to
the value note.

NOTES:
------

If id is set to `RTEMS.SELF', the calling task accesses its own notepad
locations.

This directive will not cause the running task to be preempted.

The sixteen notepad locations can be accessed using the constants
`RTEMS.NOTEPAD_0' through `RTEMS.NOTEPAD_15'.

Setting a notepad location of a global task which does not reside on
the local node will generate a request to the remote node to set the
specified notepad entry.


File: ada_user.info,  Node: Task Manager TASK_WAKE_AFTER - Wake up after interval,  Next: Task Manager TASK_WAKE_WHEN - Wake up when specified,  Prev: Task Manager TASK_SET_NOTE - Set task notepad entry,  Up: Task Manager Directives

5.4.14 TASK_WAKE_AFTER - Wake up after interval
-----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Wake_After (
        Ticks  : in     RTEMS.Interval;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - always successful

DESCRIPTION:
------------

This directive blocks the calling task for the specified number of
system clock ticks.  When the requested interval has elapsed, the task
is made ready.  The `rtems.clock_tick' directive automatically updates
the delay period.

NOTES:
------

Setting the system date and time with the `rtems.clock_set' directive
has no effect on a `rtems.task_wake_after' blocked task.

A task may give up the processor and remain in the ready state by
specifying a value of `RTEMS.YIELD_PROCESSOR' in ticks.

The maximum timer interval that can be specified is the maximum value
which can be represented by the uint32_t type.

A clock tick is required to support the functionality of this directive.


File: ada_user.info,  Node: Task Manager TASK_WAKE_WHEN - Wake up when specified,  Next: Task Manager ITERATE_OVER_ALL_THREADS - Iterate Over Tasks,  Prev: Task Manager TASK_WAKE_AFTER - Wake up after interval,  Up: Task Manager Directives

5.4.15 TASK_WAKE_WHEN - Wake up when specified
----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Wake_When (
        Time_Buffer : in     RTEMS.Time_Of_Day;
        Result      :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - awakened at date/time successfully
`RTEMS.INVALID_ADDRESS' - `time_buffer' is NULL
`RTEMS.INVALID_TIME_OF_DAY' - invalid time buffer
`RTEMS.NOT_DEFINED' - system date and time is not set

DESCRIPTION:
------------

This directive blocks a task until the date and time specified in
time_buffer.  At the requested date and time, the calling task will be
unblocked and made ready to execute.

NOTES:
------

The ticks portion of time_buffer record is ignored.  The timing
granularity of this directive is a second.

A clock tick is required to support the functionality of this directive.


File: ada_user.info,  Node: Task Manager ITERATE_OVER_ALL_THREADS - Iterate Over Tasks,  Next: Task Manager TASK_VARIABLE_ADD - Associate per task variable,  Prev: Task Manager TASK_WAKE_WHEN - Wake up when specified,  Up: Task Manager Directives

5.4.16 ITERATE_OVER_ALL_THREADS - Iterate Over Tasks
----------------------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES: NONE
----------------------------

DESCRIPTION:
------------

This directive iterates over all of the existant threads in the system
and invokes `routine' on each of them.  The user should be careful in
accessing the contents of `the_thread'.

This routine is intended for use in diagnostic utilities and is not
intented for routine use in an operational system.

NOTES:
------

There is NO protection while this routine is called.  Thus it is
possible that `the_thread' could be deleted while this is operating.
By not having protection, the user is free to invoke support routines
from the C Library which require semaphores for data structures.


File: ada_user.info,  Node: Task Manager TASK_VARIABLE_ADD - Associate per task variable,  Next: Task Manager TASK_VARIABLE_GET - Obtain value of a per task variable,  Prev: Task Manager ITERATE_OVER_ALL_THREADS - Iterate Over Tasks,  Up: Task Manager Directives

5.4.17 TASK_VARIABLE_ADD - Associate per task variable
------------------------------------------------------

CALLING SEQUENCE:
-----------------

     type Task_Variable_Dtor is access procedure (
        Argument : in     RTEMS.Address;
     );

     procedure Task_Variable_Add (
        ID            : in     RTEMS.ID;
        Task_Variable : in     RTEMS.Address;
        Dtor          : in     RTEMS.Task_Variable_Dtor;
        Result        :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - per task variable added successfully
`RTEMS.INVALID_ADDRESS' - `task_variable' is NULL
`RTEMS.INVALID_ID' - invalid task id
`RTEMS.NO_MEMORY' - invalid task id
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - not supported on remote tasks
DESCRIPTION:
------------

This directive adds the memory location specified by the ptr argument
to the context of the given task.  The variable will then be private to
the task.  The task can access and modify the variable, but the
modifications will not appear to other tasks, and other tasks'
modifications to that variable will not affect the value seen by the
task.  This is accomplished by saving and restoring the variable's
value each time a task switch occurs to or from the calling task.  If
the dtor argument is non-NULL it specifies the address of a `destructor'
function which will be called when the task is deleted.  The argument
passed to the destructor function is the task's value of the variable.

NOTES:
------

Task variables increase the context switch time to and from the tasks
that own them so it is desirable to minimize the number of task
variables.  One efficient method is to have a single task variable that
is a pointer to a dynamically allocated structure containing the task's
private `global' data.  In this case the destructor function could be
`free'.


File: ada_user.info,  Node: Task Manager TASK_VARIABLE_GET - Obtain value of a per task variable,  Next: Task Manager TASK_VARIABLE_DELETE - Remove per task variable,  Prev: Task Manager TASK_VARIABLE_ADD - Associate per task variable,  Up: Task Manager Directives

5.4.18 TASK_VARIABLE_GET - Obtain value of a per task variable
--------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Variable_Get (
        ID                  : in     RTEMS.ID;
        Task_Variable       :    out RTEMS.Address;
        Task_Variable_Value :    out RTEMS.Address;
        Result              :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - per task variable added successfully
`RTEMS.INVALID_ADDRESS' - `task_variable' is NULL
`RTEMS.INVALID_ADDRESS' - `task_variable_value' is NULL
`RTEMS.INVALID_ADDRESS' - `task_variable' is not found
`RTEMS.NO_MEMORY' - invalid task id
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - not supported on remote tasks
DESCRIPTION:
------------

This directive looks up the private value of a task variable for a
specified task and stores that value in the location pointed to by the
result argument.  The specified task is usually not the calling task,
which can get its private value by directly accessing the variable.

NOTES:
------

If you change memory which `task_variable_value' points to, remember to
declare that memory as volatile, so that the compiler will optimize it
correctly.  In this case both the pointer `task_variable_value' and
data referenced by `task_variable_value' should be considered volatile.


File: ada_user.info,  Node: Task Manager TASK_VARIABLE_DELETE - Remove per task variable,  Next: Interrupt Manager,  Prev: Task Manager TASK_VARIABLE_GET - Obtain value of a per task variable,  Up: Task Manager Directives

5.4.19 TASK_VARIABLE_DELETE - Remove per task variable
------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Task_Variable_Delete (
        ID                  : in     RTEMS.ID;
        Task_Variable       :    out RTEMS.Address;
        Result              :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - per task variable added successfully
`RTEMS.INVALID_ID' - invalid task id
`RTEMS.NO_MEMORY' - invalid task id
`RTEMS.INVALID_ADDRESS' - `task_variable' is NULL
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - not supported on remote tasks
DESCRIPTION:
------------

This directive removes the given location from a task's context.

NOTES:
------

NONE


File: ada_user.info,  Node: Interrupt Manager,  Next: Interrupt Manager Introduction,  Prev: Task Manager TASK_VARIABLE_DELETE - Remove per task variable,  Up: Top

6 Interrupt Manager
*******************

* Menu:

* Interrupt Manager Introduction::
* Interrupt Manager Background::
* Interrupt Manager Operations::
* Interrupt Manager Directives::


File: ada_user.info,  Node: Interrupt Manager Introduction,  Next: Interrupt Manager Background,  Prev: Interrupt Manager,  Up: Interrupt Manager

6.1 Introduction
================

Any real-time executive must provide a mechanism for quick response to
externally generated interrupts to satisfy the critical time
constraints of the application.  The interrupt manager provides this
mechanism for RTEMS.  This manager permits quick interrupt response
times by providing the critical ability to alter task execution which
allows a task to be preempted upon exit from an ISR.  The interrupt
manager includes the following directive:

   * `rtems.interrupt_catch' - Establish an ISR

   * `rtems.interrupt_disable' - Disable Interrupts

   * `rtems.interrupt_enable' - Enable Interrupts

   * `rtems.interrupt_flash' - Flash Interrupt

   * `rtems.interrupt_is_in_progress' - Is an ISR in Progress


File: ada_user.info,  Node: Interrupt Manager Background,  Next: Interrupt Manager Processing an Interrupt,  Prev: Interrupt Manager Introduction,  Up: Interrupt Manager

6.2 Background
==============

* Menu:

* Interrupt Manager Processing an Interrupt::
* Interrupt Manager RTEMS Interrupt Levels::
* Interrupt Manager Disabling of Interrupts by RTEMS::


File: ada_user.info,  Node: Interrupt Manager Processing an Interrupt,  Next: Interrupt Manager RTEMS Interrupt Levels,  Prev: Interrupt Manager Background,  Up: Interrupt Manager Background

6.2.1 Processing an Interrupt
-----------------------------

The interrupt manager allows the application to connect a function to a
hardware interrupt vector.  When an interrupt occurs, the processor
will automatically vector to RTEMS.  RTEMS saves and restores all
registers which are not preserved by the normal Ada calling convention
for the target processor and invokes the user's ISR.  The user's ISR is
responsible for processing the interrupt, clearing the interrupt if
necessary, and device specific manipulation.

The `rtems.interrupt_catch' directive connects a procedure to an
interrupt vector.  The vector number is managed using the
`rtems.vector_number' data type.

The interrupt service routine is assumed to abide by these conventions
and have a prototype similar to the following:

     NOT SUPPORTED FROM Ada BINDING

The vector number argument is provided by RTEMS to allow the
application to identify the interrupt source.  This could be used to
allow a single routine to service interrupts from multiple instances of
the same device.  For example, a single routine could service
interrupts from multiple serial ports and use the vector number to
identify which port requires servicing.

To minimize the masking of lower or equal priority level interrupts,
the ISR should perform the minimum actions required to service the
interrupt.  Other non-essential actions should be handled by
application tasks.  Once the user's ISR has completed, it returns
control to the RTEMS interrupt manager which will perform task
dispatching and restore the registers saved before the ISR was invoked.

The RTEMS interrupt manager guarantees that proper task scheduling and
dispatching are performed at the conclusion of an ISR.  A system call
made by the ISR may have readied a task of higher priority than the
interrupted task.  Therefore, when the ISR completes, the postponed
dispatch processing must be performed.  No dispatch processing is
performed as part of directives which have been invoked by an ISR.

Applications must adhere to the following rule if proper task
scheduling and dispatching is to be performed:

     The interrupt manager must be used for all ISRs which may be
     interrupted by the highest priority ISR which invokes an RTEMS
     directive.


Consider a processor which allows a numerically low interrupt level to
interrupt a numerically greater interrupt level.  In this example, if
an RTEMS directive is used in a level 4 ISR, then all ISRs which
execute at levels 0 through 4 must use the interrupt manager.

Interrupts are nested whenever an interrupt occurs during the execution
of another ISR.  RTEMS supports efficient interrupt nesting by allowing
the nested ISRs to terminate without performing any dispatch
processing.  Only when the outermost ISR terminates will the postponed
dispatching occur.


File: ada_user.info,  Node: Interrupt Manager RTEMS Interrupt Levels,  Next: Interrupt Manager Disabling of Interrupts by RTEMS,  Prev: Interrupt Manager Processing an Interrupt,  Up: Interrupt Manager Background

6.2.2 RTEMS Interrupt Levels
----------------------------

Many processors support multiple interrupt levels or priorities.  The
exact number of interrupt levels is processor dependent.  RTEMS
internally supports 256 interrupt levels which are mapped to the
processor's interrupt levels.  For specific information on the mapping
between RTEMS and the target processor's interrupt levels, refer to the
Interrupt Processing chapter of the Applications Supplement document
for a specific target processor.


File: ada_user.info,  Node: Interrupt Manager Disabling of Interrupts by RTEMS,  Next: Interrupt Manager Operations,  Prev: Interrupt Manager RTEMS Interrupt Levels,  Up: Interrupt Manager Background

6.2.3 Disabling of Interrupts by RTEMS
--------------------------------------

During the execution of directive calls, critical sections of code may
be executed.  When these sections are encountered, RTEMS disables all
maskable interrupts before the execution of the section and restores
them to the previous level upon completion of the section.  RTEMS has
been optimized to ensure that interrupts are disabled for a minimum
length of time.  The maximum length of time interrupts are disabled by
RTEMS is processor dependent and is detailed in the Timing
Specification chapter of the Applications Supplement document for a
specific target processor.

Non-maskable interrupts (NMI) cannot be disabled, and ISRs which
execute at this level MUST NEVER issue RTEMS system calls.  If a
directive is invoked, unpredictable results may occur due to the
inability of RTEMS to protect its critical sections.  However, ISRs
that make no system calls may safely execute as non-maskable interrupts.


File: ada_user.info,  Node: Interrupt Manager Operations,  Next: Interrupt Manager Establishing an ISR,  Prev: Interrupt Manager Disabling of Interrupts by RTEMS,  Up: Interrupt Manager

6.3 Operations
==============

* Menu:

* Interrupt Manager Establishing an ISR::
* Interrupt Manager Directives Allowed from an ISR::


File: ada_user.info,  Node: Interrupt Manager Establishing an ISR,  Next: Interrupt Manager Directives Allowed from an ISR,  Prev: Interrupt Manager Operations,  Up: Interrupt Manager Operations

6.3.1 Establishing an ISR
-------------------------

The `rtems.interrupt_catch' directive establishes an ISR for the
system.  The address of the ISR and its associated CPU vector number
are specified to this directive.  This directive installs the RTEMS
interrupt wrapper in the processor's Interrupt Vector Table and the
address of the user's ISR in the RTEMS' Vector Table.  This directive
returns the previous contents of the specified vector in the RTEMS'
Vector Table.


File: ada_user.info,  Node: Interrupt Manager Directives Allowed from an ISR,  Next: Interrupt Manager Directives,  Prev: Interrupt Manager Establishing an ISR,  Up: Interrupt Manager Operations

6.3.2 Directives Allowed from an ISR
------------------------------------

Using the interrupt manager ensures that RTEMS knows when a directive
is being called from an ISR.  The ISR may then use system calls to
synchronize itself with an application task.  The synchronization may
involve messages, events or signals being passed by the ISR to the
desired task.  Directives invoked by an ISR must operate only on
objects which reside on the local node.  The following is a list of
RTEMS system calls that may be made from an ISR:

   * Task Management

     Although it is acceptable to operate on the RTEMS_SELF task (e.g.
     the currently executing task), while in an ISR, this will refer to
     the interrupted task.  Most of the time, it is an application
     implementation error to use RTEMS_SELF from an ISR.

        - rtems_task_get_note

        - rtems_task_set_note

        - rtems_task_suspend

        - rtems_task_resume

   * Interrupt Management

        - rtems_interrupt_enable

        - rtems_interrupt_disable

        - rtems_interrupt_flash

        - rtems_interrupt_is_in_progress

        - rtems_interrupt_catch

   * Clock Management

        * rtems_clock_set

        * rtems_clock_get

        * rtems_clock_get_tod

        * rtems_clock_get_tod_timeval

        * rtems_clock_get_seconds_since_epoch

        * rtems_clock_get_ticks_per_second

        * rtems_clock_get_ticks_since_boot

        * rtems_clock_get_uptime

        * rtems_clock_set_nanoseconds_extension

        * rtems_clock_tick

   * Message, Event, and Signal Management

        - rtems_message_queue_send

        - rtems_message_queue_urgent

        - rtems_event_send

        - rtems_signal_send

   * Semaphore Management

        - rtems_semaphore_release

   * Dual-Ported Memory Management

        - rtems_port_external_to_internal

        - rtems_port_internal_to_external

   * IO Management

     The following services are safe to call from an ISR if and only if
     the device driver service invoked is also safe.  The IO Manager
     itself is safe but the invoked driver entry point may or may not
     be.
        - rtems_io_initialize

        - rtems_io_open

        - rtems_io_close

        - rtems_io_read

        - rtems_io_write

        - rtems_io_control

   * Fatal Error Management

        - rtems_fatal_error_occurred

   * Multiprocessing

        - rtems_multiprocessing_announce


File: ada_user.info,  Node: Interrupt Manager Directives,  Next: Interrupt Manager INTERRUPT_CATCH - Establish an ISR,  Prev: Interrupt Manager Directives Allowed from an ISR,  Up: Interrupt Manager

6.4 Directives
==============

* Menu:

* Interrupt Manager INTERRUPT_CATCH - Establish an ISR::
* Interrupt Manager INTERRUPT_DISABLE - Disable Interrupts::
* Interrupt Manager INTERRUPT_ENABLE - Enable Interrupts::
* Interrupt Manager INTERRUPT_FLASH - Flash Interrupts::
* Interrupt Manager INTERRUPT_IS_IN_PROGRESS - Is an ISR in Progress::

This section details the interrupt manager's directives.  A subsection
is dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Interrupt Manager INTERRUPT_CATCH - Establish an ISR,  Next: Interrupt Manager INTERRUPT_DISABLE - Disable Interrupts,  Prev: Interrupt Manager Directives,  Up: Interrupt Manager Directives

6.4.1 INTERRUPT_CATCH - Establish an ISR
----------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - ISR established successfully
`RTEMS.INVALID_NUMBER' - illegal vector number
`RTEMS.INVALID_ADDRESS' - illegal ISR entry point or invalid
`old_isr_handler'

DESCRIPTION:
------------

This directive establishes an interrupt service routine (ISR) for the
specified interrupt vector number.  The `new_isr_handler' parameter
specifies the entry point of the ISR.  The entry point of the previous
ISR for the specified vector is returned in `old_isr_handler'.

To release an interrupt vector, pass the old handler's address obtained
when the vector was first capture.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Interrupt Manager INTERRUPT_DISABLE - Disable Interrupts,  Next: Interrupt Manager INTERRUPT_ENABLE - Enable Interrupts,  Prev: Interrupt Manager INTERRUPT_CATCH - Establish an ISR,  Up: Interrupt Manager Directives

6.4.2 INTERRUPT_DISABLE - Disable Interrupts
--------------------------------------------

CALLING SEQUENCE:
-----------------

     function Interrupt_Disable return RTEMS.ISR_Level;

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive disables all maskable interrupts and returns the
previous `level'.  A later invocation of the `rtems.interrupt_enable'
directive should be used to restore the interrupt level.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Interrupt Manager INTERRUPT_ENABLE - Enable Interrupts,  Next: Interrupt Manager INTERRUPT_FLASH - Flash Interrupts,  Prev: Interrupt Manager INTERRUPT_DISABLE - Disable Interrupts,  Up: Interrupt Manager Directives

6.4.3 INTERRUPT_ENABLE - Enable Interrupts
------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Interrupt_Enable (
        Level : in     RTEMS.ISR_Level
     );

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive enables maskable interrupts to the `level' which was
returned by a previous call to `rtems.interrupt_disable'.  Immediately
prior to invoking this directive, maskable interrupts should be
disabled by a call to `rtems.interrupt_disable' and will be enabled
when this directive returns to the caller.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Interrupt Manager INTERRUPT_FLASH - Flash Interrupts,  Next: Interrupt Manager INTERRUPT_IS_IN_PROGRESS - Is an ISR in Progress,  Prev: Interrupt Manager INTERRUPT_ENABLE - Enable Interrupts,  Up: Interrupt Manager Directives

6.4.4 INTERRUPT_FLASH - Flash Interrupts
----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Interrupt_Flash (
        Level : in     RTEMS.ISR_Level
     );

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive temporarily enables maskable interrupts to the `level'
which was returned by a previous call to `rtems.interrupt_disable'.
Immediately prior to invoking this directive, maskable interrupts should
be disabled by a call to `rtems.interrupt_disable' and will be
redisabled when this directive returns to the caller.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Interrupt Manager INTERRUPT_IS_IN_PROGRESS - Is an ISR in Progress,  Next: Clock Manager,  Prev: Interrupt Manager INTERRUPT_FLASH - Flash Interrupts,  Up: Interrupt Manager Directives

6.4.5 INTERRUPT_IS_IN_PROGRESS - Is an ISR in Progress
------------------------------------------------------

CALLING SEQUENCE:
-----------------

     function Interrupt_Is_In_Progress return RTEMS.Boolean;

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive returns `TRUE' if the processor is currently servicing
an interrupt and `FALSE' otherwise.  A return value of `TRUE' indicates
that the caller is an interrupt service routine, NOT a task.  The
directives available to an interrupt service routine are restricted.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Clock Manager,  Next: Clock Manager Introduction,  Prev: Interrupt Manager INTERRUPT_IS_IN_PROGRESS - Is an ISR in Progress,  Up: Top

7 Clock Manager
***************

* Menu:

* Clock Manager Introduction::
* Clock Manager Background::
* Clock Manager Operations::
* Clock Manager Directives::


File: ada_user.info,  Node: Clock Manager Introduction,  Next: Clock Manager Background,  Prev: Clock Manager,  Up: Clock Manager

7.1 Introduction
================

The clock manager provides support for time of day and other time
related capabilities.  The directives provided by the clock manager are:

   * `rtems.clock_set' - Set date and time

   * `rtems.clock_get' - Get date and time information

   * `rtems.clock_get_tod' - Get date and time in TOD format

   * `rtems.clock_get_tod_timeval' - Get date and time in timeval format

   * `rtems.clock_get_seconds_since_epoch' - Get seconds since epoch

   * `rtems.clock_get_ticks_per_second' - Get ticks per second

   * `rtems.clock_get_ticks_since_boot' - Get ticks since boot

   * `rtems.clock_get_uptime' - Get time since boot

   * `rtems.clock_set_nanoseconds_extension' - Install the nanoseconds
     since last tick handler

   * `rtems.clock_tick' - Announce a clock tick


File: ada_user.info,  Node: Clock Manager Background,  Next: Clock Manager Required Support,  Prev: Clock Manager Introduction,  Up: Clock Manager

7.2 Background
==============

* Menu:

* Clock Manager Required Support::
* Clock Manager Time and Date Data Structures::
* Clock Manager Clock Tick and Timeslicing::
* Clock Manager Delays::
* Clock Manager Timeouts::


File: ada_user.info,  Node: Clock Manager Required Support,  Next: Clock Manager Time and Date Data Structures,  Prev: Clock Manager Background,  Up: Clock Manager Background

7.2.1 Required Support
----------------------

For the features provided by the clock manager to be utilized, periodic
timer interrupts are required.  Therefore, a real-time clock or
hardware timer is necessary to create the timer interrupts.  The
`rtems.clock_tick' directive is normally called by the timer ISR to
announce to RTEMS that a system clock tick has occurred.  Elapsed time
is measured in ticks.  A tick is defined to be an integral number of
microseconds which is specified by the user in the Configuration Table.


File: ada_user.info,  Node: Clock Manager Time and Date Data Structures,  Next: Clock Manager Clock Tick and Timeslicing,  Prev: Clock Manager Required Support,  Up: Clock Manager Background

7.2.2 Time and Date Data Structures
-----------------------------------

The clock facilities of the clock manager operate upon calendar time.
These directives utilize the following date and time record for the
native time and date format:

     type Time_Of_Day is
        record
           Year    : RTEMS.Unsigned32; -- year, A.D.
           Month   : RTEMS.Unsigned32; -- month, 1 .. 12
           Day     : RTEMS.Unsigned32; -- day, 1 .. 31
           Hour    : RTEMS.Unsigned32; -- hour, 0 .. 23
           Minute  : RTEMS.Unsigned32; -- minute, 0 .. 59
           Second  : RTEMS.Unsigned32; -- second, 0 .. 59
           Ticks   : RTEMS.Unsigned32; -- elapsed ticks between seconds
        end record;

The native date and time format is the only format supported when
setting the system date and time using the `rtems.clock_set' directive.
Some applications expect to operate on a "UNIX-style" date and time
data structure.  The `rtems.clock_get_tod_timeval' always returns the
date and time in `struct timeval' format.  The `rtems.clock_get'
directive can optionally return the current date and time in this
format.

The `struct timeval' data structure has two fields: `tv_sec' and
`tv_usec' which are seconds and microseconds, respectively.  The
`tv_sec' field in this data structure is the number of seconds since
the POSIX epoch of January 1, 1970 but will never be prior to the RTEMS
epoch of January 1, 1988.


File: ada_user.info,  Node: Clock Manager Clock Tick and Timeslicing,  Next: Clock Manager Delays,  Prev: Clock Manager Time and Date Data Structures,  Up: Clock Manager Background

7.2.3 Clock Tick and Timeslicing
--------------------------------

Timeslicing is a task scheduling discipline in which tasks of equal
priority are executed for a specific period of time before control of
the CPU is passed to another task.  It is also sometimes referred to as
the automatic round-robin scheduling algorithm.  The length of time
allocated to each task is known as the quantum or timeslice.

The system's timeslice is defined as an integral number of ticks, and
is specified in the Configuration Table.  The timeslice is defined for
the entire system of tasks, but timeslicing is enabled and disabled on
a per task basis.

The `rtems.clock_tick' directive implements timeslicing by decrementing
the running task's time-remaining counter when both timeslicing and
preemption are enabled.  If the task's timeslice has expired, then that
task will be preempted if there exists a ready task of equal priority.


File: ada_user.info,  Node: Clock Manager Delays,  Next: Clock Manager Timeouts,  Prev: Clock Manager Clock Tick and Timeslicing,  Up: Clock Manager Background

7.2.4 Delays
------------

A sleep timer allows a task to delay for a given interval or up until a
given time, and then wake and continue execution.  This type of timer
is created automatically by the `rtems.task_wake_after' and
`rtems.task_wake_when' directives and, as a result, does not have an
RTEMS ID.  Once activated, a sleep timer cannot be explicitly deleted.
Each task may activate one and only one sleep timer at a time.


File: ada_user.info,  Node: Clock Manager Timeouts,  Next: Clock Manager Operations,  Prev: Clock Manager Delays,  Up: Clock Manager Background

7.2.5 Timeouts
--------------

Timeouts are a special type of timer automatically created when the
timeout option is used on the `rtems.message_queue_receive',
`rtems.event_receive', `rtems.semaphore_obtain' and
`rtems.region_get_segment' directives.  Each task may have one and only
one timeout active at a time.  When a timeout expires, it unblocks the
task with a timeout status code.


File: ada_user.info,  Node: Clock Manager Operations,  Next: Clock Manager Announcing a Tick,  Prev: Clock Manager Timeouts,  Up: Clock Manager

7.3 Operations
==============

* Menu:

* Clock Manager Announcing a Tick::
* Clock Manager Setting the Time::
* Clock Manager Obtaining the Time::


File: ada_user.info,  Node: Clock Manager Announcing a Tick,  Next: Clock Manager Setting the Time,  Prev: Clock Manager Operations,  Up: Clock Manager Operations

7.3.1 Announcing a Tick
-----------------------

RTEMS provides the `rtems.clock_tick' directive which is called from
the user's real-time clock ISR to inform RTEMS that a tick has elapsed.
The tick frequency value, defined in microseconds, is a configuration
parameter found in the Configuration Table.  RTEMS divides one million
microseconds (one second) by the number of microseconds per tick to
determine the number of calls to the `rtems.clock_tick' directive per
second.  The frequency of `rtems.clock_tick' calls determines the
resolution (granularity) for all time dependent RTEMS actions.  For
example, calling `rtems.clock_tick' ten times per second yields a higher
resolution than calling `rtems.clock_tick' two times per second.  The
`rtems.clock_tick' directive is responsible for maintaining both
calendar time and the dynamic set of timers.


File: ada_user.info,  Node: Clock Manager Setting the Time,  Next: Clock Manager Obtaining the Time,  Prev: Clock Manager Announcing a Tick,  Up: Clock Manager Operations

7.3.2 Setting the Time
----------------------

The `rtems.clock_set' directive allows a task or an ISR to set the date
and time maintained by RTEMS.  If setting the date and time causes any
outstanding timers to pass their deadline, then the expired timers will
be fired during the invocation of the `rtems.clock_set' directive.


File: ada_user.info,  Node: Clock Manager Obtaining the Time,  Next: Clock Manager Directives,  Prev: Clock Manager Setting the Time,  Up: Clock Manager Operations

7.3.3 Obtaining the Time
------------------------

The `rtems.clock_get' directive allows a task or an ISR to obtain the
current date and time or date and time related information.  The
current date and time can be returned in either native or UNIX-style
format.  Additionally, the application can obtain date and time related
information such as the number of seconds since the RTEMS epoch, the
number of ticks since the executive was initialized, and the number of
ticks per second.  The information returned by the `rtems.clock_get'
directive is dependent on the option selected by the caller.  This is
specified using one of the following constants associated with the
enumerated type `rtems.clock_get_options':

   * `RTEMS.CLOCK_GET_TOD' - obtain native style date and time

   * `RTEMS.CLOCK_GET_TIME_VALUE' - obtain UNIX-style date and time

   * `RTEMS.CLOCK_GET_TICKS_SINCE_BOOT' - obtain number of ticks since
     RTEMS was initialized

   * `RTEMS.CLOCK_GET_SECONDS_SINCE_EPOCH' - obtain number of seconds
     since RTEMS epoch

   * `RTEMS.CLOCK_GET_TICKS_PER_SECOND' - obtain number of clock ticks
     per second


Calendar time operations will return an error code if invoked before
the date and time have been set.


File: ada_user.info,  Node: Clock Manager Directives,  Next: Clock Manager CLOCK_SET - Set date and time,  Prev: Clock Manager Obtaining the Time,  Up: Clock Manager

7.4 Directives
==============

* Menu:

* Clock Manager CLOCK_SET - Set date and time::
* Clock Manager CLOCK_GET - Get date and time information::
* Clock Manager CLOCK_GET_TOD - Get date and time in TOD format::
* Clock Manager CLOCK_GET_TOD_TIMEVAL - Get date and time in timeval format::
* Clock Manager CLOCK_GET_SECONDS_SINCE_EPOCH - Get seconds since epoch::
* Clock Manager CLOCK_GET_TICKS_PER_SECOND - Get ticks per second::
* Clock Manager CLOCK_GET_TICKS_SINCE_BOOT - Get ticks since boot::
* Clock Manager CLOCK_GET_UPTIME - Get the time since boot::
* Clock Manager CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler::
* Clock Manager CLOCK_TICK - Announce a clock tick::

This section details the clock manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Clock Manager CLOCK_SET - Set date and time,  Next: Clock Manager CLOCK_GET - Get date and time information,  Prev: Clock Manager Directives,  Up: Clock Manager Directives

7.4.1 CLOCK_SET - Set date and time
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Clock_Set (
        Time_Buffer : in     RTEMS.Time_Of_Day;
        Result      :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - date and time set successfully
`RTEMS.INVALID_ADDRESS' - `time_buffer' is NULL
`RTEMS.INVALID_CLOCK' - invalid time of day

DESCRIPTION:
------------

This directive sets the system date and time.  The date, time, and
ticks in the time_buffer record are all range-checked, and an error is
returned if any one is out of its valid range.

NOTES:
------

Years before 1988 are invalid.

The system date and time are based on the configured tick rate (number
of microseconds in a tick).

Setting the time forward may cause a higher priority task, blocked
waiting on a specific time, to be made ready.  In this case, the
calling task will be preempted after the next clock tick.

Re-initializing RTEMS causes the system date and time to be reset to an
uninitialized state.  Another call to `rtems.clock_set' is required to
re-initialize the system date and time to application specific
specifications.


File: ada_user.info,  Node: Clock Manager CLOCK_GET - Get date and time information,  Next: Clock Manager CLOCK_GET_TOD - Get date and time in TOD format,  Prev: Clock Manager CLOCK_SET - Set date and time,  Up: Clock Manager Directives

7.4.2 CLOCK_GET - Get date and time information
-----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Clock_Get (
        Option      : in     RTEMS.Clock_Get_Options;
        Time_Buffer : in     RTEMS.Address;
        Result      :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - current time obtained successfully
`RTEMS.NOT_DEFINED' - system date and time is not set
`RTEMS.INVALID_ADDRESS' - `time_buffer' is NULL

DESCRIPTION:
------------

This directive obtains the system date and time.  If the caller is
attempting to obtain the date and time (i.e.  option is set to either
`RTEMS.CLOCK_GET_SECONDS_SINCE_EPOCH', `RTEMS.CLOCK_GET_TOD', or
`RTEMS.CLOCK_GET_TIME_VALUE') and the date and time has not been set
with a previous call to `rtems.clock_set', then the `RTEMS.NOT_DEFINED'
status code is returned.  The caller can always obtain the number of
ticks per second (option is `RTEMS.CLOCK_GET_TICKS_PER_SECOND') and the
number of ticks since the executive was initialized option is
`RTEMS.CLOCK_GET_TICKS_SINCE_BOOT').

The `option' argument may taken on any value of the enumerated type
`rtems_clock_get_options'.  The data type expected for `time_buffer' is
based on the value of `option' as indicated below:

   * `RTEMS.Clock_Get_TOD' - Address of an variable of type
     RTEMS.Time_Of_Day

   * `RTEMS.Clock_Get_Seconds_Since_Epoch' - Address of an variable of
     type RTEMS.Interval

   * `RTEMS.Clock_Get_Ticks_Since_Boot' - Address of an variable of
     type RTEMS.Interval

   * `RTEMS.Clock_Get_Ticks_Per_Second' - Address of an variable of
     type RTEMS.Interval

   * `RTEMS.Clock_Get_Time_Value' - Address of an variable of type
     RTEMS.Clock_Time_Value


NOTES:
------

This directive is callable from an ISR.

This directive will not cause the running task to be preempted.
Re-initializing RTEMS causes the system date and time to be reset to an
uninitialized state.  Another call to `rtems.clock_set' is required to
re-initialize the system date and time to application specific
specifications.


File: ada_user.info,  Node: Clock Manager CLOCK_GET_TOD - Get date and time in TOD format,  Next: Clock Manager CLOCK_GET_TOD_TIMEVAL - Get date and time in timeval format,  Prev: Clock Manager CLOCK_GET - Get date and time information,  Up: Clock Manager Directives

7.4.3 CLOCK_GET_TOD - Get date and time in TOD format
-----------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Clock_Get_TOD (
        Time_Buffer : in     RTEMS.Time_Of_Day;
        Result      :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - current time obtained successfully
`RTEMS.NOT_DEFINED' - system date and time is not set
`RTEMS.INVALID_ADDRESS' - `time_buffer' is NULL

DESCRIPTION:
------------

This directive obtains the system date and time.  If the date and time
has not been set with a previous call to `rtems.clock_set', then the
`RTEMS.NOT_DEFINED' status code is returned.

NOTES:
------

This directive is callable from an ISR.

This directive will not cause the running task to be preempted.
Re-initializing RTEMS causes the system date and time to be reset to an
uninitialized state.  Another call to `rtems.clock_set' is required to
re-initialize the system date and time to application specific
specifications.


File: ada_user.info,  Node: Clock Manager CLOCK_GET_TOD_TIMEVAL - Get date and time in timeval format,  Next: Clock Manager CLOCK_GET_SECONDS_SINCE_EPOCH - Get seconds since epoch,  Prev: Clock Manager CLOCK_GET_TOD - Get date and time in TOD format,  Up: Clock Manager Directives

7.4.4 CLOCK_GET_TOD_TIMEVAL - Get date and time in timeval format
-----------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Clock_Get_TOD_Timeval (
        Time   : in     RTEMS.Timeval;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - current time obtained successfully
`RTEMS.NOT_DEFINED' - system date and time is not set
`RTEMS.INVALID_ADDRESS' - `time' is NULL

DESCRIPTION:
------------

This directive obtains the system date and time in POSIX `struct
timeval' format.  If the date and time has not been set with a previous
call to `rtems.clock_set', then the `RTEMS.NOT_DEFINED' status code is
returned.

NOTES:
------

This directive is callable from an ISR.

This directive will not cause the running task to be preempted.
Re-initializing RTEMS causes the system date and time to be reset to an
uninitialized state.  Another call to `rtems.clock_set' is required to
re-initialize the system date and time to application specific
specifications.


File: ada_user.info,  Node: Clock Manager CLOCK_GET_SECONDS_SINCE_EPOCH - Get seconds since epoch,  Next: Clock Manager CLOCK_GET_TICKS_PER_SECOND - Get ticks per second,  Prev: Clock Manager CLOCK_GET_TOD_TIMEVAL - Get date and time in timeval format,  Up: Clock Manager Directives

7.4.5 CLOCK_GET_SECONDS_SINCE_EPOCH - Get seconds since epoch
-------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Clock_Get_Seconds_Since_Epoch(
        The_Interval :    out RTEMS.Interval;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - current time obtained successfully
`RTEMS.NOT_DEFINED' - system date and time is not set
`RTEMS.INVALID_ADDRESS' - `the_interval' is NULL

DESCRIPTION:
------------

This directive returns the number of seconds since the RTEMS epoch and
the current system date and time.  If the date and time has not been
set with a previous call to `rtems.clock_set', then the
`RTEMS.NOT_DEFINED' status code is returned.

NOTES:
------

This directive is callable from an ISR.

This directive will not cause the running task to be preempted.
Re-initializing RTEMS causes the system date and time to be reset to an
uninitialized state.  Another call to `rtems.clock_set' is required to
re-initialize the system date and time to application specific
specifications.


File: ada_user.info,  Node: Clock Manager CLOCK_GET_TICKS_PER_SECOND - Get ticks per second,  Next: Clock Manager CLOCK_GET_TICKS_SINCE_BOOT - Get ticks since boot,  Prev: Clock Manager CLOCK_GET_SECONDS_SINCE_EPOCH - Get seconds since epoch,  Up: Clock Manager Directives

7.4.6 CLOCK_GET_TICKS_PER_SECOND - Get ticks per second
-------------------------------------------------------

CALLING SEQUENCE:
-----------------

     function Clock_Get_Ticks_Per_Seconds
     return RTEMS.Interval;

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive returns the number of clock ticks per second.  This is
strictly based upon the microseconds per clock tick that the
application has configured.

NOTES:
------

This directive is callable from an ISR.

This directive will not cause the running task to be preempted.
Re-initializing RTEMS causes the system date and time to be reset to an
uninitialized state.  Another call to `rtems.clock_set' is required to
re-initialize the system date and time to application specific
specifications.


File: ada_user.info,  Node: Clock Manager CLOCK_GET_TICKS_SINCE_BOOT - Get ticks since boot,  Next: Clock Manager CLOCK_GET_UPTIME - Get the time since boot,  Prev: Clock Manager CLOCK_GET_TICKS_PER_SECOND - Get ticks per second,  Up: Clock Manager Directives

7.4.7 CLOCK_GET_TICKS_SINCE_BOOT - Get ticks since boot
-------------------------------------------------------

CALLING SEQUENCE:
-----------------

     function Clock_Get_Ticks_Since_Boot
     return RTEMS.Interval;

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive returns the number of clock ticks that have elapsed
since the system was booted.  This is the historical measure of uptime
in an RTEMS system.  The newer service `rtems.clock_get_uptime' is
another and potentially more accurate way of obtaining similar
information.

NOTES:
------

This directive is callable from an ISR.

This directive will not cause the running task to be preempted.
Re-initializing RTEMS causes the system date and time to be reset to an
uninitialized state.  Another call to `rtems.clock_set' is required to
re-initialize the system date and time to application specific
specifications.

This directive simply returns the number of times the dirivective
`rtems.clock_tick' has been invoked since the system was booted.


File: ada_user.info,  Node: Clock Manager CLOCK_GET_UPTIME - Get the time since boot,  Next: Clock Manager CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler,  Prev: Clock Manager CLOCK_GET_TICKS_SINCE_BOOT - Get ticks since boot,  Up: Clock Manager Directives

7.4.8 CLOCK_GET_UPTIME - Get the time since boot
------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Clock_Get_Uptime (
        Uptime :    out RTEMS.Timespec;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - clock tick processed successfully
`RTEMS.INVALID_ADDRESS' - `time_buffer' is NULL

DESCRIPTION:
------------

This directive returns the seconds and nanoseconds since the system was
booted.  If the BSP supports nanosecond clock accuracy, the time
reported will probably be different on every call.

NOTES:
------

This directive may be called from an ISR.


File: ada_user.info,  Node: Clock Manager CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler,  Next: Clock Manager CLOCK_TICK - Announce a clock tick,  Prev: Clock Manager CLOCK_GET_UPTIME - Get the time since boot,  Up: Clock Manager Directives

7.4.9 CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler
---------------------------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - clock tick processed successfully
`RTEMS.INVALID_ADDRESS' - `time_buffer' is NULL

DESCRIPTION:
------------

This directive is used by the Clock device driver to install the
`routine' which will be invoked by the internal RTEMS method used to
obtain a highly accurate time of day.  It is usually called during the
initialization of the driver.

When the `routine' is invoked, it will determine the number of
nanoseconds which have elapsed since the last invocation of the
`rtems.clock_tick' directive.  It should do this as quickly as possible
with as little impact as possible on the device used as a clock source.

NOTES:
------

This directive may be called from an ISR.

This directive is called as part of every service to obtain the current
date and time as well as timestamps.


File: ada_user.info,  Node: Clock Manager CLOCK_TICK - Announce a clock tick,  Next: Timer Manager,  Prev: Clock Manager CLOCK_SET_NANOSECONDS_EXTENSION - Install the nanoseconds since last tick handler,  Up: Clock Manager Directives

7.4.10 CLOCK_TICK - Announce a clock tick
-----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Clock_Tick (
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - clock tick processed successfully

DESCRIPTION:
------------

This directive announces to RTEMS that a system clock tick has
occurred.  The directive is usually called from the timer interrupt ISR
of the local processor.  This directive maintains the system date and
time, decrements timers for delayed tasks, timeouts, rate monotonic
periods, and implements timeslicing.

NOTES:
------

This directive is typically called from an ISR.

The `microseconds_per_tick' and `ticks_per_timeslice' parameters in the
Configuration Table contain the number of microseconds per tick and
number of ticks per timeslice, respectively.


File: ada_user.info,  Node: Timer Manager,  Next: Timer Manager Introduction,  Prev: Clock Manager CLOCK_TICK - Announce a clock tick,  Up: Top

8 Timer Manager
***************

* Menu:

* Timer Manager Introduction::
* Timer Manager Background::
* Timer Manager Operations::
* Timer Manager Directives::


File: ada_user.info,  Node: Timer Manager Introduction,  Next: Timer Manager Background,  Prev: Timer Manager,  Up: Timer Manager

8.1 Introduction
================

The timer manager provides support for timer facilities.  The
directives provided by the timer manager are:

   * `rtems.timer_create' - Create a timer

   * `rtems.timer_ident' - Get ID of a timer

   * `rtems.timer_cancel' - Cancel a timer

   * `rtems.timer_delete' - Delete a timer

   * `rtems.timer_fire_after' - Fire timer after interval

   * `rtems.timer_fire_when' - Fire timer when specified

   * `rtems.timer_initiate_server' - Initiate server for task-based
     timers

   * `rtems.timer_server_fire_after' - Fire task-based timer after
     interval

   * `rtems.timer_server_fire_when' - Fire task-based timer when
     specified

   * `rtems.timer_reset' - Reset an interval timer


File: ada_user.info,  Node: Timer Manager Background,  Next: Timer Manager Required Support,  Prev: Timer Manager Introduction,  Up: Timer Manager

8.2 Background
==============

* Menu:

* Timer Manager Required Support::
* Timer Manager Timers::
* Timer Manager Timer Server::
* Timer Manager Timer Service Routines::


File: ada_user.info,  Node: Timer Manager Required Support,  Next: Timer Manager Timers,  Prev: Timer Manager Background,  Up: Timer Manager Background

8.2.1 Required Support
----------------------

A clock tick is required to support the functionality provided by this
manager.


File: ada_user.info,  Node: Timer Manager Timers,  Next: Timer Manager Timer Server,  Prev: Timer Manager Required Support,  Up: Timer Manager Background

8.2.2 Timers
------------

A timer is an RTEMS object which allows the application to schedule
operations to occur at specific times in the future.  User supplied
timer service routines are invoked by either the `rtems.clock_tick'
directive or a special Timer Server task when the timer fires.  Timer
service routines may perform any operations or directives which normally
would be performed by the application code which invoked the
`rtems.clock_tick' directive.

The timer can be used to implement watchdog routines which only fire to
denote that an application error has occurred.  The timer is reset at
specific points in the application to ensure that the watchdog does not
fire.  Thus, if the application does not reset the watchdog timer, then
the timer service routine will fire to indicate that the application
has failed to reach a reset point.  This use of a timer is sometimes
referred to as a "keep alive" or a "deadman" timer.


File: ada_user.info,  Node: Timer Manager Timer Server,  Next: Timer Manager Timer Service Routines,  Prev: Timer Manager Timers,  Up: Timer Manager Background

8.2.3 Timer Server
------------------

The Timer Server task is responsible for executing the timer service
routines associated with all task-based timers.  This task executes at
a priority higher than any RTEMS application task, and is created
non-preemptible, and thus can be viewed logically as the lowest
priority interrupt.

By providing a mechanism where timer service routines execute in task
rather than interrupt space, the application is allowed a bit more
flexibility in what operations a timer service routine can perform.
For example, the Timer Server can be configured to have a floating
point context in which case it would be safe to perform floating point
operations from a task-based timer.  Most of the time, executing
floating point instructions from an interrupt service routine is not
considered safe. However, since the Timer Server task is
non-preemptible, only directives allowed from an ISR can be called in
the timer service routine.

The Timer Server is designed to remain blocked until a task-based timer
fires.  This reduces the execution overhead of the Timer Server.


File: ada_user.info,  Node: Timer Manager Timer Service Routines,  Next: Timer Manager Operations,  Prev: Timer Manager Timer Server,  Up: Timer Manager Background

8.2.4 Timer Service Routines
----------------------------

The timer service routine should adhere to Ada calling conventions and
have a prototype similar to the following:

     procedure User_Routine(
       Timer_ID  : in     RTEMS.ID;
       User_Data : in     System.Address
     );

Where the timer_id parameter is the RTEMS object ID of the timer which
is being fired and user_data is a pointer to user-defined information
which may be utilized by the timer service routine.  The argument
user_data may be NULL.


File: ada_user.info,  Node: Timer Manager Operations,  Next: Timer Manager Creating a Timer,  Prev: Timer Manager Timer Service Routines,  Up: Timer Manager

8.3 Operations
==============

* Menu:

* Timer Manager Creating a Timer::
* Timer Manager Obtaining Timer IDs::
* Timer Manager Initiating an Interval Timer::
* Timer Manager Initiating a Time of Day Timer::
* Timer Manager Canceling a Timer::
* Timer Manager Resetting a Timer::
* Timer Manager Initiating the Timer Server::
* Timer Manager Deleting a Timer::


File: ada_user.info,  Node: Timer Manager Creating a Timer,  Next: Timer Manager Obtaining Timer IDs,  Prev: Timer Manager Operations,  Up: Timer Manager Operations

8.3.1 Creating a Timer
----------------------

The `rtems.timer_create' directive creates a timer by allocating a
Timer Control Block (TMCB), assigning the timer a user-specified name,
and assigning it a timer ID.  Newly created timers do not have a timer
service routine associated with them and are not active.


File: ada_user.info,  Node: Timer Manager Obtaining Timer IDs,  Next: Timer Manager Initiating an Interval Timer,  Prev: Timer Manager Creating a Timer,  Up: Timer Manager Operations

8.3.2 Obtaining Timer IDs
-------------------------

When a timer is created, RTEMS generates a unique timer ID and assigns
it to the created timer until it is deleted.  The timer ID may be
obtained by either of two methods.  First, as the result of an
invocation of the `rtems.timer_create' directive, the timer ID is
stored in a user provided location.  Second, the timer ID may be
obtained later using the `rtems.timer_ident' directive.  The timer ID
is used by other directives to manipulate this timer.


File: ada_user.info,  Node: Timer Manager Initiating an Interval Timer,  Next: Timer Manager Initiating a Time of Day Timer,  Prev: Timer Manager Obtaining Timer IDs,  Up: Timer Manager Operations

8.3.3 Initiating an Interval Timer
----------------------------------

The `rtems.timer_fire_after' and `rtems.timer_server_fire_after'
directives initiate a timer to fire a user provided timer service
routine after the specified number of clock ticks have elapsed.  When
the interval has elapsed, the timer service routine will be invoked
from the `rtems.clock_tick' directive if it was initiated by the
`rtems.timer_fire_after' directive and from the Timer Server task if
initiated by the `rtems.timer_server_fire_after' directive.


File: ada_user.info,  Node: Timer Manager Initiating a Time of Day Timer,  Next: Timer Manager Canceling a Timer,  Prev: Timer Manager Initiating an Interval Timer,  Up: Timer Manager Operations

8.3.4 Initiating a Time of Day Timer
------------------------------------

The `rtems.timer_fire_when' and `rtems.timer_server_fire_when'
directive initiate a timer to fire a user provided timer service
routine when the specified time of day has been reached.  When the
interval has elapsed, the timer service routine will be invoked from the
`rtems.clock_tick' directive by the `rtems.timer_fire_when' directive
and from the Timer Server task if initiated by the
`rtems.timer_server_fire_when' directive.


File: ada_user.info,  Node: Timer Manager Canceling a Timer,  Next: Timer Manager Resetting a Timer,  Prev: Timer Manager Initiating a Time of Day Timer,  Up: Timer Manager Operations

8.3.5 Canceling a Timer
-----------------------

The `rtems.timer_cancel' directive is used to halt the specified timer.
Once canceled, the timer service routine will not fire unless the timer
is reinitiated.  The timer can be reinitiated using the
`rtems.timer_reset', `rtems.timer_fire_after', and
`rtems.timer_fire_when' directives.


File: ada_user.info,  Node: Timer Manager Resetting a Timer,  Next: Timer Manager Initiating the Timer Server,  Prev: Timer Manager Canceling a Timer,  Up: Timer Manager Operations

8.3.6 Resetting a Timer
-----------------------

The `rtems.timer_reset' directive is used to restore an interval timer
initiated by a previous invocation of `rtems.timer_fire_after' or
`rtems.timer_server_fire_after' to its original interval length.  If the
timer has not been used or the last usage of this timer was by the
`rtems.timer_fire_when' or `rtems.timer_server_fire_when' directive,
then an error is returned.  The timer service routine is not changed or
fired by this directive.


File: ada_user.info,  Node: Timer Manager Initiating the Timer Server,  Next: Timer Manager Deleting a Timer,  Prev: Timer Manager Resetting a Timer,  Up: Timer Manager Operations

8.3.7 Initiating the Timer Server
---------------------------------

The `rtems.timer_initiate_server' directive is used to allocate and
start the execution of the Timer Server task.  The application can
specify both the stack size and attributes of the Timer Server.  The
Timer Server executes at a priority higher than any application task
and thus the user can expect to be preempted as the result of executing
the `rtems.timer_initiate_server' directive.


File: ada_user.info,  Node: Timer Manager Deleting a Timer,  Next: Timer Manager Directives,  Prev: Timer Manager Initiating the Timer Server,  Up: Timer Manager Operations

8.3.8 Deleting a Timer
----------------------

The `rtems.timer_delete' directive is used to delete a timer.  If the
timer is running and has not expired, the timer is automatically
canceled.  The timer's control block is returned to the TMCB free list
when it is deleted.  A timer can be deleted by a task other than the
task which created the timer.  Any subsequent references to the timer's
name and ID are invalid.


File: ada_user.info,  Node: Timer Manager Directives,  Next: Timer Manager TIMER_CREATE - Create a timer,  Prev: Timer Manager Deleting a Timer,  Up: Timer Manager

8.4 Directives
==============

* Menu:

* Timer Manager TIMER_CREATE - Create a timer::
* Timer Manager TIMER_IDENT - Get ID of a timer::
* Timer Manager TIMER_CANCEL - Cancel a timer::
* Timer Manager TIMER_DELETE - Delete a timer::
* Timer Manager TIMER_FIRE_AFTER - Fire timer after interval::
* Timer Manager TIMER_FIRE_WHEN - Fire timer when specified::
* Timer Manager TIMER_INITIATE_SERVER - Initiate server for task-based timers::
* Timer Manager TIMER_SERVER_FIRE_AFTER - Fire task-based timer after interval::
* Timer Manager TIMER_SERVER_FIRE_WHEN - Fire task-based timer when specified::
* Timer Manager TIMER_RESET - Reset an interval timer::

This section details the timer manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Timer Manager TIMER_CREATE - Create a timer,  Next: Timer Manager TIMER_IDENT - Get ID of a timer,  Prev: Timer Manager Directives,  Up: Timer Manager Directives

8.4.1 TIMER_CREATE - Create a timer
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Create (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer created successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - invalid timer name
`RTEMS.TOO_MANY' - too many timers created

DESCRIPTION:
------------

This directive creates a timer.  The assigned timer id is returned in
id.  This id is used to access the timer with other timer manager
directives.  For control and maintenance of the timer, RTEMS allocates
a TMCB from the local TMCB free pool and initializes it.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Timer Manager TIMER_IDENT - Get ID of a timer,  Next: Timer Manager TIMER_CANCEL - Cancel a timer,  Prev: Timer Manager TIMER_CREATE - Create a timer,  Up: Timer Manager Directives

8.4.2 TIMER_IDENT - Get ID of a timer
-------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Ident (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer identified successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - timer name not found

DESCRIPTION:
------------

This directive obtains the timer id associated with the timer name to
be acquired.  If the timer name is not unique, then the timer id will
match one of the timers with that name.  However, this timer id is not
guaranteed to correspond to the desired timer.  The timer id is used to
access this timer in other timer related directives.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Timer Manager TIMER_CANCEL - Cancel a timer,  Next: Timer Manager TIMER_DELETE - Delete a timer,  Prev: Timer Manager TIMER_IDENT - Get ID of a timer,  Up: Timer Manager Directives

8.4.3 TIMER_CANCEL - Cancel a timer
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Cancel (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer canceled successfully
`RTEMS.INVALID_ID' - invalid timer id

DESCRIPTION:
------------

This directive cancels the timer id.  This timer will be reinitiated by
the next invocation of `rtems.timer_reset', `rtems.timer_fire_after', or
`rtems.timer_fire_when' with this id.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Timer Manager TIMER_DELETE - Delete a timer,  Next: Timer Manager TIMER_FIRE_AFTER - Fire timer after interval,  Prev: Timer Manager TIMER_CANCEL - Cancel a timer,  Up: Timer Manager Directives

8.4.4 TIMER_DELETE - Delete a timer
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer deleted successfully
`RTEMS.INVALID_ID' - invalid timer id

DESCRIPTION:
------------

This directive deletes the timer specified by id.  If the timer is
running, it is automatically canceled.  The TMCB for the deleted timer
is reclaimed by RTEMS.

NOTES:
------

This directive will not cause the running task to be preempted.

A timer can be deleted by a task other than the task which created the
timer.


File: ada_user.info,  Node: Timer Manager TIMER_FIRE_AFTER - Fire timer after interval,  Next: Timer Manager TIMER_FIRE_WHEN - Fire timer when specified,  Prev: Timer Manager TIMER_DELETE - Delete a timer,  Up: Timer Manager Directives

8.4.5 TIMER_FIRE_AFTER - Fire timer after interval
--------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Fire_After (
        ID        : in     RTEMS.ID;
        Ticks     : in     RTEMS.Interval;
        Routine   : in     RTEMS.Timer_Service_Routine;
        User_Data : in     RTEMS.Address;
        Result    :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer initiated successfully
`RTEMS.INVALID_ADDRESS' - `routine' is NULL
`RTEMS.INVALID_ID' - invalid timer id
`RTEMS.INVALID_NUMBER' - invalid interval

DESCRIPTION:
------------

This directive initiates the timer specified by id.  If the timer is
running, it is automatically canceled before being initiated.  The
timer is scheduled to fire after an interval ticks clock ticks has
passed.  When the timer fires, the timer service routine routine will
be invoked with the argument user_data.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Timer Manager TIMER_FIRE_WHEN - Fire timer when specified,  Next: Timer Manager TIMER_INITIATE_SERVER - Initiate server for task-based timers,  Prev: Timer Manager TIMER_FIRE_AFTER - Fire timer after interval,  Up: Timer Manager Directives

8.4.6 TIMER_FIRE_WHEN - Fire timer when specified
-------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Fire_When (
        ID        : in     RTEMS.ID;
        Wall_Time : in     RTEMS.Time_Of_Day;
        Routine   : in     RTEMS.Timer_Service_Routine;
        User_Data : in     RTEMS.Address;
        Result    :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer initiated successfully
`RTEMS.INVALID_ADDRESS' - `routine' is NULL
`RTEMS.INVALID_ADDRESS' - `wall_time' is NULL
`RTEMS.INVALID_ID' - invalid timer id
`RTEMS.NOT_DEFINED' - system date and time is not set
`RTEMS.INVALID_CLOCK' - invalid time of day

DESCRIPTION:
------------

This directive initiates the timer specified by id.  If the timer is
running, it is automatically canceled before being initiated.  The
timer is scheduled to fire at the time of day specified by wall_time.
When the timer fires, the timer service routine routine will be invoked
with the argument user_data.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Timer Manager TIMER_INITIATE_SERVER - Initiate server for task-based timers,  Next: Timer Manager TIMER_SERVER_FIRE_AFTER - Fire task-based timer after interval,  Prev: Timer Manager TIMER_FIRE_WHEN - Fire timer when specified,  Up: Timer Manager Directives

8.4.7 TIMER_INITIATE_SERVER - Initiate server for task-based timers
-------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Initiate_Server (
        Server_Priority : in     RTEMS.Task_Priority;
        Stack_Size      : in     RTEMS.Unsigned32;
        Attribute_Set   : in     RTEMS.Attribute;
        Result          :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - Timer Server initiated successfully
`RTEMS.TOO_MANY' - too many tasks created

DESCRIPTION:
------------

This directive initiates the Timer Server task.  This task is
responsible for executing all timers initiated via the
`rtems.timer_server_fire_after' or `rtems.timer_server_fire_when'
directives.

NOTES:
------

This directive could cause the calling task to be preempted.

The Timer Server task is created using the `rtems.task_create' service
and must be accounted for when configuring the system.

Even through this directive invokes the `rtems.task_create' and
`rtems.task_start' directives, it should only fail due to resource
allocation problems.


File: ada_user.info,  Node: Timer Manager TIMER_SERVER_FIRE_AFTER - Fire task-based timer after interval,  Next: Timer Manager TIMER_SERVER_FIRE_WHEN - Fire task-based timer when specified,  Prev: Timer Manager TIMER_INITIATE_SERVER - Initiate server for task-based timers,  Up: Timer Manager Directives

8.4.8 TIMER_SERVER_FIRE_AFTER - Fire task-based timer after interval
--------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Fire_Server_After (
        ID        : in     RTEMS.ID;
        Ticks     : in     RTEMS.Interval;
        Routine   : in     RTEMS.Timer_Service_Routine;
        User_Data : in     RTEMS.Address;
        Result    :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer initiated successfully
`RTEMS.INVALID_ADDRESS' - `routine' is NULL
`RTEMS.INVALID_ID' - invalid timer id
`RTEMS.INVALID_NUMBER' - invalid interval
`RTEMS.INCORRECT_STATE' - Timer Server not initiated

DESCRIPTION:
------------

This directive initiates the timer specified by id and specifies that
when it fires it will be executed by the Timer Server.

If the timer is running, it is automatically canceled before being
initiated.  The timer is scheduled to fire after an interval ticks
clock ticks has passed.  When the timer fires, the timer service
routine routine will be invoked with the argument user_data.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Timer Manager TIMER_SERVER_FIRE_WHEN - Fire task-based timer when specified,  Next: Timer Manager TIMER_RESET - Reset an interval timer,  Prev: Timer Manager TIMER_SERVER_FIRE_AFTER - Fire task-based timer after interval,  Up: Timer Manager Directives

8.4.9 TIMER_SERVER_FIRE_WHEN - Fire task-based timer when specified
-------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Fire_Server_When (
        ID        : in     RTEMS.ID;
        Wall_Time : in     RTEMS.Time_Of_Day;
        Routine   : in     RTEMS.Timer_Service_Routine;
        User_Data : in     RTEMS.Address;
        Result    :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer initiated successfully
`RTEMS.INVALID_ADDRESS' - `routine' is NULL
`RTEMS.INVALID_ADDRESS' - `wall_time' is NULL
`RTEMS.INVALID_ID' - invalid timer id
`RTEMS.NOT_DEFINED' - system date and time is not set
`RTEMS.INVALID_CLOCK' - invalid time of day
`RTEMS.INCORRECT_STATE' - Timer Server not initiated

DESCRIPTION:
------------

This directive initiates the timer specified by id and specifies that
when it fires it will be executed by the Timer Server.

If the timer is running, it is automatically canceled before being
initiated.  The timer is scheduled to fire at the time of day specified
by wall_time.  When the timer fires, the timer service routine routine
will be invoked with the argument user_data.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Timer Manager TIMER_RESET - Reset an interval timer,  Next: Semaphore Manager,  Prev: Timer Manager TIMER_SERVER_FIRE_WHEN - Fire task-based timer when specified,  Up: Timer Manager Directives

8.4.10 TIMER_RESET - Reset an interval timer
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Timer_Reset (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - timer reset successfully
`RTEMS.INVALID_ID' - invalid timer id
`RTEMS.NOT_DEFINED' - attempted to reset a when or newly created timer

DESCRIPTION:
------------

This directive resets the timer associated with id.  This timer must
have been previously initiated with either the `rtems.timer_fire_after'
or `rtems.timer_server_fire_after' directive.  If active the timer is
canceled, after which the timer is reinitiated using the same interval
and timer service routine which the original `rtems.timer_fire_after'
`rtems.timer_server_fire_after' directive used.

NOTES:
------

If the timer has not been used or the last usage of this timer was by a
`rtems.timer_fire_when' or `rtems.timer_server_fire_when' directive,
then the `RTEMS.NOT_DEFINED' error is returned.

Restarting a cancelled after timer results in the timer being
reinitiated with its previous timer service routine and interval.

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Semaphore Manager,  Next: Semaphore Manager Introduction,  Prev: Timer Manager TIMER_RESET - Reset an interval timer,  Up: Top

9 Semaphore Manager
*******************

* Menu:

* Semaphore Manager Introduction::
* Semaphore Manager Background::
* Semaphore Manager Operations::
* Semaphore Manager Directives::


File: ada_user.info,  Node: Semaphore Manager Introduction,  Next: Semaphore Manager Background,  Prev: Semaphore Manager,  Up: Semaphore Manager

9.1 Introduction
================

The semaphore manager utilizes standard Dijkstra counting semaphores to
provide synchronization and mutual exclusion capabilities.  The
directives provided by the semaphore manager are:

   * `rtems.semaphore_create' -  Create a semaphore

   * `rtems.semaphore_ident' - Get ID of a semaphore

   * `rtems.semaphore_delete' - Delete a semaphore

   * `rtems.semaphore_obtain' - Acquire a semaphore

   * `rtems.semaphore_release' - Release a semaphore

   * `rtems.semaphore_flush' - Unblock all tasks waiting on a semaphore


File: ada_user.info,  Node: Semaphore Manager Background,  Next: Semaphore Manager Nested Resource Access,  Prev: Semaphore Manager Introduction,  Up: Semaphore Manager

9.2 Background
==============

* Menu:

* Semaphore Manager Nested Resource Access::
* Semaphore Manager Priority Inversion::
* Semaphore Manager Priority Inheritance::
* Semaphore Manager Priority Ceiling::
* Semaphore Manager Building a Semaphore Attribute Set::
* Semaphore Manager Building a SEMAPHORE_OBTAIN Option Set::

A semaphore can be viewed as a protected variable whose value can be
modified only with the `rtems.semaphore_create',
`rtems.semaphore_obtain', and `rtems.semaphore_release' directives.
RTEMS supports both binary and counting semaphores. A binary semaphore
is restricted to values of zero or one, while a counting semaphore can
assume any non-negative integer value.

A binary semaphore can be used to control access to a single resource.
In particular, it can be used to enforce mutual exclusion for a
critical section in user code.  In this instance, the semaphore would
be created with an initial count of one to indicate that no task is
executing the critical section of code.  Upon entry to the critical
section, a task must issue the `rtems.semaphore_obtain' directive to
prevent other tasks from entering the critical section.  Upon exit from
the critical section, the task must issue the `rtems.semaphore_release'
directive to allow another task to execute the critical section.

A counting semaphore can be used to control access to a pool of two or
more resources.  For example, access to three printers could be
administered by a semaphore created with an initial count of three.
When a task requires access to one of the printers, it issues the
`rtems.semaphore_obtain' directive to obtain access to a printer.  If a
printer is not currently available, the task can wait for a printer to
become available or return immediately.  When the task has completed
printing, it should issue the `rtems.semaphore_release' directive to
allow other tasks access to the printer.

Task synchronization may be achieved by creating a semaphore with an
initial count of zero.  One task waits for the arrival of another task
by issuing a `rtems.semaphore_obtain' directive when it reaches a
synchronization point.  The other task performs a corresponding
`rtems.semaphore_release' operation when it reaches its synchronization
point, thus unblocking the pending task.


File: ada_user.info,  Node: Semaphore Manager Nested Resource Access,  Next: Semaphore Manager Priority Inversion,  Prev: Semaphore Manager Background,  Up: Semaphore Manager Background

9.2.1 Nested Resource Access
----------------------------

Deadlock occurs when a task owning a binary semaphore attempts to
acquire that same semaphore and blocks as result.  Since the semaphore
is allocated to a task, it cannot be deleted.  Therefore, the task that
currently holds the semaphore and is also blocked waiting for that
semaphore will never execute again.

RTEMS addresses this problem by allowing the task holding the binary
semaphore to obtain the same binary semaphore multiple times in a
nested manner.  Each `rtems.semaphore_obtain' must be accompanied with a
`rtems.semaphore_release'.  The semaphore will only be made available
for acquisition by other tasks when the outermost
`rtems.semaphore_obtain' is matched with a `rtems.semaphore_release'.

Simple binary semaphores do not allow nested access and so can be used
for task synchronization.


File: ada_user.info,  Node: Semaphore Manager Priority Inversion,  Next: Semaphore Manager Priority Inheritance,  Prev: Semaphore Manager Nested Resource Access,  Up: Semaphore Manager Background

9.2.2 Priority Inversion
------------------------

Priority inversion is a form of indefinite postponement which is common
in multitasking, preemptive executives with shared resources.  Priority
inversion occurs when a high priority tasks requests access to shared
resource which is currently allocated to low priority task.  The high
priority task must block until the low priority task releases the
resource.  This problem is exacerbated when the low priority task is
prevented from executing by one or more medium priority tasks.  Because
the low priority task is not executing, it cannot complete its
interaction with the resource and release that resource.  The high
priority task is effectively prevented from executing by lower priority
tasks.


File: ada_user.info,  Node: Semaphore Manager Priority Inheritance,  Next: Semaphore Manager Priority Ceiling,  Prev: Semaphore Manager Priority Inversion,  Up: Semaphore Manager Background

9.2.3 Priority Inheritance
--------------------------

Priority inheritance is an algorithm that calls for the lower priority
task holding a resource to have its priority increased to that of the
highest priority task blocked waiting for that resource.  Each time a
task blocks attempting to obtain the resource, the task holding the
resource may have its priority increased.

RTEMS supports priority inheritance for local, binary semaphores that
use the priority task wait queue blocking discipline.   When a task of
higher priority than the task holding the semaphore blocks, the
priority of the task holding the semaphore is increased to that of the
blocking task.  When the task holding the task completely releases the
binary semaphore (i.e. not for a nested release), the holder's priority
is restored to the value it had before any higher priority was
inherited.

The RTEMS implementation of the priority inheritance algorithm takes
into account the scenario in which a task holds more than one binary
semaphore.  The holding task will execute at the priority of the higher
of the highest ceiling priority or at the priority of the highest
priority task blocked waiting for any of the semaphores the task holds.
Only when the task releases ALL of the binary semaphores it holds will
its priority be restored to the normal value.


File: ada_user.info,  Node: Semaphore Manager Priority Ceiling,  Next: Semaphore Manager Building a Semaphore Attribute Set,  Prev: Semaphore Manager Priority Inheritance,  Up: Semaphore Manager Background

9.2.4 Priority Ceiling
----------------------

Priority ceiling is an algorithm that calls for the lower priority task
holding a resource to have its priority increased to that of the
highest priority task which will EVER block waiting for that resource.
This algorithm addresses the problem of priority inversion although it
avoids the possibility of changing the priority of the task holding the
resource multiple times.  The priority ceiling algorithm will only
change the priority of the task holding the resource a maximum of one
time.  The ceiling priority is set at creation time and must be the
priority of the highest priority task which will ever attempt to
acquire that semaphore.

RTEMS supports priority ceiling for local, binary semaphores that use
the priority task wait queue blocking discipline.   When a task of
lower priority than the ceiling priority successfully obtains the
semaphore, its priority is raised to the ceiling priority.  When the
task holding the task completely releases the binary semaphore (i.e.
not for a nested release), the holder's priority is restored to the
value it had before any higher priority was put into effect.

The need to identify the highest priority task which will attempt to
obtain a particular semaphore can be a difficult task in a large,
complicated system.  Although the priority ceiling algorithm is more
efficient than the priority inheritance algorithm with respect to the
maximum number of task priority changes which may occur while a task
holds a particular semaphore, the priority inheritance algorithm is
more forgiving in that it does not require this apriori information.

The RTEMS implementation of the priority ceiling algorithm takes into
account the scenario in which a task holds more than one binary
semaphore.  The holding task will execute at the priority of the higher
of the highest ceiling priority or at the priority of the highest
priority task blocked waiting for any of the semaphores the task holds.
Only when the task releases ALL of the binary semaphores it holds will
its priority be restored to the normal value.


File: ada_user.info,  Node: Semaphore Manager Building a Semaphore Attribute Set,  Next: Semaphore Manager Building a SEMAPHORE_OBTAIN Option Set,  Prev: Semaphore Manager Priority Ceiling,  Up: Semaphore Manager Background

9.2.5 Building a Semaphore Attribute Set
----------------------------------------

In general, an attribute set is built by a bitwise OR of the desired
attribute components.  The following table lists the set of valid
semaphore attributes:

   * `RTEMS.FIFO' - tasks wait by FIFO (default)

   * `RTEMS.PRIORITY' - tasks wait by priority

   * `RTEMS.BINARY_SEMAPHORE' - restrict values to 0 and 1

   * `RTEMS.COUNTING_SEMAPHORE' - no restriction on values (default)

   * `RTEMS.SIMPLE_BINARY_SEMAPHORE' - restrict values to 0 and 1, do
     not allow nested access, allow deletion of locked semaphore.

   * `RTEMS.NO_INHERIT_PRIORITY' - do not use priority inheritance
     (default)

   * `RTEMS.INHERIT_PRIORITY' - use priority inheritance

   * `RTEMS.PRIORITY_CEILING' - use priority ceiling

   * `RTEMS.NO_PRIORITY_CEILING' - do not use priority ceiling (default)

   * `RTEMS.LOCAL' - local task (default)

   * `RTEMS.GLOBAL' - global task

Attribute values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each attribute appears exactly once in the component list.  An
attribute listed as a default is not required to appear in the
attribute list, although it is a good programming practice to specify
default attributes.  If all defaults are desired, the attribute
`RTEMS.DEFAULT_ATTRIBUTES' should be specified on this call.

This example demonstrates the attribute_set parameter needed to create a
local semaphore with the task priority waiting queue discipline.  The
attribute_set parameter passed to the `rtems.semaphore_create'
directive could be either `RTEMS.PRIORITY' or `RTEMS.LOCAL or
RTEMS.PRIORITY'.  The attribute_set parameter can be set to
`RTEMS.PRIORITY' because `RTEMS.LOCAL' is the default for all created
tasks.  If a similar semaphore were to be known globally, then the
attribute_set parameter would be `RTEMS.GLOBAL or RTEMS.PRIORITY'.

Some combinatinos of these attributes are invalid.  For example,
priority ordered blocking discipline must be applied to a binary
semaphore in order to use either the priority inheritance or priority
ceiling functionality.  The following tree figure illustrates the valid
combinations.

     Not available in ASCII representation

Figure    9.1: Valid Semaphore Attributes Combinations


File: ada_user.info,  Node: Semaphore Manager Building a SEMAPHORE_OBTAIN Option Set,  Next: Semaphore Manager Operations,  Prev: Semaphore Manager Building a Semaphore Attribute Set,  Up: Semaphore Manager Background

9.2.6 Building a SEMAPHORE_OBTAIN Option Set
--------------------------------------------

In general, an option is built by a bitwise OR of the desired option
components.  The set of valid options for the `rtems.semaphore_obtain'
directive are listed in the following table:

   * `RTEMS.WAIT' - task will wait for semaphore (default)

   * `RTEMS.NO_WAIT' - task should not wait

Option values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each attribute appears exactly once in the component list.  An option
listed as a default is not required to appear in the list, although it
is a good programming practice to specify default options.  If all
defaults are desired, the option `RTEMS.DEFAULT_OPTIONS' should be
specified on this call.

This example demonstrates the option parameter needed to poll for a
semaphore.  The option parameter passed to the `rtems.semaphore_obtain'
directive should be `RTEMS.NO_WAIT'.


File: ada_user.info,  Node: Semaphore Manager Operations,  Next: Semaphore Manager Creating a Semaphore,  Prev: Semaphore Manager Building a SEMAPHORE_OBTAIN Option Set,  Up: Semaphore Manager

9.3 Operations
==============

* Menu:

* Semaphore Manager Creating a Semaphore::
* Semaphore Manager Obtaining Semaphore IDs::
* Semaphore Manager Acquiring a Semaphore::
* Semaphore Manager Releasing a Semaphore::
* Semaphore Manager Deleting a Semaphore::


File: ada_user.info,  Node: Semaphore Manager Creating a Semaphore,  Next: Semaphore Manager Obtaining Semaphore IDs,  Prev: Semaphore Manager Operations,  Up: Semaphore Manager Operations

9.3.1 Creating a Semaphore
--------------------------

The `rtems.semaphore_create' directive creates a binary or counting
semaphore with a user-specified name as well as an initial count.  If a
binary semaphore is created with a count of zero (0) to indicate that
it has been allocated, then the task creating the semaphore is
considered the current holder of the semaphore.  At create time the
method for ordering waiting tasks in the semaphore's task wait queue
(by FIFO or task priority) is specified.  Additionally, the priority
inheritance or priority ceiling algorithm may be selected for local,
binary semaphores that use the priority task wait queue blocking
discipline.  If the priority ceiling algorithm is selected, then the
highest priority of any task which will attempt to obtain this semaphore
must be specified.  RTEMS allocates a Semaphore Control Block (SMCB)
from the SMCB free list.  This data structure is used by RTEMS to
manage the newly created semaphore.  Also, a unique semaphore ID is
generated and returned to the calling task.


File: ada_user.info,  Node: Semaphore Manager Obtaining Semaphore IDs,  Next: Semaphore Manager Acquiring a Semaphore,  Prev: Semaphore Manager Creating a Semaphore,  Up: Semaphore Manager Operations

9.3.2 Obtaining Semaphore IDs
-----------------------------

When a semaphore is created, RTEMS generates a unique semaphore ID and
assigns it to the created semaphore until it is deleted.  The semaphore
ID may be obtained by either of two methods.  First, as the result of
an invocation of the `rtems.semaphore_create' directive, the semaphore
ID is stored in a user provided location.  Second, the semaphore ID may
be obtained later using the `rtems.semaphore_ident' directive.  The
semaphore ID is used by other semaphore manager directives to access
this semaphore.


File: ada_user.info,  Node: Semaphore Manager Acquiring a Semaphore,  Next: Semaphore Manager Releasing a Semaphore,  Prev: Semaphore Manager Obtaining Semaphore IDs,  Up: Semaphore Manager Operations

9.3.3 Acquiring a Semaphore
---------------------------

The `rtems.semaphore_obtain' directive is used to acquire the specified
semaphore.  A simplified version of the `rtems.semaphore_obtain'
directive can be described as follows:

     if semaphore's count is greater than zero
        then decrement semaphore's count
        else wait for release of semaphore

     return SUCCESSFUL

When the semaphore cannot be immediately acquired, one of the following
situations applies:

   * By default, the calling task will wait forever to acquire the
     semaphore.

   * Specifying `RTEMS.NO_WAIT' forces an immediate return with an
     error status code.

   * Specifying a timeout limits the interval the task will wait before
     returning with an error status code.

If the task waits to acquire the semaphore, then it is placed in the
semaphore's task wait queue in either FIFO or task priority order.  If
the task blocked waiting for a binary semaphore using priority
inheritance and the task's priority is greater than that of the task
currently holding the semaphore, then the holding task will inherit the
priority of the blocking task.  All tasks waiting on a semaphore are
returned an error code when the semaphore is deleted.

When a task successfully obtains a semaphore using priority ceiling and
the priority ceiling for this semaphore is greater than that of the
holder, then the holder's priority will be elevated.


File: ada_user.info,  Node: Semaphore Manager Releasing a Semaphore,  Next: Semaphore Manager Deleting a Semaphore,  Prev: Semaphore Manager Acquiring a Semaphore,  Up: Semaphore Manager Operations

9.3.4 Releasing a Semaphore
---------------------------

The `rtems.semaphore_release' directive is used to release the
specified semaphore.  A simplified version of the
`rtems.semaphore_release' directive can be described as follows:

     if no tasks are waiting on this semaphore
        then increment semaphore's count
        else assign semaphore to a waiting task

     return SUCCESSFUL

If this is the outermost release of a binary semaphore that uses
priority inheritance or priority ceiling and the task does not
currently hold any other binary semaphores, then the task performing
the `rtems.semaphore_release' will have its priority restored to its
normal value.


File: ada_user.info,  Node: Semaphore Manager Deleting a Semaphore,  Next: Semaphore Manager Directives,  Prev: Semaphore Manager Releasing a Semaphore,  Up: Semaphore Manager Operations

9.3.5 Deleting a Semaphore
--------------------------

The `rtems.semaphore_delete' directive removes a semaphore from the
system and frees its control block.  A semaphore can be deleted by any
local task that knows the semaphore's ID.  As a result of this
directive, all tasks blocked waiting to acquire the semaphore will be
readied and returned a status code which indicates that the semaphore
was deleted.  Any subsequent references to the semaphore's name and ID
are invalid.


File: ada_user.info,  Node: Semaphore Manager Directives,  Next: Semaphore Manager SEMAPHORE_CREATE - Create a semaphore,  Prev: Semaphore Manager Deleting a Semaphore,  Up: Semaphore Manager

9.4 Directives
==============

* Menu:

* Semaphore Manager SEMAPHORE_CREATE - Create a semaphore::
* Semaphore Manager SEMAPHORE_IDENT - Get ID of a semaphore::
* Semaphore Manager SEMAPHORE_DELETE - Delete a semaphore::
* Semaphore Manager SEMAPHORE_OBTAIN - Acquire a semaphore::
* Semaphore Manager SEMAPHORE_RELEASE - Release a semaphore::
* Semaphore Manager SEMAPHORE_FLUSH - Unblock all tasks waiting on a semaphore::

This section details the semaphore manager's directives.  A subsection
is dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Semaphore Manager SEMAPHORE_CREATE - Create a semaphore,  Next: Semaphore Manager SEMAPHORE_IDENT - Get ID of a semaphore,  Prev: Semaphore Manager Directives,  Up: Semaphore Manager Directives

9.4.1 SEMAPHORE_CREATE - Create a semaphore
-------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Semaphore_Create (
        Name             : in     RTEMS.Name;
        Count            : in     RTEMS.Unsigned32;
        Attribute_Set    : in     RTEMS.Attribute;
        Priority_Ceiling : in     RTEMS.Task_Priority;
        ID               :    out RTEMS.ID;
        Result           :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - semaphore created successfully
`RTEMS.INVALID_NAME' - invalid semaphore name
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.TOO_MANY' - too many semaphores created
`RTEMS.NOT_DEFINED' - invalid attribute set
`RTEMS.INVALID_NUMBER' - invalid starting count for binary semaphore
`RTEMS.MP_NOT_CONFIGURED' - multiprocessing not configured
`RTEMS.TOO_MANY' - too many global objects

DESCRIPTION:
------------

This directive creates a semaphore which resides on the local node. The
created semaphore has the user-defined name specified in name and the
initial count specified in count.  For control and maintenance of the
semaphore, RTEMS allocates and initializes a SMCB.  The RTEMS-assigned
semaphore id is returned in id.  This semaphore id is used with other
semaphore related directives to access the semaphore.

Specifying PRIORITY in attribute_set causes tasks waiting for a
semaphore to be serviced according to task priority.  When FIFO is
selected, tasks are serviced in First In-First Out order.

NOTES:
------

This directive will not cause the calling task to be preempted.

The priority inheritance and priority ceiling algorithms are only
supported for local, binary semaphores that use the priority task wait
queue blocking discipline.

The following semaphore attribute constants are defined by RTEMS:

   * `RTEMS.FIFO' - tasks wait by FIFO (default)

   * `RTEMS.PRIORITY' - tasks wait by priority

   * `RTEMS.BINARY_SEMAPHORE' - restrict values to 0 and 1

   * `RTEMS.COUNTING_SEMAPHORE' - no restriction on values (default)

   * `RTEMS.SIMPLE_BINARY_SEMAPHORE' - restrict values to 0 and 1,
     block on nested access, allow deletion of locked semaphore.

   * `RTEMS.NO_INHERIT_PRIORITY' - do not use priority inheritance
     (default)

   * `RTEMS.INHERIT_PRIORITY' - use priority inheritance

   * `RTEMS.PRIORITY_CEILING' - use priority ceiling

   * `RTEMS.NO_PRIORITY_CEILING' - do not use priority ceiling (default)

   * `RTEMS.LOCAL' - local semaphore (default)

   * `RTEMS.GLOBAL' - global semaphore

Semaphores should not be made global unless remote tasks must interact
with the created semaphore.  This is to avoid the system overhead
incurred by the creation of a global semaphore.  When a global
semaphore is created, the semaphore's name and id must be transmitted
to every node in the system for insertion in the local copy of the
global object table.

Note that some combinations of attributes are not valid.  See the
earlier discussion on this.

The total number of global objects, including semaphores, is limited by
the maximum_global_objects field in the Configuration Table.


File: ada_user.info,  Node: Semaphore Manager SEMAPHORE_IDENT - Get ID of a semaphore,  Next: Semaphore Manager SEMAPHORE_DELETE - Delete a semaphore,  Prev: Semaphore Manager SEMAPHORE_CREATE - Create a semaphore,  Up: Semaphore Manager Directives

9.4.2 SEMAPHORE_IDENT - Get ID of a semaphore
---------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Semaphore_Ident (
        Name   : in     RTEMS.Name;
        Node   : in     RTEMS.Unsigned32;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - semaphore identified successfully
`RTEMS.INVALID_NAME' - semaphore name not found
`RTEMS.INVALID_NODE' - invalid node id

DESCRIPTION:
------------

This directive obtains the semaphore id associated with the semaphore
name.  If the semaphore name is not unique, then the semaphore id will
match one of the semaphores with that name.  However, this semaphore id
is not guaranteed to correspond to the desired semaphore.  The
semaphore id is used by other semaphore related directives to access
the semaphore.

NOTES:
------

This directive will not cause the running task to be preempted.

If node is `RTEMS.SEARCH_ALL_NODES', all nodes are searched with the
local node being searched first.  All other nodes are searched with the
lowest numbered node searched first.

If node is a valid node number which does not represent the local node,
then only the semaphores exported by the designated node are searched.

This directive does not generate activity on remote nodes.  It accesses
only the local copy of the global object table.


File: ada_user.info,  Node: Semaphore Manager SEMAPHORE_DELETE - Delete a semaphore,  Next: Semaphore Manager SEMAPHORE_OBTAIN - Acquire a semaphore,  Prev: Semaphore Manager SEMAPHORE_IDENT - Get ID of a semaphore,  Up: Semaphore Manager Directives

9.4.3 SEMAPHORE_DELETE - Delete a semaphore
-------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Semaphore_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' -  semaphore deleted successfully
`RTEMS.INVALID_ID' - invalid semaphore id
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - cannot delete remote semaphore
`RTEMS.RESOURCE_IN_USE' - binary semaphore is in use

DESCRIPTION:
------------

This directive deletes the semaphore specified by `id'.  All tasks
blocked waiting to acquire the semaphore will be readied and returned a
status code which indicates that the semaphore was deleted.  The SMCB
for this semaphore is reclaimed by RTEMS.

NOTES:
------

The calling task will be preempted if it is enabled by the task's
execution mode and a higher priority local task is waiting on the
deleted semaphore.  The calling task will NOT be preempted if all of
the tasks that are waiting on the semaphore are remote tasks.

The calling task does not have to be the task that created the
semaphore.  Any local task that knows the semaphore id can delete the
semaphore.

When a global semaphore is deleted, the semaphore id must be
transmitted to every node in the system for deletion from the local
copy of the global object table.

The semaphore must reside on the local node, even if the semaphore was
created with the `RTEMS.GLOBAL' option.

Proxies, used to represent remote tasks, are reclaimed when the
semaphore is deleted.


File: ada_user.info,  Node: Semaphore Manager SEMAPHORE_OBTAIN - Acquire a semaphore,  Next: Semaphore Manager SEMAPHORE_RELEASE - Release a semaphore,  Prev: Semaphore Manager SEMAPHORE_DELETE - Delete a semaphore,  Up: Semaphore Manager Directives

9.4.4 SEMAPHORE_OBTAIN - Acquire a semaphore
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Semaphore_Obtain (
        ID         : in     RTEMS.ID;
        Option_Set : in     RTEMS.Option;
        Timeout    : in     RTEMS.Interval;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - semaphore obtained successfully
`RTEMS.UNSATISFIED' - semaphore not available
`RTEMS.TIMEOUT' - timed out waiting for semaphore
`RTEMS.OBJECT_WAS_DELETED' - semaphore deleted while waiting
`RTEMS.INVALID_ID' - invalid semaphore id

DESCRIPTION:
------------

This directive acquires the semaphore specified by id.  The
`RTEMS.WAIT' and `RTEMS.NO_WAIT' components of the options parameter
indicate whether the calling task wants to wait for the semaphore to
become available or return immediately if the semaphore is not
currently available.  With either `RTEMS.WAIT' or `RTEMS.NO_WAIT', if
the current semaphore count is positive, then it is decremented by one
and the semaphore is successfully acquired by returning immediately
with a successful return code.

If the calling task chooses to return immediately and the current
semaphore count is zero or negative, then a status code is returned
indicating that the semaphore is not available. If the calling task
chooses to wait for a semaphore and the current semaphore count is zero
or negative, then it is decremented by one and the calling task is
placed on the semaphore's wait queue and blocked.  If the semaphore was
created with the `RTEMS.PRIORITY' attribute, then the calling task is
inserted into the queue according to its priority.  However, if the
semaphore was created with the `RTEMS.FIFO' attribute, then the calling
task is placed at the rear of the wait queue.  If the binary semaphore
was created with the `RTEMS.INHERIT_PRIORITY' attribute, then the
priority of the task currently holding the binary semaphore is
guaranteed to be greater than or equal to that of the blocking task.
If the binary semaphore was created with the `RTEMS.PRIORITY_CEILING'
attribute, a task successfully obtains the semaphore, and the priority
of that task is greater than the ceiling priority for this semaphore,
then the priority of the task obtaining the semaphore is elevated to
that of the ceiling.

The timeout parameter specifies the maximum interval the calling task is
willing to be blocked waiting for the semaphore.  If it is set to
`RTEMS.NO_TIMEOUT', then the calling task will wait forever.  If the
semaphore is available or the `RTEMS.NO_WAIT' option component is set,
then timeout is ignored.

NOTES:
------

The following semaphore acquisition option constants are defined by
RTEMS:

   * `RTEMS.WAIT' - task will wait for semaphore (default)

   * `RTEMS.NO_WAIT' - task should not wait

Attempting to obtain a global semaphore which does not reside on the
local node will generate a request to the remote node to access the
semaphore.  If the semaphore is not available and `RTEMS.NO_WAIT' was
not specified, then the task must be blocked until the semaphore is
released.  A proxy is allocated on the remote node to represent the task
until the semaphore is released.

A clock tick is required to support the timeout functionality of this
directive.


File: ada_user.info,  Node: Semaphore Manager SEMAPHORE_RELEASE - Release a semaphore,  Next: Semaphore Manager SEMAPHORE_FLUSH - Unblock all tasks waiting on a semaphore,  Prev: Semaphore Manager SEMAPHORE_OBTAIN - Acquire a semaphore,  Up: Semaphore Manager Directives

9.4.5 SEMAPHORE_RELEASE - Release a semaphore
---------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Semaphore_Release (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - semaphore released successfully
`RTEMS.INVALID_ID' - invalid semaphore id
`RTEMS.NOT_OWNER_OF_RESOURCE' - calling task does not own semaphore

DESCRIPTION:
------------

This directive releases the semaphore specified by id.  The semaphore
count is incremented by one.  If the count is zero or negative, then
the first task on this semaphore's wait queue is removed and unblocked.
The unblocked task may preempt the running task if the running task's
preemption mode is enabled and the unblocked task has a higher priority
than the running task.

NOTES:
------

The calling task may be preempted if it causes a higher priority task
to be made ready for execution.

Releasing a global semaphore which does not reside on the local node
will generate a request telling the remote node to release the
semaphore.

If the task to be unblocked resides on a different node from the
semaphore, then the semaphore allocation is forwarded to the
appropriate node, the waiting task is unblocked, and the proxy used to
represent the task is reclaimed.

The outermost release of a local, binary, priority inheritance or
priority ceiling semaphore may result in the calling task having its
priority lowered.  This will occur if the calling task holds no other
binary semaphores and it has inherited a higher priority.


File: ada_user.info,  Node: Semaphore Manager SEMAPHORE_FLUSH - Unblock all tasks waiting on a semaphore,  Next: Message Manager,  Prev: Semaphore Manager SEMAPHORE_RELEASE - Release a semaphore,  Up: Semaphore Manager Directives

9.4.6 SEMAPHORE_FLUSH - Unblock all tasks waiting on a semaphore
----------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Semaphore_Flush (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - semaphore released successfully
`RTEMS.INVALID_ID' - invalid semaphore id
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - not supported for remote semaphores

DESCRIPTION:
------------

This directive unblocks all tasks waiting on the semaphore specified by
id.  Since there are tasks blocked on the semaphore, the semaphore's
count is not changed by this directive and thus is zero before and
after this directive is executed.  Tasks which are unblocked as the
result of this directive will return from the `rtems.semaphore_obtain'
directive with a status code of `RTEMS.UNSATISFIED' to indicate that
the semaphore was not obtained.

This directive may unblock any number of tasks.  Any of the unblocked
tasks may preempt the running task if the running task's preemption
mode is enabled and an unblocked task has a higher priority than the
running task.

NOTES:
------

The calling task may be preempted if it causes a higher priority task
to be made ready for execution.

If the task to be unblocked resides on a different node from the
semaphore, then the waiting task is unblocked, and the proxy used to
represent the task is reclaimed.


File: ada_user.info,  Node: Message Manager,  Next: Message Manager Introduction,  Prev: Semaphore Manager SEMAPHORE_FLUSH - Unblock all tasks waiting on a semaphore,  Up: Top

10 Message Manager
******************

* Menu:

* Message Manager Introduction::
* Message Manager Background::
* Message Manager Operations::
* Message Manager Directives::


File: ada_user.info,  Node: Message Manager Introduction,  Next: Message Manager Background,  Prev: Message Manager,  Up: Message Manager

10.1 Introduction
=================

The message manager provides communication and synchronization
capabilities using RTEMS message queues.  The directives provided by
the message manager are:

   * `rtems.message_queue_create' - Create a queue

   * `rtems.message_queue_ident' - Get ID of a queue

   * `rtems.message_queue_delete' - Delete a queue

   * `rtems.message_queue_send' - Put message at rear of a queue

   * `rtems.message_queue_urgent' - Put message at front of a queue

   * `rtems.message_queue_broadcast' - Broadcast N messages to a queue

   * `rtems.message_queue_receive' - Receive message from a queue

   * `rtems.message_queue_get_number_pending' - Get number of messages
     pending on a queue

   * `rtems.message_queue_flush' - Flush all messages on a queue


File: ada_user.info,  Node: Message Manager Background,  Next: Message Manager Messages,  Prev: Message Manager Introduction,  Up: Message Manager

10.2 Background
===============

* Menu:

* Message Manager Messages::
* Message Manager Message Queues::
* Message Manager Building a Message Queue Attribute Set::
* Message Manager Building a MESSAGE_QUEUE_RECEIVE Option Set::


File: ada_user.info,  Node: Message Manager Messages,  Next: Message Manager Message Queues,  Prev: Message Manager Background,  Up: Message Manager Background

10.2.1 Messages
---------------

A message is a variable length buffer where information can be stored
to support communication.  The length of the message and the
information stored in that message are user-defined and can be actual
data, pointer(s), or empty.


File: ada_user.info,  Node: Message Manager Message Queues,  Next: Message Manager Building a Message Queue Attribute Set,  Prev: Message Manager Messages,  Up: Message Manager Background

10.2.2 Message Queues
---------------------

A message queue permits the passing of messages among tasks and ISRs.
Message queues can contain a variable number of messages.  Normally
messages are sent to and received from the queue in FIFO order using
the `rtems.message_queue_send' directive.  However, the
`rtems.message_queue_urgent' directive can be used to place messages at
the head of a queue in LIFO order.

Synchronization can be accomplished when a task can wait for a message
to arrive at a queue.  Also, a task may poll a queue for the arrival of
a message.

The maximum length message which can be sent is set on a per message
queue basis.


File: ada_user.info,  Node: Message Manager Building a Message Queue Attribute Set,  Next: Message Manager Building a MESSAGE_QUEUE_RECEIVE Option Set,  Prev: Message Manager Message Queues,  Up: Message Manager Background

10.2.3 Building a Message Queue Attribute Set
---------------------------------------------

In general, an attribute set is built by a bitwise OR of the desired
attribute components.  The set of valid message queue attributes is
provided in the following table:

   * `RTEMS.FIFO' - tasks wait by FIFO (default)

   * `RTEMS.PRIORITY' - tasks wait by priority

   * `RTEMS.LOCAL' - local message queue (default)

   * `RTEMS.GLOBAL' - global message queue

An attribute listed as a default is not required to appear in the
attribute list, although it is a good programming practice to specify
default attributes.  If all defaults are desired, the attribute
`RTEMS.DEFAULT_ATTRIBUTES' should be specified on this call.

This example demonstrates the attribute_set parameter needed to create
a local message queue with the task priority waiting queue discipline.
The attribute_set parameter to the `rtems.message_queue_create'
directive could be either `RTEMS.PRIORITY' or `RTEMS.LOCAL or
RTEMS.PRIORITY'.  The attribute_set parameter can be set to
`RTEMS.PRIORITY' because `RTEMS.LOCAL' is the default for all created
message queues.  If a similar message queue were to be known globally,
then the attribute_set parameter would be `RTEMS.GLOBAL or
RTEMS.PRIORITY'.


File: ada_user.info,  Node: Message Manager Building a MESSAGE_QUEUE_RECEIVE Option Set,  Next: Message Manager Operations,  Prev: Message Manager Building a Message Queue Attribute Set,  Up: Message Manager Background

10.2.4 Building a MESSAGE_QUEUE_RECEIVE Option Set
--------------------------------------------------

In general, an option is built by a bitwise OR of the desired option
components.  The set of valid options for the
`rtems.message_queue_receive' directive are listed in the following
table:

   * `RTEMS.WAIT' - task will wait for a message (default)

   * `RTEMS.NO_WAIT' - task should not wait

An option listed as a default is not required to appear in the option
OR list, although it is a good programming practice to specify default
options.  If all defaults are desired, the option
`RTEMS.DEFAULT_OPTIONS' should be specified on this call.

This example demonstrates the option parameter needed to poll for a
message to arrive.  The option parameter passed to the
`rtems.message_queue_receive' directive should be `RTEMS.NO_WAIT'.


File: ada_user.info,  Node: Message Manager Operations,  Next: Message Manager Creating a Message Queue,  Prev: Message Manager Building a MESSAGE_QUEUE_RECEIVE Option Set,  Up: Message Manager

10.3 Operations
===============

* Menu:

* Message Manager Creating a Message Queue::
* Message Manager Obtaining Message Queue IDs::
* Message Manager Receiving a Message::
* Message Manager Sending a Message::
* Message Manager Broadcasting a Message::
* Message Manager Deleting a Message Queue::


File: ada_user.info,  Node: Message Manager Creating a Message Queue,  Next: Message Manager Obtaining Message Queue IDs,  Prev: Message Manager Operations,  Up: Message Manager Operations

10.3.1 Creating a Message Queue
-------------------------------

The `rtems.message_queue_create' directive creates a message queue with
the user-defined name.  The user specifies the maximum message size and
maximum number of messages which can be placed in the message queue at
one time.  The user may select FIFO or task priority as the method for
placing waiting tasks in the task wait queue.  RTEMS allocates a Queue
Control Block (QCB) from the QCB free list to maintain the newly
created queue as well as memory for the message buffer pool associated
with this message queue.  RTEMS also generates a message queue ID which
is returned to the calling task.

For GLOBAL message queues, the maximum message size is effectively
limited to the longest message which the MPCI is capable of
transmitting.


File: ada_user.info,  Node: Message Manager Obtaining Message Queue IDs,  Next: Message Manager Receiving a Message,  Prev: Message Manager Creating a Message Queue,  Up: Message Manager Operations

10.3.2 Obtaining Message Queue IDs
----------------------------------

When a message queue is created, RTEMS generates a unique message queue
ID.  The message queue ID may be obtained by either of two methods.
First, as the result of an invocation of the
`rtems.message_queue_create' directive, the queue ID is stored in a
user provided location.  Second, the queue ID may be obtained later
using the `rtems.message_queue_ident' directive.  The queue ID is used
by other message manager directives to access this message queue.


File: ada_user.info,  Node: Message Manager Receiving a Message,  Next: Message Manager Sending a Message,  Prev: Message Manager Obtaining Message Queue IDs,  Up: Message Manager Operations

10.3.3 Receiving a Message
--------------------------

The `rtems.message_queue_receive' directive attempts to retrieve a
message from the specified message queue.  If at least one message is
in the queue, then the message is removed from the queue, copied to the
caller's message buffer, and returned immediately along with the length
of the message.  When messages are unavailable, one of the following
situations applies:

   * By default, the calling task will wait forever for the message to
     arrive.

   * Specifying the `RTEMS.NO_WAIT' option forces an immediate return
     with an error status code.

   * Specifying a timeout limits the period the task will wait before
     returning with an error status.

If the task waits for a message, then it is placed in the message
queue's task wait queue in either FIFO or task priority order.  All
tasks waiting on a message queue are returned an error code when the
message queue is deleted.


File: ada_user.info,  Node: Message Manager Sending a Message,  Next: Message Manager Broadcasting a Message,  Prev: Message Manager Receiving a Message,  Up: Message Manager Operations

10.3.4 Sending a Message
------------------------

Messages can be sent to a queue with the `rtems.message_queue_send' and
`rtems.message_queue_urgent' directives.  These directives work
identically when tasks are waiting to receive a message.  A task is
removed from the task waiting queue, unblocked,  and the message is
copied to a waiting task's message buffer.

When no tasks are waiting at the queue, `rtems.message_queue_send'
places the message at the rear of the message queue, while
`rtems.message_queue_urgent' places the message at the front of the
queue.  The message is copied to a message buffer from this message
queue's buffer pool and then placed in the message queue.  Neither
directive can successfully send a message to a message queue which has
a full queue of pending messages.


File: ada_user.info,  Node: Message Manager Broadcasting a Message,  Next: Message Manager Deleting a Message Queue,  Prev: Message Manager Sending a Message,  Up: Message Manager Operations

10.3.5 Broadcasting a Message
-----------------------------

The `rtems.message_queue_broadcast' directive sends the same message to
every task waiting on the specified message queue as an atomic
operation.  The message is copied to each waiting task's message buffer
and each task is unblocked.  The number of tasks which were unblocked
is returned to the caller.


File: ada_user.info,  Node: Message Manager Deleting a Message Queue,  Next: Message Manager Directives,  Prev: Message Manager Broadcasting a Message,  Up: Message Manager Operations

10.3.6 Deleting a Message Queue
-------------------------------

The `rtems.message_queue_delete' directive removes a message queue from
the system and frees its control block as well as the memory associated
with this message queue's message buffer pool.  A message queue can be
deleted by any local task that knows the message queue's ID.  As a
result of this directive, all tasks blocked waiting to receive a
message from the message queue will be readied and returned a status
code which indicates that the message queue was deleted.  Any
subsequent references to the message queue's name and ID are invalid.
Any messages waiting at the message queue are also deleted and
deallocated.


File: ada_user.info,  Node: Message Manager Directives,  Next: Message Manager MESSAGE_QUEUE_CREATE - Create a queue,  Prev: Message Manager Deleting a Message Queue,  Up: Message Manager

10.4 Directives
===============

* Menu:

* Message Manager MESSAGE_QUEUE_CREATE - Create a queue::
* Message Manager MESSAGE_QUEUE_IDENT - Get ID of a queue::
* Message Manager MESSAGE_QUEUE_DELETE - Delete a queue::
* Message Manager MESSAGE_QUEUE_SEND - Put message at rear of a queue::
* Message Manager MESSAGE_QUEUE_URGENT - Put message at front of a queue::
* Message Manager MESSAGE_QUEUE_BROADCAST - Broadcast N messages to a queue::
* Message Manager MESSAGE_QUEUE_RECEIVE - Receive message from a queue::
* Message Manager MESSAGE_QUEUE_GET_NUMBER_PENDING - Get number of messages pending on a queue::
* Message Manager MESSAGE_QUEUE_FLUSH - Flush all messages on a queue::

This section details the message manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_CREATE - Create a queue,  Next: Message Manager MESSAGE_QUEUE_IDENT - Get ID of a queue,  Prev: Message Manager Directives,  Up: Message Manager Directives

10.4.1 MESSAGE_QUEUE_CREATE - Create a queue
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Create (
        Name             : in     RTEMS.Name;
        Count            : in     RTEMS.Unsigned32;
        Max_Message_Size : in     RTEMS.Unsigned32;
        Attribute_Set    : in     RTEMS.Attribute;
        ID               :    out RTEMS.ID;
        Result           :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - queue created successfully
`RTEMS.INVALID_NAME' - invalid queue name
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NUMBER' - invalid message count
`RTEMS.INVALID_SIZE' - invalid message size
`RTEMS.TOO_MANY' - too many queues created
`RTEMS.UNSATISFIED' - unable to allocate message buffers
`RTEMS.MP_NOT_CONFIGURED' - multiprocessing not configured
`RTEMS.TOO_MANY' - too many global objects

DESCRIPTION:
------------

This directive creates a message queue which resides on the local node
with the user-defined name specified in name.  For control and
maintenance of the queue, RTEMS allocates and initializes a QCB.
Memory is allocated from the RTEMS Workspace for the specified count of
messages, each of max_message_size bytes in length.  The RTEMS-assigned
queue id, returned in id, is used to access the message queue.

Specifying `RTEMS.PRIORITY' in attribute_set causes tasks waiting for a
message to be serviced according to task priority.  When `RTEMS.FIFO'
is specified, waiting tasks are serviced in First In-First Out order.

NOTES:
------

This directive will not cause the calling task to be preempted.

The following message queue attribute constants are defined by RTEMS:

   * `RTEMS.FIFO' - tasks wait by FIFO (default)

   * `RTEMS.PRIORITY' - tasks wait by priority

   * `RTEMS.LOCAL' - local message queue (default)

   * `RTEMS.GLOBAL' - global message queue

Message queues should not be made global unless remote tasks must
interact with the created message queue.  This is to avoid the system
overhead incurred by the creation of a global message queue.  When a
global message queue is created, the message queue's name and id must
be transmitted to every node in the system for insertion in the local
copy of the global object table.

For GLOBAL message queues, the maximum message size is effectively
limited to the longest message which the MPCI is capable of
transmitting.

The total number of global objects, including message queues, is
limited by the maximum_global_objects field in the configuration table.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_IDENT - Get ID of a queue,  Next: Message Manager MESSAGE_QUEUE_DELETE - Delete a queue,  Prev: Message Manager MESSAGE_QUEUE_CREATE - Create a queue,  Up: Message Manager Directives

10.4.2 MESSAGE_QUEUE_IDENT - Get ID of a queue
----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Ident (
        Name   : in     RTEMS.Name;
        Node   : in     RTEMS.Unsigned32;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - queue identified successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - queue name not found
`RTEMS.INVALID_NODE' - invalid node id

DESCRIPTION:
------------

This directive obtains the queue id associated with the queue name
specified in name.  If the queue name is not unique, then the queue id
will match one of the queues with that name.  However, this queue id is
not guaranteed to correspond to the desired queue.  The queue id is
used with other message related directives to access the message queue.

NOTES:
------

This directive will not cause the running task to be preempted.

If node is `RTEMS.SEARCH_ALL_NODES', all nodes are searched with the
local node being searched first.  All other nodes are searched with the
lowest numbered node searched first.

If node is a valid node number which does not represent the local node,
then only the message queues exported by the designated node are
searched.

This directive does not generate activity on remote nodes.  It accesses
only the local copy of the global object table.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_DELETE - Delete a queue,  Next: Message Manager MESSAGE_QUEUE_SEND - Put message at rear of a queue,  Prev: Message Manager MESSAGE_QUEUE_IDENT - Get ID of a queue,  Up: Message Manager Directives

10.4.3 MESSAGE_QUEUE_DELETE - Delete a queue
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - queue deleted successfully
`RTEMS.INVALID_ID' - invalid queue id
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - cannot delete remote queue

DESCRIPTION:
------------

This directive deletes the message queue specified by id.  As a result
of this directive, all tasks blocked waiting to receive a message from
this queue will be readied and returned a status code which indicates
that the message queue was deleted.  If no tasks are waiting, but the
queue contains messages, then RTEMS returns these message buffers back
to the system message buffer pool.  The QCB for this queue as well as
the memory for the message buffers is reclaimed by RTEMS.

NOTES:
------

The calling task will be preempted if its preemption mode is enabled
and one or more local tasks with a higher priority than the calling
task are waiting on the deleted queue.  The calling task will NOT be
preempted if the tasks that are waiting are remote tasks.

The calling task does not have to be the task that created the queue,
although the task and queue must reside on the same node.

When the queue is deleted, any messages in the queue are returned to
the free message buffer pool.  Any information stored in those messages
is lost.

When a global message queue is deleted, the message queue id must be
transmitted to every node in the system for deletion from the local
copy of the global object table.

Proxies, used to represent remote tasks, are reclaimed when the message
queue is deleted.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_SEND - Put message at rear of a queue,  Next: Message Manager MESSAGE_QUEUE_URGENT - Put message at front of a queue,  Prev: Message Manager MESSAGE_QUEUE_DELETE - Delete a queue,  Up: Message Manager Directives

10.4.4 MESSAGE_QUEUE_SEND - Put message at rear of a queue
----------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Send (
        ID     : in     RTEMS.ID;
        Buffer : in     RTEMS.Address;
        Size   : in     RTEMS.Unsigned32;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - message sent successfully
`RTEMS.INVALID_ID' - invalid queue id
`RTEMS.INVALID_SIZE' - invalid message size
`RTEMS.INVALID_ADDRESS' - `buffer' is NULL
`RTEMS.UNSATISFIED' - out of message buffers
`RTEMS.TOO_MANY' - queue's limit has been reached

DESCRIPTION:
------------

This directive sends the message buffer of size bytes in length to the
queue specified by id.  If a task is waiting at the queue, then the
message is copied to the waiting task's buffer and the task is
unblocked. If no tasks are waiting at the queue, then the message is
copied to a message buffer which is obtained from this message queue's
message buffer pool.  The message buffer is then placed at the rear of
the queue.

NOTES:
------

The calling task will be preempted if it has preemption enabled and a
higher priority task is unblocked as the result of this directive.

Sending a message to a global message queue which does not reside on
the local node will generate a request to the remote node to post the
message on the specified message queue.

If the task to be unblocked resides on a different node from the
message queue, then the message is forwarded to the appropriate node,
the waiting task is unblocked, and the proxy used to represent the task
is reclaimed.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_URGENT - Put message at front of a queue,  Next: Message Manager MESSAGE_QUEUE_BROADCAST - Broadcast N messages to a queue,  Prev: Message Manager MESSAGE_QUEUE_SEND - Put message at rear of a queue,  Up: Message Manager Directives

10.4.5 MESSAGE_QUEUE_URGENT - Put message at front of a queue
-------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Urgent (
        ID     : in     RTEMS.ID;
        Buffer : in     RTEMS.Address;
        Size   : in     RTEMS.Unsigned32;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - message sent successfully
`RTEMS.INVALID_ID' - invalid queue id
`RTEMS.INVALID_SIZE' - invalid message size
`RTEMS.INVALID_ADDRESS' - `buffer' is NULL
`RTEMS.UNSATISFIED' - out of message buffers
`RTEMS.TOO_MANY' - queue's limit has been reached

DESCRIPTION:
------------

This directive sends the message buffer of size bytes in length to the
queue specified by id.  If a task is waiting on the queue, then the
message is copied to the task's buffer and the task is unblocked.  If
no tasks are waiting on the queue, then the message is copied to a
message buffer which is obtained from this message queue's message
buffer pool.  The message buffer is then placed at the front of the
queue.

NOTES:
------

The calling task will be preempted if it has preemption enabled and a
higher priority task is unblocked as the result of this directive.

Sending a message to a global message queue which does not reside on
the local node will generate a request telling the remote node to post
the message on the specified message queue.

If the task to be unblocked resides on a different node from the
message queue, then the message is forwarded to the appropriate node,
the waiting task is unblocked, and the proxy used to represent the task
is reclaimed.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_BROADCAST - Broadcast N messages to a queue,  Next: Message Manager MESSAGE_QUEUE_RECEIVE - Receive message from a queue,  Prev: Message Manager MESSAGE_QUEUE_URGENT - Put message at front of a queue,  Up: Message Manager Directives

10.4.6 MESSAGE_QUEUE_BROADCAST - Broadcast N messages to a queue
----------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Broadcast (
        ID     : in     RTEMS.ID;
        Buffer : in     RTEMS.Address;
        Size   : in     RTEMS.Unsigned32;
        Count  :    out RTEMS.Unsigned32;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - message broadcasted successfully
`RTEMS.INVALID_ID' - invalid queue id
`RTEMS.INVALID_ADDRESS' - `buffer' is NULL
`RTEMS.INVALID_ADDRESS' - `count' is NULL
`RTEMS.INVALID_SIZE' - invalid message size

DESCRIPTION:
------------

This directive causes all tasks that are waiting at the queue specified
by id to be unblocked and sent the message contained in buffer.  Before
a task is unblocked, the message buffer of size byes in length is
copied to that task's message buffer.  The number of tasks that were
unblocked is returned in count.

NOTES:
------

The calling task will be preempted if it has preemption enabled and a
higher priority task is unblocked as the result of this directive.

The execution time of this directive is directly related to the number
of tasks waiting on the message queue, although it is more efficient
than the equivalent number of invocations of `rtems.message_queue_send'.

Broadcasting a message to a global message queue which does not reside
on the local node will generate a request telling the remote node to
broadcast the message to the specified message queue.

When a task is unblocked which resides on a different node from the
message queue, a copy of the message is forwarded to the appropriate
node,  the waiting task is unblocked, and the proxy used to represent
the task is reclaimed.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_RECEIVE - Receive message from a queue,  Next: Message Manager MESSAGE_QUEUE_GET_NUMBER_PENDING - Get number of messages pending on a queue,  Prev: Message Manager MESSAGE_QUEUE_BROADCAST - Broadcast N messages to a queue,  Up: Message Manager Directives

10.4.7 MESSAGE_QUEUE_RECEIVE - Receive message from a queue
-----------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Receive (
        ID         : in     RTEMS.ID;
        Buffer     : in     RTEMS.Address;
        Option_Set : in     RTEMS.Option;
        Timeout    : in     RTEMS.Interval;
        Size       :    out RTEMS.Unsigned32;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - message received successfully
`RTEMS.INVALID_ID' - invalid queue id
`RTEMS.INVALID_ADDRESS' - `buffer' is NULL
`RTEMS.INVALID_ADDRESS' - `size' is NULL
`RTEMS.UNSATISFIED' - queue is empty
`RTEMS.TIMEOUT' - timed out waiting for message
`RTEMS.OBJECT_WAS_DELETED' - queue deleted while waiting

DESCRIPTION:
------------

This directive receives a message from the message queue specified in
id.  The `RTEMS.WAIT' and `RTEMS.NO_WAIT' options of the options
parameter allow the calling task to specify whether to wait for a
message to become available or return immediately.  For either option,
if there is at least one message in the queue, then it is copied to
buffer, size is set to return the length of the message in bytes, and
this directive returns immediately with a successful return code.  The
buffer has to be big enough to receive a message of the maximum length
with respect to this message queue.

If the calling task chooses to return immediately and the queue is
empty, then a status code indicating this condition is returned.  If
the calling task chooses to wait at the message queue and the queue is
empty, then the calling task is placed on the message wait queue and
blocked.  If the queue was created with the `RTEMS.PRIORITY' option
specified, then the calling task is inserted into the wait queue
according to its priority.  But, if the queue was created with the
`RTEMS.FIFO' option specified, then the calling task is placed at the
rear of the wait queue.

A task choosing to wait at the queue can optionally specify a timeout
value in the timeout parameter.  The timeout parameter specifies the
maximum interval to wait before the calling task desires to be
unblocked.  If it is set to `RTEMS.NO_TIMEOUT', then the calling task
will wait forever.

NOTES:
------

The following message receive option constants are defined by RTEMS:

   * `RTEMS.WAIT' - task will wait for a message (default)

   * `RTEMS.NO_WAIT' - task should not wait

Receiving a message from a global message queue which does not reside
on the local node will generate a request to the remote node to obtain
a message from the specified message queue.  If no message is available
and `RTEMS.WAIT' was specified, then the task must be blocked until a
message is posted.  A proxy is allocated on the remote node to
represent the task until the message is posted.

A clock tick is required to support the timeout functionality of this
directive.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_GET_NUMBER_PENDING - Get number of messages pending on a queue,  Next: Message Manager MESSAGE_QUEUE_FLUSH - Flush all messages on a queue,  Prev: Message Manager MESSAGE_QUEUE_RECEIVE - Receive message from a queue,  Up: Message Manager Directives

10.4.8 MESSAGE_QUEUE_GET_NUMBER_PENDING - Get number of messages pending on a queue
-----------------------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Get_Number_Pending (
        ID     : in     RTEMS.ID;
        Count  :    out RTEMS.Unsigned32;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - number of messages pending returned successfully
`RTEMS.INVALID_ADDRESS' - `count' is NULL
`RTEMS.INVALID_ID' - invalid queue id

DESCRIPTION:
------------

This directive returns the number of messages pending on this message
queue in count.  If no messages are present on the queue, count is set
to zero.

NOTES:
------

Getting the number of pending messages on a global message queue which
does not reside on the local node will generate a request to the remote
node to actually obtain the pending message count for the specified
message queue.


File: ada_user.info,  Node: Message Manager MESSAGE_QUEUE_FLUSH - Flush all messages on a queue,  Next: Event Manager,  Prev: Message Manager MESSAGE_QUEUE_GET_NUMBER_PENDING - Get number of messages pending on a queue,  Up: Message Manager Directives

10.4.9 MESSAGE_QUEUE_FLUSH - Flush all messages on a queue
----------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Message_Queue_Flush (
        ID     : in     RTEMS.ID;
        Count  :    out RTEMS.Unsigned32;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - message queue flushed successfully
`RTEMS.INVALID_ADDRESS' - `count' is NULL
`RTEMS.INVALID_ID' - invalid queue id

DESCRIPTION:
------------

This directive removes all pending messages from the specified queue
id.  The number of messages removed is returned in count.  If no
messages are present on the queue, count is set to zero.

NOTES:
------

Flushing all messages on a global message queue which does not reside
on the local node will generate a request to the remote node to
actually flush the specified message queue.


File: ada_user.info,  Node: Event Manager,  Next: Event Manager Introduction,  Prev: Message Manager MESSAGE_QUEUE_FLUSH - Flush all messages on a queue,  Up: Top

11 Event Manager
****************

* Menu:

* Event Manager Introduction::
* Event Manager Background::
* Event Manager Operations::
* Event Manager Directives::


File: ada_user.info,  Node: Event Manager Introduction,  Next: Event Manager Background,  Prev: Event Manager,  Up: Event Manager

11.1 Introduction
=================

The event manager provides a high performance method of intertask
communication and synchronization.  The directives provided by the
event manager are:

   * `rtems.event_send' - Send event set to a task

   * `rtems.event_receive' - Receive event condition


File: ada_user.info,  Node: Event Manager Background,  Next: Event Manager Event Sets,  Prev: Event Manager Introduction,  Up: Event Manager

11.2 Background
===============

* Menu:

* Event Manager Event Sets::
* Event Manager Building an Event Set or Condition::
* Event Manager Building an EVENT_RECEIVE Option Set::


File: ada_user.info,  Node: Event Manager Event Sets,  Next: Event Manager Building an Event Set or Condition,  Prev: Event Manager Background,  Up: Event Manager Background

11.2.1 Event Sets
-----------------

An event flag is used by a task (or ISR) to inform another task of the
occurrence of a significant situation.  Thirty-two event flags are
associated with each task.  A collection of one or more event flags is
referred to as an event set.  The data type `rtems.event_set' is used
to manage event sets.

The application developer should remember the following key
characteristics of event operations when utilizing the event manager:

   * Events provide a simple synchronization facility.

   * Events are aimed at tasks.

   * Tasks can wait on more than one event simultaneously.

   * Events are independent of one another.

   * Events do not hold or transport data.

   * Events are not queued.  In other words, if an event is sent more
     than once to a task before being received, the second and
     subsequent send operations to that same task have no effect.

An event set is posted when it is directed (or sent) to a task.  A
pending event is an event that has been posted but not received.  An
event condition is used to specify the event set which the task desires
to receive and the algorithm which will be used to determine when the
request is satisfied. An event condition is satisfied based upon one of
two algorithms which are selected by the user.  The `RTEMS.EVENT_ANY'
algorithm states that an event condition is satisfied when at least a
single requested event is posted.  The `RTEMS.EVENT_ALL' algorithm
states that an event condition is satisfied when every requested event
is posted.


File: ada_user.info,  Node: Event Manager Building an Event Set or Condition,  Next: Event Manager Building an EVENT_RECEIVE Option Set,  Prev: Event Manager Event Sets,  Up: Event Manager Background

11.2.2 Building an Event Set or Condition
-----------------------------------------

An event set or condition is built by a bitwise OR of the desired
events.  The set of valid events is `RTEMS.EVENT_0' through
`RTEMS.EVENT_31'.  If an event is not explicitly specified in the set or
condition, then it is not present.  Events are specifically designed to
be mutually exclusive, therefore bitwise OR and addition operations are
equivalent as long as each event appears exactly once in the event set
list.

For example, when sending the event set consisting of `RTEMS.EVENT_6',
`RTEMS.EVENT_15', and `RTEMS.EVENT_31', the event parameter to the
`rtems.event_send' directive should be `RTEMS.EVENT_6 or RTEMS.EVENT_15
or RTEMS.EVENT_31'.


File: ada_user.info,  Node: Event Manager Building an EVENT_RECEIVE Option Set,  Next: Event Manager Operations,  Prev: Event Manager Building an Event Set or Condition,  Up: Event Manager Background

11.2.3 Building an EVENT_RECEIVE Option Set
-------------------------------------------

In general, an option is built by a bitwise OR of the desired option
components.  The set of valid options for the `rtems.event_receive'
directive are listed in the following table:

   * `RTEMS.WAIT' - task will wait for event (default)

   * `RTEMS.NO_WAIT' - task should not wait

   * `RTEMS.EVENT_ALL' - return after all events (default)

   * `RTEMS.EVENT_ANY' - return after any events

Option values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each option appears exactly once in the component list.  An option
listed as a default is not required to appear in the option list,
although it is a good programming practice to specify default options.
If all defaults are desired, the option `RTEMS.DEFAULT_OPTIONS' should
be specified on this call.

This example demonstrates the option parameter needed to poll for all
events in a particular event condition to arrive.  The option parameter
passed to the `rtems.event_receive' directive should be either
`RTEMS.EVENT_ALL or RTEMS.NO_WAIT' or `RTEMS.NO_WAIT'.  The option
parameter can be set to `RTEMS.NO_WAIT' because `RTEMS.EVENT_ALL' is the
default condition for `rtems.event_receive'.


File: ada_user.info,  Node: Event Manager Operations,  Next: Event Manager Sending an Event Set,  Prev: Event Manager Building an EVENT_RECEIVE Option Set,  Up: Event Manager

11.3 Operations
===============

* Menu:

* Event Manager Sending an Event Set::
* Event Manager Receiving an Event Set::
* Event Manager Determining the Pending Event Set::
* Event Manager Receiving all Pending Events::


File: ada_user.info,  Node: Event Manager Sending an Event Set,  Next: Event Manager Receiving an Event Set,  Prev: Event Manager Operations,  Up: Event Manager Operations

11.3.1 Sending an Event Set
---------------------------

The `rtems.event_send' directive allows a task (or an ISR) to direct an
event set to a target task.  Based upon the state of the target task,
one of the following situations applies:

   * Target Task is Blocked Waiting for Events

        - If the waiting task's input event condition is satisfied,
          then the task is made ready for execution.

        - If the waiting task's input event condition is not satisfied,
          then the event set is posted but left pending and the task
          remains blocked.


   * Target Task is Not Waiting for Events

        - The event set is posted and left pending.



File: ada_user.info,  Node: Event Manager Receiving an Event Set,  Next: Event Manager Determining the Pending Event Set,  Prev: Event Manager Sending an Event Set,  Up: Event Manager Operations

11.3.2 Receiving an Event Set
-----------------------------

The `rtems.event_receive' directive is used by tasks to accept a
specific input event condition.  The task also specifies whether the
request is satisfied when all requested events are available or any
single requested event is available.  If the requested event condition
is satisfied by pending events, then a successful return code and the
satisfying event set are returned immediately.  If the condition is not
satisfied, then one of the following situations applies:

   * By default, the calling task will wait forever for the event
     condition to be satisfied.

   * Specifying the `RTEMS.NO_WAIT' option forces an immediate return
     with an error status code.

   * Specifying a timeout limits the period the task will wait before
     returning with an error status code.


File: ada_user.info,  Node: Event Manager Determining the Pending Event Set,  Next: Event Manager Receiving all Pending Events,  Prev: Event Manager Receiving an Event Set,  Up: Event Manager Operations

11.3.3 Determining the Pending Event Set
----------------------------------------

A task can determine the pending event set by calling the
`rtems.event_receive' directive with a value of `RTEMS.PENDING_EVENTS'
for the input event condition.  The pending events are returned to the
calling task but the event set is left unaltered.


File: ada_user.info,  Node: Event Manager Receiving all Pending Events,  Next: Event Manager Directives,  Prev: Event Manager Determining the Pending Event Set,  Up: Event Manager Operations

11.3.4 Receiving all Pending Events
-----------------------------------

A task can receive all of the currently pending events by calling the
`rtems.event_receive' directive with a value of `RTEMS.ALL_EVENTS' for
the input event condition and `RTEMS.NO_WAIT or RTEMS.EVENT_ANY' for
the option set.  The pending events are returned to the calling task
and the event set is cleared.  If no events are pending then the
`RTEMS.UNSATISFIED' status code will be returned.


File: ada_user.info,  Node: Event Manager Directives,  Next: Event Manager EVENT_SEND - Send event set to a task,  Prev: Event Manager Receiving all Pending Events,  Up: Event Manager

11.4 Directives
===============

* Menu:

* Event Manager EVENT_SEND - Send event set to a task::
* Event Manager EVENT_RECEIVE - Receive event condition::

This section details the event manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Event Manager EVENT_SEND - Send event set to a task,  Next: Event Manager EVENT_RECEIVE - Receive event condition,  Prev: Event Manager Directives,  Up: Event Manager Directives

11.4.1 EVENT_SEND - Send event set to a task
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Event_Send (
        ID       : in     RTEMS.ID;
        Event_In : in     RTEMS.Event_Set;
        Result   :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - event set sent successfully
`RTEMS.INVALID_ID' - invalid task id

DESCRIPTION:
------------

This directive sends an event set, event_in, to the task specified by
id.  If a blocked task's input event condition is satisfied by this
directive, then it will be made ready.  If its input event condition is
not satisfied, then the events satisfied are updated and the events not
satisfied are left pending.  If the task specified by id is not blocked
waiting for events, then the events sent are left pending.

NOTES:
------

Specifying `RTEMS.SELF' for id results in the event set being sent to
the calling task.

Identical events sent to a task are not queued.  In other words, the
second, and subsequent, posting of an event to a task before it can
perform an `rtems.event_receive' has no effect.

The calling task will be preempted if it has preemption enabled and a
higher priority task is unblocked as the result of this directive.

Sending an event set to a global task which does not reside on the
local node will generate a request telling the remote node to send the
event set to the appropriate task.


File: ada_user.info,  Node: Event Manager EVENT_RECEIVE - Receive event condition,  Next: Signal Manager,  Prev: Event Manager EVENT_SEND - Send event set to a task,  Up: Event Manager Directives

11.4.2 EVENT_RECEIVE - Receive event condition
----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Event_Receive (
        Event_In   : in     RTEMS.Event_Set;
        Option_Set : in     RTEMS.Option;
        Ticks      : in     RTEMS.Interval;
        Event_Out  :    out RTEMS.Event_Set;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - event received successfully
`RTEMS.UNSATISFIED' - input event not satisfied (`RTEMS.NO_WAIT')
`RTEMS.INVALID_ADDRESS' - `event_out' is NULL
`RTEMS.TIMEOUT' - timed out waiting for event

DESCRIPTION:
------------

This directive attempts to receive the event condition specified in
event_in.  If event_in is set to `RTEMS.PENDING_EVENTS', then the
current pending events are returned in event_out and left pending.  The
`RTEMS.WAIT' and `RTEMS.NO_WAIT' options in the option_set parameter
are used to specify whether or not the task is willing to wait for the
event condition to be satisfied.  `RTEMS.EVENT_ANY' and
`RTEMS.EVENT_ALL' are used in the option_set parameter are used to
specify whether a single event or the complete event set is necessary
to satisfy the event condition.  The event_out parameter is returned to
the calling task with the value that corresponds to the events in
event_in that were satisfied.

If pending events satisfy the event condition, then event_out is set to
the satisfied events and the pending events in the event condition are
cleared.  If the event condition is not satisfied and `RTEMS.NO_WAIT'
is specified, then event_out is set to the currently satisfied events.
If the calling task chooses to wait, then it will block waiting for the
event condition.

If the calling task must wait for the event condition to be satisfied,
then the timeout parameter is used to specify the maximum interval to
wait.  If it is set to `RTEMS.NO_TIMEOUT', then the calling task will
wait forever.

NOTES:
------

This directive only affects the events specified in event_in.  Any
pending events that do not correspond to any of the events specified in
event_in will be left pending.

The following event receive option constants are defined by RTEMS:

   * `RTEMS.WAIT' 	task will wait for event (default)

   * `RTEMS.NO_WAIT' 	task should not wait

   * `RTEMS.EVENT_ALL' 	return after all events (default)

   * `RTEMS.EVENT_ANY' 	return after any events

A clock tick is required to support the functionality of this directive.


File: ada_user.info,  Node: Signal Manager,  Next: Signal Manager Introduction,  Prev: Event Manager EVENT_RECEIVE - Receive event condition,  Up: Top

12 Signal Manager
*****************

* Menu:

* Signal Manager Introduction::
* Signal Manager Background::
* Signal Manager Operations::
* Signal Manager Directives::


File: ada_user.info,  Node: Signal Manager Introduction,  Next: Signal Manager Background,  Prev: Signal Manager,  Up: Signal Manager

12.1 Introduction
=================

The signal manager provides the capabilities required for asynchronous
communication.  The directives provided by the signal manager are:

   * `rtems.signal_catch' - Establish an ASR

   * `rtems.signal_send' - Send signal set to a task


File: ada_user.info,  Node: Signal Manager Background,  Next: Signal Manager Signal Manager Definitions,  Prev: Signal Manager Introduction,  Up: Signal Manager

12.2 Background
===============

* Menu:

* Signal Manager Signal Manager Definitions::
* Signal Manager A Comparison of ASRs and ISRs::
* Signal Manager Building a Signal Set::
* Signal Manager Building an ASR Mode::


File: ada_user.info,  Node: Signal Manager Signal Manager Definitions,  Next: Signal Manager A Comparison of ASRs and ISRs,  Prev: Signal Manager Background,  Up: Signal Manager Background

12.2.1 Signal Manager Definitions
---------------------------------

The signal manager allows a task to optionally define an asynchronous
signal routine (ASR).  An ASR is to a task what an ISR is to an
application's set of tasks.  When the processor is interrupted, the
execution of an application is also interrupted and an ISR is given
control.  Similarly, when a signal is sent to a task, that task's
execution path will be "interrupted" by the ASR.  Sending a signal to a
task has no effect on the receiving task's current execution state.

A signal flag is used by a task (or ISR) to inform another task of the
occurrence of a significant situation.  Thirty-two signal flags are
associated with each task.  A collection of one or more signals is
referred to as a signal set.  The data type `rtems.signal_set' is used
to manipulate signal sets.

A signal set is posted when it is directed (or sent) to a task. A
pending signal is a signal that has been sent to a task with a valid
ASR, but has not been processed by that task's ASR.


File: ada_user.info,  Node: Signal Manager A Comparison of ASRs and ISRs,  Next: Signal Manager Building a Signal Set,  Prev: Signal Manager Signal Manager Definitions,  Up: Signal Manager Background

12.2.2 A Comparison of ASRs and ISRs
------------------------------------

The format of an ASR is similar to that of an ISR with the following
exceptions:

   * ISRs are scheduled by the processor hardware.  ASRs are scheduled
     by RTEMS.

   * ISRs do not execute in the context of a task and may invoke only a
     subset of directives.  ASRs execute in the context of a task and
     may execute any directive.

   * When an ISR is invoked, it is passed the vector number as its
     argument.  When an ASR is invoked, it is passed the signal set as
     its argument.

   * An ASR has a task mode which can be different from that of the
     task.  An ISR does not execute as a task and, as a result, does
     not have a task mode.


File: ada_user.info,  Node: Signal Manager Building a Signal Set,  Next: Signal Manager Building an ASR Mode,  Prev: Signal Manager A Comparison of ASRs and ISRs,  Up: Signal Manager Background

12.2.3 Building a Signal Set
----------------------------

A signal set is built by a bitwise OR of the desired signals.  The set
of valid signals is `RTEMS.SIGNAL_0' through `RTEMS.SIGNAL_31'.  If a
signal is not explicitly specified in the signal set, then it is not
present.  Signal values are specifically designed to be mutually
exclusive, therefore bitwise OR and addition operations are equivalent
as long as each signal appears exactly once in the component list.

This example demonstrates the signal parameter used when sending the
signal set consisting of `RTEMS.SIGNAL_6', `RTEMS.SIGNAL_15', and
`RTEMS.SIGNAL_31'.  The signal parameter provided to the
`rtems.signal_send' directive should be `RTEMS.SIGNAL_6 or
RTEMS.SIGNAL_15 or RTEMS.SIGNAL_31'.


File: ada_user.info,  Node: Signal Manager Building an ASR Mode,  Next: Signal Manager Operations,  Prev: Signal Manager Building a Signal Set,  Up: Signal Manager Background

12.2.4 Building an ASR Mode
---------------------------

In general, an ASR's mode is built by a bitwise OR of the desired mode
components.  The set of valid mode components is the same as those
allowed with the task_create and task_mode directives.  A complete list
of mode options is provided in the following table:

   * `RTEMS.PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and enables
     preemption

   * `RTEMS.NO_PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and disables
     preemption

   * `RTEMS.NO_TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and
     disables timeslicing

   * `RTEMS.TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and enables
     timeslicing

   * `RTEMS.ASR' is masked by `RTEMS.ASR_MASK' and enables ASR
     processing

   * `RTEMS.NO_ASR' is masked by `RTEMS.ASR_MASK' and disables ASR
     processing

   * `RTEMS.INTERRUPT_LEVEL(0)' is masked by `RTEMS.INTERRUPT_MASK' and
     enables all interrupts

   * `RTEMS.INTERRUPT_LEVEL(n)' is masked by `RTEMS.INTERRUPT_MASK' and
     sets interrupts level n

Mode values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each mode appears exactly once in the component list.  A mode component
listed as a default is not required to appear in the mode list,
although it is a good programming practice to specify default
components.  If all defaults are desired, the mode DEFAULT_MODES should
be specified on this call.

This example demonstrates the mode parameter used with the
`rtems.signal_catch' to establish an ASR which executes at interrupt
level three and is non-preemptible.  The mode should be set to
`RTEMS.INTERRUPT_LEVEL(3) or RTEMS.NO_PREEMPT' to indicate the desired
processor mode and interrupt level.


File: ada_user.info,  Node: Signal Manager Operations,  Next: Signal Manager Establishing an ASR,  Prev: Signal Manager Building an ASR Mode,  Up: Signal Manager

12.3 Operations
===============

* Menu:

* Signal Manager Establishing an ASR::
* Signal Manager Sending a Signal Set::
* Signal Manager Processing an ASR::


File: ada_user.info,  Node: Signal Manager Establishing an ASR,  Next: Signal Manager Sending a Signal Set,  Prev: Signal Manager Operations,  Up: Signal Manager Operations

12.3.1 Establishing an ASR
--------------------------

The `rtems.signal_catch' directive establishes an ASR for the calling
task.  The address of the ASR and its execution mode are specified to
this directive.  The ASR's mode is distinct from the task's mode.  For
example, the task may allow preemption, while that task's ASR may have
preemption disabled.  Until a task calls `rtems.signal_catch' the first
time, its ASR is invalid, and no signal sets can be sent to the task.

A task may invalidate its ASR and discard all pending signals by
calling `rtems.signal_catch' with a value of NULL for the ASR's
address.  When a task's ASR is invalid, new signal sets sent to this
task are discarded.

A task may disable ASR processing (`RTEMS.NO_ASR') via the task_mode
directive.  When a task's ASR is disabled, the signals sent to it are
left pending to be processed later when the ASR is enabled.

Any directive that can be called from a task can also be called from an
ASR.  A task is only allowed one active ASR.  Thus, each call to
`rtems.signal_catch' replaces the previous one.

Normally, signal processing is disabled for the ASR's execution mode,
but if signal processing is enabled for the ASR, the ASR must be
reentrant.


File: ada_user.info,  Node: Signal Manager Sending a Signal Set,  Next: Signal Manager Processing an ASR,  Prev: Signal Manager Establishing an ASR,  Up: Signal Manager Operations

12.3.2 Sending a Signal Set
---------------------------

The `rtems.signal_send' directive allows both tasks and ISRs to send
signals to a target task.  The target task and a set of signals are
specified to the `rtems.signal_send' directive.  The sending of a
signal to a task has no effect on the execution state of that task.  If
the task is not the currently running task, then the signals are left
pending and processed by the task's ASR the next time the task is
dispatched to run.  The ASR is executed immediately before the task is
dispatched.  If the currently running task sends a signal to itself or
is sent a signal from an ISR, its ASR is immediately dispatched to run
provided signal processing is enabled.

If an ASR with signals enabled is preempted by another task or an ISR
and a new signal set is sent, then a new copy of the ASR will be
invoked, nesting the preempted ASR.  Upon completion of processing the
new signal set, control will return to the preempted ASR.  In this
situation, the ASR must be reentrant.

Like events, identical signals sent to a task are not queued.  In other
words, sending the same signal multiple times to a task (without any
intermediate signal processing occurring for the task), has the same
result as sending that signal to that task once.


File: ada_user.info,  Node: Signal Manager Processing an ASR,  Next: Signal Manager Directives,  Prev: Signal Manager Sending a Signal Set,  Up: Signal Manager Operations

12.3.3 Processing an ASR
------------------------

Asynchronous signals were designed to provide the capability to
generate software interrupts.  The processing of software interrupts
parallels that of hardware interrupts.  As a result, the differences
between the formats of ASRs and ISRs is limited to the meaning of the
single argument passed to an ASR.  The ASR should have the following
calling sequence and adhere to Ada calling conventions:

     procedure User_Routine (
       Signals : in     RTEMS.Signal_Set
     );

When the ASR returns to RTEMS the mode and execution path of the
interrupted task (or ASR) is restored to the context prior to entering
the ASR.


File: ada_user.info,  Node: Signal Manager Directives,  Next: Signal Manager SIGNAL_CATCH - Establish an ASR,  Prev: Signal Manager Processing an ASR,  Up: Signal Manager

12.4 Directives
===============

* Menu:

* Signal Manager SIGNAL_CATCH - Establish an ASR::
* Signal Manager SIGNAL_SEND - Send signal set to a task::

This section details the signal manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Signal Manager SIGNAL_CATCH - Establish an ASR,  Next: Signal Manager SIGNAL_SEND - Send signal set to a task,  Prev: Signal Manager Directives,  Up: Signal Manager Directives

12.4.1 SIGNAL_CATCH - Establish an ASR
--------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Signal_Catch (
        ASR_Handler : in     RTEMS.ASR_Handler;
        Mode_Set    : in     RTEMS.Mode;
        Result      :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - always successful

DESCRIPTION:
------------

This directive establishes an asynchronous signal routine (ASR) for the
calling task.  The asr_handler parameter specifies the entry point of
the ASR.  If asr_handler is NULL, the ASR for the calling task is
invalidated and all pending signals are cleared.  Any signals sent to a
task with an invalid ASR are discarded.  The mode parameter specifies
the execution mode for the ASR.  This execution mode supersedes the
task's execution mode while the ASR is executing.

NOTES:
------

This directive will not cause the calling task to be preempted.

The following task mode constants are defined by RTEMS:

   * `RTEMS.PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and enables
     preemption

   * `RTEMS.NO_PREEMPT' is masked by `RTEMS.PREEMPT_MASK' and disables
     preemption

   * `RTEMS.NO_TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and
     disables timeslicing

   * `RTEMS.TIMESLICE' is masked by `RTEMS.TIMESLICE_MASK' and enables
     timeslicing

   * `RTEMS.ASR' is masked by `RTEMS.ASR_MASK' and enables ASR
     processing

   * `RTEMS.NO_ASR' is masked by `RTEMS.ASR_MASK' and disables ASR
     processing

   * `RTEMS.INTERRUPT_LEVEL(0)' is masked by `RTEMS.INTERRUPT_MASK' and
     enables all interrupts

   * `RTEMS.INTERRUPT_LEVEL(n)' is masked by `RTEMS.INTERRUPT_MASK' and
     sets interrupts level n


File: ada_user.info,  Node: Signal Manager SIGNAL_SEND - Send signal set to a task,  Next: Partition Manager,  Prev: Signal Manager SIGNAL_CATCH - Establish an ASR,  Up: Signal Manager Directives

12.4.2 SIGNAL_SEND - Send signal set to a task
----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Signal_Send (
        ID         : in     RTEMS.ID;
        Signal_Set : in     RTEMS.Signal_Set;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - signal sent successfully
`RTEMS.INVALID_ID' - task id invalid
`RTEMS.INVALID_NUMBER' - empty signal set
`RTEMS.NOT_DEFINED' - ASR invalid

DESCRIPTION:
------------

This directive sends a signal set to the task specified in id.  The
signal_set parameter contains the signal set to be sent to the task.

If a caller sends a signal set to a task with an invalid ASR, then an
error code is returned to the caller.  If a caller sends a signal set
to a task whose ASR is valid but disabled, then the signal set will be
caught and left pending for the ASR to process when it is enabled. If a
caller sends a signal set to a task with an ASR that is both valid and
enabled, then the signal set is caught and the ASR will execute the next
time the task is dispatched to run.

NOTES:
------

Sending a signal set to a task has no effect on that task's state.  If
a signal set is sent to a blocked task, then the task will remain
blocked and the signals will be processed when the task becomes the
running task.

Sending a signal set to a global task which does not reside on the
local node will generate a request telling the remote node to send the
signal set to the specified task.


File: ada_user.info,  Node: Partition Manager,  Next: Partition Manager Introduction,  Prev: Signal Manager SIGNAL_SEND - Send signal set to a task,  Up: Top

13 Partition Manager
********************

* Menu:

* Partition Manager Introduction::
* Partition Manager Background::
* Partition Manager Operations::
* Partition Manager Directives::


File: ada_user.info,  Node: Partition Manager Introduction,  Next: Partition Manager Background,  Prev: Partition Manager,  Up: Partition Manager

13.1 Introduction
=================

The partition manager provides facilities to dynamically allocate
memory in fixed-size units.  The directives provided by the partition
manager are:

   * `rtems.partition_create' - Create a partition

   * `rtems.partition_ident' - Get ID of a partition

   * `rtems.partition_delete' - Delete a partition

   * `rtems.partition_get_buffer' - Get buffer from a partition

   * `rtems.partition_return_buffer' - Return buffer to a partition


File: ada_user.info,  Node: Partition Manager Background,  Next: Partition Manager Partition Manager Definitions,  Prev: Partition Manager Introduction,  Up: Partition Manager

13.2 Background
===============

* Menu:

* Partition Manager Partition Manager Definitions::
* Partition Manager Building a Partition Attribute Set::


File: ada_user.info,  Node: Partition Manager Partition Manager Definitions,  Next: Partition Manager Building a Partition Attribute Set,  Prev: Partition Manager Background,  Up: Partition Manager Background

13.2.1 Partition Manager Definitions
------------------------------------

A partition is a physically contiguous memory area divided into
fixed-size buffers that can be dynamically allocated and deallocated.

Partitions are managed and maintained as a list of buffers.  Buffers
are obtained from the front of the partition's free buffer chain and
returned to the rear of the same chain.  When a buffer is on the free
buffer chain, RTEMS uses two pointers of memory from each buffer as the
free buffer chain.  When a buffer is allocated, the entire buffer is
available for application use.  Therefore, modifying memory that is
outside of an allocated buffer could destroy the free buffer chain or
the contents of an adjacent allocated buffer.


File: ada_user.info,  Node: Partition Manager Building a Partition Attribute Set,  Next: Partition Manager Operations,  Prev: Partition Manager Partition Manager Definitions,  Up: Partition Manager Background

13.2.2 Building a Partition Attribute Set
-----------------------------------------

In general, an attribute set is built by a bitwise OR of the desired
attribute components.  The set of valid partition attributes is
provided in the following table:

   * `RTEMS.LOCAL' - local task (default)

   * `RTEMS.GLOBAL' - global task

Attribute values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each attribute appears exactly once in the component list.  An
attribute listed as a default is not required to appear in the
attribute list, although it is a good programming practice to specify
default attributes.  If all defaults are desired, the attribute
`RTEMS.DEFAULT_ATTRIBUTES' should be specified on this call.  The
attribute_set parameter should be `RTEMS.GLOBAL' to indicate that the
partition is to be known globally.


File: ada_user.info,  Node: Partition Manager Operations,  Next: Partition Manager Creating a Partition,  Prev: Partition Manager Building a Partition Attribute Set,  Up: Partition Manager

13.3 Operations
===============

* Menu:

* Partition Manager Creating a Partition::
* Partition Manager Obtaining Partition IDs::
* Partition Manager Acquiring a Buffer::
* Partition Manager Releasing a Buffer::
* Partition Manager Deleting a Partition::


File: ada_user.info,  Node: Partition Manager Creating a Partition,  Next: Partition Manager Obtaining Partition IDs,  Prev: Partition Manager Operations,  Up: Partition Manager Operations

13.3.1 Creating a Partition
---------------------------

The `rtems.partition_create' directive creates a partition with a
user-specified name.  The partition's name, starting address, length
and buffer size are all specified to the `rtems.partition_create'
directive.  RTEMS allocates a Partition Control Block (PTCB) from the
PTCB free list.  This data structure is used by RTEMS to manage the
newly created partition.  The number of buffers in the partition is
calculated based upon the specified partition length and buffer size.
If successful,the unique partition ID is returned to the calling task.


File: ada_user.info,  Node: Partition Manager Obtaining Partition IDs,  Next: Partition Manager Acquiring a Buffer,  Prev: Partition Manager Creating a Partition,  Up: Partition Manager Operations

13.3.2 Obtaining Partition IDs
------------------------------

When a partition is created, RTEMS generates a unique partition ID and
assigned it to the created partition until it is deleted.  The
partition ID may be obtained by either of two methods.  First, as the
result of an invocation of the `rtems.partition_create' directive, the
partition ID is stored in a user provided location.  Second, the
partition ID may be obtained later using the `rtems.partition_ident'
directive.  The partition ID is used by other partition manager
directives to access this partition.


File: ada_user.info,  Node: Partition Manager Acquiring a Buffer,  Next: Partition Manager Releasing a Buffer,  Prev: Partition Manager Obtaining Partition IDs,  Up: Partition Manager Operations

13.3.3 Acquiring a Buffer
-------------------------

A buffer can be obtained by calling the `rtems.partition_get_buffer'
directive.  If a buffer is available, then it is returned immediately
with a successful return code.  Otherwise, an unsuccessful return code
is returned immediately to the caller.  Tasks cannot block to wait for
a buffer to become available.


File: ada_user.info,  Node: Partition Manager Releasing a Buffer,  Next: Partition Manager Deleting a Partition,  Prev: Partition Manager Acquiring a Buffer,  Up: Partition Manager Operations

13.3.4 Releasing a Buffer
-------------------------

Buffers are returned to a partition's free buffer chain with the
`rtems.partition_return_buffer' directive.  This directive returns an
error status code if the returned buffer was not previously allocated
from this partition.


File: ada_user.info,  Node: Partition Manager Deleting a Partition,  Next: Partition Manager Directives,  Prev: Partition Manager Releasing a Buffer,  Up: Partition Manager Operations

13.3.5 Deleting a Partition
---------------------------

The `rtems.partition_delete' directive allows a partition to be removed
and returned to RTEMS.  When a partition is deleted, the PTCB for that
partition is returned to the PTCB free list.  A partition with buffers
still allocated cannot be deleted.  Any task attempting to do so will
be returned an error status code.


File: ada_user.info,  Node: Partition Manager Directives,  Next: Partition Manager PARTITION_CREATE - Create a partition,  Prev: Partition Manager Deleting a Partition,  Up: Partition Manager

13.4 Directives
===============

* Menu:

* Partition Manager PARTITION_CREATE - Create a partition::
* Partition Manager PARTITION_IDENT - Get ID of a partition::
* Partition Manager PARTITION_DELETE - Delete a partition::
* Partition Manager PARTITION_GET_BUFFER - Get buffer from a partition::
* Partition Manager PARTITION_RETURN_BUFFER - Return buffer to a partition::

This section details the partition manager's directives.  A subsection
is dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


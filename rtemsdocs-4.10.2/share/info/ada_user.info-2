This is ada_user.info, produced by makeinfo version 4.13 from
ada_user.texi.

INFO-DIR-SECTION RTEMS On-Line Manual
START-INFO-DIR-ENTRY
* RTEMS Ada User: (ada_user).          The Ada User's Guide
END-INFO-DIR-ENTRY


File: ada_user.info,  Node: Partition Manager PARTITION_CREATE - Create a partition,  Next: Partition Manager PARTITION_IDENT - Get ID of a partition,  Prev: Partition Manager Directives,  Up: Partition Manager Directives

13.4.1 PARTITION_CREATE - Create a partition
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Partition_Create (
        Name             : in     RTEMS.Name;
        Starting_Address : in     RTEMS.Address;
        Length           : in     RTEMS.Unsigned32;
        Buffer_Size      : in     RTEMS.Unsigned32;
        Attribute_Set    : in     RTEMS.Attribute;
        ID               :    out RTEMS.ID;
        Result           :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - partition created successfully
`RTEMS.INVALID_NAME' - invalid partition name
`RTEMS.TOO_MANY' - too many partitions created
`RTEMS.INVALID_ADDRESS' - address not on four byte boundary
`RTEMS.INVALID_ADDRESS' - `starting_address' is NULL
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_SIZE' - length or buffer size is 0
`RTEMS.INVALID_SIZE' - length is less than the buffer size
`RTEMS.INVALID_SIZE' - buffer size not a multiple of 4
`RTEMS.MP_NOT_CONFIGURED' - multiprocessing not configured
`RTEMS.TOO_MANY' - too many global objects

DESCRIPTION:
------------

This directive creates a partition of fixed size buffers from a
physically contiguous memory space which starts at starting_address and
is length bytes in size.  Each allocated buffer is to be of
`buffer_size' in bytes.  The assigned partition id is returned in `id'.
This partition id is used to access the partition with other partition
related directives.  For control and maintenance of the partition,
RTEMS allocates a PTCB from the local PTCB free pool and initializes it.

NOTES:
------

This directive will not cause the calling task to be preempted.

The `starting_address' must be properly aligned for the target
architecture.

The `buffer_size' parameter must be a multiple of the CPU alignment
factor.  Additionally, `buffer_size' must be large enough to hold two
pointers on the target architecture.  This is required for RTEMS to
manage the buffers when they are free.

Memory from the partition is not used by RTEMS to store the Partition
Control Block.

The following partition attribute constants are defined by RTEMS:

   * `RTEMS.LOCAL' - local task (default)

   * `RTEMS.GLOBAL' - global task

The PTCB for a global partition is allocated on the local node.  The
memory space used for the partition must reside in shared memory.
Partitions should not be made global unless remote tasks must interact
with the partition.  This is to avoid the overhead incurred by the
creation of a global partition.  When a global partition is created,
the partition's name and id must be transmitted to every node in the
system for insertion in the local copy of the global object table.

The total number of global objects, including partitions, is limited by
the maximum_global_objects field in the Configuration Table.


File: ada_user.info,  Node: Partition Manager PARTITION_IDENT - Get ID of a partition,  Next: Partition Manager PARTITION_DELETE - Delete a partition,  Prev: Partition Manager PARTITION_CREATE - Create a partition,  Up: Partition Manager Directives

13.4.2 PARTITION_IDENT - Get ID of a partition
----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Partition_Ident (
        Name   : in     RTEMS.Name;
        Node   : in     RTEMS.Unsigned32;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - partition identified successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - partition name not found
`RTEMS.INVALID_NODE' - invalid node id

DESCRIPTION:
------------

This directive obtains the partition id associated with the partition
name.  If the partition name is not unique, then the partition id will
match one of the partitions with that name.  However, this partition id
is not guaranteed to correspond to the desired partition.  The
partition id is used with other partition related directives to access
the partition.

NOTES:
------

This directive will not cause the running task to be preempted.

If node is `RTEMS.SEARCH_ALL_NODES', all nodes are searched with the
local node being searched first.  All other nodes are searched with the
lowest numbered node searched first.

If node is a valid node number which does not represent the local node,
then only the partitions exported by the designated node are searched.

This directive does not generate activity on remote nodes.  It accesses
only the local copy of the global object table.


File: ada_user.info,  Node: Partition Manager PARTITION_DELETE - Delete a partition,  Next: Partition Manager PARTITION_GET_BUFFER - Get buffer from a partition,  Prev: Partition Manager PARTITION_IDENT - Get ID of a partition,  Up: Partition Manager Directives

13.4.3 PARTITION_DELETE - Delete a partition
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Partition_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - partition deleted successfully
`RTEMS.INVALID_ID' - invalid partition id
`RTEMS.RESOURCE_IN_USE' - buffers still in use
`RTEMS.ILLEGAL_ON_REMOTE_OBJECT' - cannot delete remote partition

DESCRIPTION:
------------

This directive deletes the partition specified by id.  The partition
cannot be deleted if any of its buffers are still allocated.  The PTCB
for the deleted partition is reclaimed by RTEMS.

NOTES:
------

This directive will not cause the calling task to be preempted.

The calling task does not have to be the task that created the
partition.  Any local task that knows the partition id can delete the
partition.

When a global partition is deleted, the partition id must be
transmitted to every node in the system for deletion from the local
copy of the global object table.

The partition must reside on the local node, even if the partition was
created with the `RTEMS.GLOBAL' option.


File: ada_user.info,  Node: Partition Manager PARTITION_GET_BUFFER - Get buffer from a partition,  Next: Partition Manager PARTITION_RETURN_BUFFER - Return buffer to a partition,  Prev: Partition Manager PARTITION_DELETE - Delete a partition,  Up: Partition Manager Directives

13.4.4 PARTITION_GET_BUFFER - Get buffer from a partition
---------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Partition_Get_Buffer (
        ID     : in     RTEMS.ID;
        Buffer :    out RTEMS.Address;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - buffer obtained successfully
`RTEMS.INVALID_ADDRESS' - `buffer' is NULL
`RTEMS.INVALID_ID' - invalid partition id
`RTEMS.UNSATISFIED' - all buffers are allocated

DESCRIPTION:
------------

This directive allows a buffer to be obtained from the partition
specified in id.  The address of the allocated buffer is returned in
buffer.

NOTES:
------

This directive will not cause the running task to be preempted.

All buffers begin on a four byte boundary.

A task cannot wait on a buffer to become available.

Getting a buffer from a global partition which does not reside on the
local node will generate a request telling the remote node to allocate
a buffer from the specified partition.


File: ada_user.info,  Node: Partition Manager PARTITION_RETURN_BUFFER - Return buffer to a partition,  Next: Region Manager,  Prev: Partition Manager PARTITION_GET_BUFFER - Get buffer from a partition,  Up: Partition Manager Directives

13.4.5 PARTITION_RETURN_BUFFER - Return buffer to a partition
-------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Partition_Return_Buffer (
        ID     : in     RTEMS.ID;
        Buffer : in     RTEMS.Address;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - buffer returned successfully
`RTEMS.INVALID_ADDRESS' - `buffer' is NULL
`RTEMS.INVALID_ID' - invalid partition id
`RTEMS.INVALID_ADDRESS' - buffer address not in partition

DESCRIPTION:
------------

This directive returns the buffer specified by buffer to the partition
specified by id.

NOTES:
------

This directive will not cause the running task to be preempted.

Returning a buffer to a global partition which does not reside on the
local node will generate a request telling the remote node to return
the buffer to the specified partition.

Returning a buffer multiple times is an error.  It will corrupt the
internal state of the partition.


File: ada_user.info,  Node: Region Manager,  Next: Region Manager Introduction,  Prev: Partition Manager PARTITION_RETURN_BUFFER - Return buffer to a partition,  Up: Top

14 Region Manager
*****************

* Menu:

* Region Manager Introduction::
* Region Manager Background::
* Region Manager Operations::
* Region Manager Directives::


File: ada_user.info,  Node: Region Manager Introduction,  Next: Region Manager Background,  Prev: Region Manager,  Up: Region Manager

14.1 Introduction
=================

The region manager provides facilities to dynamically allocate memory
in variable sized units.  The directives provided by the region manager
are:

   * `rtems.region_create' - Create a region

   * `rtems.region_ident' - Get ID of a region

   * `rtems.region_delete' - Delete a region

   * `rtems.region_extend' - Add memory to a region

   * `rtems.region_get_segment' - Get segment from a region

   * `rtems.region_return_segment' - Return segment to a region

   * `rtems.region_get_segment_size' - Obtain size of a segment

   * `rtems.region_resize_segment' - Change size of a segment


File: ada_user.info,  Node: Region Manager Background,  Next: Region Manager Region Manager Definitions,  Prev: Region Manager Introduction,  Up: Region Manager

14.2 Background
===============

* Menu:

* Region Manager Region Manager Definitions::
* Region Manager Building an Attribute Set::
* Region Manager Building an Option Set::


File: ada_user.info,  Node: Region Manager Region Manager Definitions,  Next: Region Manager Building an Attribute Set,  Prev: Region Manager Background,  Up: Region Manager Background

14.2.1 Region Manager Definitions
---------------------------------

A region makes up a physically contiguous memory space with
user-defined boundaries from which variable-sized segments are
dynamically allocated and deallocated.  A segment is a variable size
section of memory which is allocated in multiples of a user-defined
page size.  This page size is required to be a multiple of four greater
than or equal to four.  For example, if a request for a 350-byte
segment is made in a region with 256-byte pages, then a 512-byte
segment is allocated.

Regions are organized as doubly linked chains of variable sized memory
blocks.  Memory requests are allocated using a first-fit algorithm.  If
available, the requester receives the number of bytes requested
(rounded up to the next page size).  RTEMS requires some overhead from
the region's memory for each segment that is allocated.  Therefore, an
application should only modify the memory of a segment that has been
obtained from the region.  The application should NOT modify the memory
outside of any obtained segments and within the region's boundaries
while the region is currently active in the system.

Upon return to the region, the free block is coalesced with its
neighbors (if free) on both sides to produce the largest possible
unused block.


File: ada_user.info,  Node: Region Manager Building an Attribute Set,  Next: Region Manager Building an Option Set,  Prev: Region Manager Region Manager Definitions,  Up: Region Manager Background

14.2.2 Building an Attribute Set
--------------------------------

In general, an attribute set is built by a bitwise OR of the desired
attribute components.  The set of valid region attributes is provided
in the following table:

   * `RTEMS.FIFO' - tasks wait by FIFO (default)

   * `RTEMS.PRIORITY' - tasks wait by priority

Attribute values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each attribute appears exactly once in the component list.  An
attribute listed as a default is not required to appear in the
attribute list, although it is a good programming practice to specify
default attributes.  If all defaults are desired, the attribute
`RTEMS.DEFAULT_ATTRIBUTES' should be specified on this call.

This example demonstrates the attribute_set parameter needed to create
a region with the task priority waiting queue discipline.  The
attribute_set parameter to the `rtems.region_create' directive should
be `RTEMS.PRIORITY'.


File: ada_user.info,  Node: Region Manager Building an Option Set,  Next: Region Manager Operations,  Prev: Region Manager Building an Attribute Set,  Up: Region Manager Background

14.2.3 Building an Option Set
-----------------------------

In general, an option is built by a bitwise OR of the desired option
components.  The set of valid options for the
`rtems.region_get_segment' directive are listed in the following table:

   * `RTEMS.WAIT' - task will wait for segment (default)

   * `RTEMS.NO_WAIT' - task should not wait

Option values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each option appears exactly once in the component list.  An option
listed as a default is not required to appear in the option list,
although it is a good programming practice to specify default options.
If all defaults are desired, the option `RTEMS.DEFAULT_OPTIONS' should
be specified on this call.

This example demonstrates the option parameter needed to poll for a
segment.  The option parameter passed to the `rtems.region_get_segment'
directive should be `RTEMS.NO_WAIT'.


File: ada_user.info,  Node: Region Manager Operations,  Next: Region Manager Creating a Region,  Prev: Region Manager Building an Option Set,  Up: Region Manager

14.3 Operations
===============

* Menu:

* Region Manager Creating a Region::
* Region Manager Obtaining Region IDs::
* Region Manager Adding Memory to a Region::
* Region Manager Acquiring a Segment::
* Region Manager Releasing a Segment::
* Region Manager Obtaining the Size of a Segment::
* Region Manager Changing the Size of a Segment::
* Region Manager Deleting a Region::


File: ada_user.info,  Node: Region Manager Creating a Region,  Next: Region Manager Obtaining Region IDs,  Prev: Region Manager Operations,  Up: Region Manager Operations

14.3.1 Creating a Region
------------------------

The `rtems.region_create' directive creates a region with the
user-defined name.  The user may select FIFO or task priority as the
method for placing waiting tasks in the task wait queue.  RTEMS
allocates a Region Control Block (RNCB) from the RNCB free list to
maintain the newly created region.  RTEMS also generates a unique
region ID which is returned to the calling task.

It is not possible to calculate the exact number of bytes available to
the user since RTEMS requires overhead for each segment allocated.  For
example, a region with one segment that is the size of the entire
region has more available bytes than a region with two segments that
collectively are the size of the entire region.  This is because the
region with one segment requires only the overhead for one segment,
while the other region requires the overhead for two segments.

Due to automatic coalescing, the number of segments in the region
dynamically changes.  Therefore, the total overhead required by RTEMS
dynamically changes.


File: ada_user.info,  Node: Region Manager Obtaining Region IDs,  Next: Region Manager Adding Memory to a Region,  Prev: Region Manager Creating a Region,  Up: Region Manager Operations

14.3.2 Obtaining Region IDs
---------------------------

When a region is created, RTEMS generates a unique region ID and
assigns it to the created region until it is deleted.  The region ID
may be obtained by either of two methods.  First, as the result of an
invocation of the `rtems.region_create' directive, the region ID is
stored in a user provided location.  Second, the region ID may be
obtained later using the `rtems.region_ident' directive.  The region ID
is used by other region manager directives to access this region.


File: ada_user.info,  Node: Region Manager Adding Memory to a Region,  Next: Region Manager Acquiring a Segment,  Prev: Region Manager Obtaining Region IDs,  Up: Region Manager Operations

14.3.3 Adding Memory to a Region
--------------------------------

The `rtems.region_extend' directive may be used to add memory to an
existing region.  The caller specifies the size in bytes and starting
address of the memory being added.

NOTE:  Please see the release notes or RTEMS source code for
information regarding restrictions on the location of the memory being
added in relation to memory already in the region.


File: ada_user.info,  Node: Region Manager Acquiring a Segment,  Next: Region Manager Releasing a Segment,  Prev: Region Manager Adding Memory to a Region,  Up: Region Manager Operations

14.3.4 Acquiring a Segment
--------------------------

The `rtems.region_get_segment' directive attempts to acquire a segment
from a specified region.  If the region has enough available free
memory, then a segment is returned successfully to the caller.  When
the segment cannot be allocated, one of the following situations
applies:

   * By default, the calling task will wait forever to acquire the
     segment.

   * Specifying the `RTEMS.NO_WAIT' option forces an immediate return
     with an error status code.

   * Specifying a timeout limits the interval the task will wait before
     returning with an error status code.

If the task waits for the segment, then it is placed in the region's
task wait queue in either FIFO or task priority order.  All tasks
waiting on a region are returned an error when the message queue is
deleted.


File: ada_user.info,  Node: Region Manager Releasing a Segment,  Next: Region Manager Obtaining the Size of a Segment,  Prev: Region Manager Acquiring a Segment,  Up: Region Manager Operations

14.3.5 Releasing a Segment
--------------------------

When a segment is returned to a region by the
`rtems.region_return_segment' directive, it is merged with its
unallocated neighbors to form the largest possible segment.  The first
task on the wait queue is examined to determine if its segment request
can now be satisfied.  If so, it is given a segment and unblocked.
This process is repeated until the first task's segment request cannot
be satisfied.


File: ada_user.info,  Node: Region Manager Obtaining the Size of a Segment,  Next: Region Manager Changing the Size of a Segment,  Prev: Region Manager Releasing a Segment,  Up: Region Manager Operations

14.3.6 Obtaining the Size of a Segment
--------------------------------------

The `rtems.region_get_segment_size' directive returns the size in bytes
of the specified segment.  The size returned includes any "extra"
memory included in the segment because of rounding up to a page size
boundary.


File: ada_user.info,  Node: Region Manager Changing the Size of a Segment,  Next: Region Manager Deleting a Region,  Prev: Region Manager Obtaining the Size of a Segment,  Up: Region Manager Operations

14.3.7 Changing the Size of a Segment
-------------------------------------

The `rtems.region_resize_segment' directive is used to change the size
in bytes of the specified segment.  The size may be increased or
decreased.  When increasing the size of a segment, it is possible that
the request cannot be satisfied.  This directive provides functionality
similar to the `realloc()' function in the Standard C Library.


File: ada_user.info,  Node: Region Manager Deleting a Region,  Next: Region Manager Directives,  Prev: Region Manager Changing the Size of a Segment,  Up: Region Manager Operations

14.3.8 Deleting a Region
------------------------

A region can be removed from the system and returned to RTEMS with the
`rtems.region_delete' directive.  When a region is deleted, its control
block is returned to the RNCB free list.  A region with segments still
allocated is not allowed to be deleted.  Any task attempting to do so
will be returned an error.  As a result of this directive, all tasks
blocked waiting to obtain a segment from the region will be readied and
returned a status code which indicates that the region was deleted.


File: ada_user.info,  Node: Region Manager Directives,  Next: Region Manager REGION_CREATE - Create a region,  Prev: Region Manager Deleting a Region,  Up: Region Manager

14.4 Directives
===============

* Menu:

* Region Manager REGION_CREATE - Create a region::
* Region Manager REGION_IDENT - Get ID of a region::
* Region Manager REGION_DELETE - Delete a region::
* Region Manager REGION_EXTEND - Add memory to a region::
* Region Manager REGION_GET_SEGMENT - Get segment from a region::
* Region Manager REGION_RETURN_SEGMENT - Return segment to a region::
* Region Manager REGION_GET_SEGMENT_SIZE - Obtain size of a segment::
* Region Manager REGION_RESIZE_SEGMENT - Change size of a segment::

This section details the region manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Region Manager REGION_CREATE - Create a region,  Next: Region Manager REGION_IDENT - Get ID of a region,  Prev: Region Manager Directives,  Up: Region Manager Directives

14.4.1 REGION_CREATE - Create a region
--------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Create (
        Name             : in     RTEMS.Name;
        Starting_Address : in     RTEMS.Address;
        Length           : in     RTEMS.Unsigned32;
        Page_Size        : in     RTEMS.Unsigned32;
        Attribute_Set    : in     RTEMS.Attribute;
        ID               :    out RTEMS.ID;
        Result           :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - region created successfully
`RTEMS.INVALID_NAME' - invalid region name
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_ADDRESS' - `starting_address' is NULL
`RTEMS.INVALID_ADDRESS' - address not on four byte boundary
`RTEMS.TOO_MANY' - too many regions created
`RTEMS.INVALID_SIZE' - invalid page size

DESCRIPTION:
------------

This directive creates a region from a physically contiguous memory
space which starts at starting_address and is length bytes long.
Segments allocated from the region will be a multiple of page_size
bytes in length.  The assigned region id is returned in id.  This
region id is used as an argument to other region related directives to
access the region.

For control and maintenance of the region, RTEMS allocates and
initializes an RNCB from the RNCB free pool.  Thus memory from the
region is not used to store the RNCB.  However, some overhead within
the region is required by RTEMS each time a segment is constructed in
the region.

Specifying `RTEMS.PRIORITY' in attribute_set causes tasks waiting for a
segment to be serviced according to task priority.  Specifying
`RTEMS.FIFO' in attribute_set or selecting `RTEMS.DEFAULT_ATTRIBUTES'
will cause waiting tasks to be serviced in First In-First Out order.

The `starting_address' parameter must be aligned on a four byte
boundary.  The `page_size' parameter must be a multiple of four greater
than or equal to eight.

NOTES:
------

This directive will not cause the calling task to be preempted.

The following region attribute constants are defined by RTEMS:

   * `RTEMS.FIFO' - tasks wait by FIFO (default)

   * `RTEMS.PRIORITY' - tasks wait by priority


File: ada_user.info,  Node: Region Manager REGION_IDENT - Get ID of a region,  Next: Region Manager REGION_DELETE - Delete a region,  Prev: Region Manager REGION_CREATE - Create a region,  Up: Region Manager Directives

14.4.2 REGION_IDENT - Get ID of a region
----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Ident (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - region identified successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - region name not found

DESCRIPTION:
------------

This directive obtains the region id associated with the region name to
be acquired.  If the region name is not unique, then the region id will
match one of the regions with that name.  However, this region id is
not guaranteed to correspond to the desired region.  The region id is
used to access this region in other region manager directives.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Region Manager REGION_DELETE - Delete a region,  Next: Region Manager REGION_EXTEND - Add memory to a region,  Prev: Region Manager REGION_IDENT - Get ID of a region,  Up: Region Manager Directives

14.4.3 REGION_DELETE - Delete a region
--------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - region deleted successfully
`RTEMS.INVALID_ID' - invalid region id
`RTEMS.RESOURCE_IN_USE' - segments still in use

DESCRIPTION:
------------

This directive deletes the region specified by id.  The region cannot
be deleted if any of its segments are still allocated.  The RNCB for
the deleted region is reclaimed by RTEMS.

NOTES:
------

This directive will not cause the calling task to be preempted.

The calling task does not have to be the task that created the region.
Any local task that knows the region id can delete the region.


File: ada_user.info,  Node: Region Manager REGION_EXTEND - Add memory to a region,  Next: Region Manager REGION_GET_SEGMENT - Get segment from a region,  Prev: Region Manager REGION_DELETE - Delete a region,  Up: Region Manager Directives

14.4.4 REGION_EXTEND - Add memory to a region
---------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Extend (
        ID               : in     RTEMS.ID;
        Starting_Address : in     RTEMS.Address;
        Length           : in     RTEMS.Unsigned32;
        Result           :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - region extended successfully
`RTEMS.INVALID_ADDRESS' - `starting_address' is NULL
`RTEMS.INVALID_ID' - invalid region id
`RTEMS.INVALID_ADDRESS' - invalid address of area to add

DESCRIPTION:
------------

This directive adds the memory which starts at starting_address for
length bytes to the region specified by id.

NOTES:
------

This directive will not cause the calling task to be preempted.

The calling task does not have to be the task that created the region.
Any local task that knows the region id can extend the region.


File: ada_user.info,  Node: Region Manager REGION_GET_SEGMENT - Get segment from a region,  Next: Region Manager REGION_RETURN_SEGMENT - Return segment to a region,  Prev: Region Manager REGION_EXTEND - Add memory to a region,  Up: Region Manager Directives

14.4.5 REGION_GET_SEGMENT - Get segment from a region
-----------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Get_Segment (
        ID         : in     RTEMS.ID;
        Size       : in     RTEMS.Unsigned32;
        Option_Set : in     RTEMS.Option;
        Timeout    : in     RTEMS.Interval;
        Segment    :    out RTEMS.Address;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - segment obtained successfully
`RTEMS.INVALID_ADDRESS' - `segment' is NULL
`RTEMS.INVALID_ID' - invalid region id
`RTEMS.INVALID_SIZE' - request is for zero bytes or exceeds the size of
maximum segment which is possible for this region
`RTEMS.UNSATISFIED' - segment of requested size not available
`RTEMS.TIMEOUT' - timed out waiting for segment
`RTEMS.OBJECT_WAS_DELETED' - region deleted while waiting

DESCRIPTION:
------------

This directive obtains a variable size segment from the region
specified by id.  The address of the allocated segment is returned in
segment.  The `RTEMS.WAIT' and `RTEMS.NO_WAIT' components of the
options parameter are used to specify whether the calling tasks wish to
wait for a segment to become available or return immediately if no
segment is available.  For either option, if a sufficiently sized
segment is available, then the segment is successfully acquired by
returning immediately with  the `RTEMS.SUCCESSFUL' status code.

If the calling task chooses to return immediately and a segment large
enough is not available, then an error code indicating this fact is
returned.  If the calling task chooses to wait for the segment and a
segment large enough is not available, then the calling task is placed
on the region's segment wait queue and blocked.  If the region was
created with the `RTEMS.PRIORITY' option, then the calling task is
inserted into the wait queue according to its priority.  However, if
the region was created with the `RTEMS.FIFO' option, then the calling
task is placed at the rear of the wait queue.

The timeout parameter specifies the maximum interval that a task is
willing to wait to obtain a segment.  If timeout is set to
`RTEMS.NO_TIMEOUT', then the calling task will wait forever.

NOTES:
------

The actual length of the allocated segment may be larger than the
requested size because a segment size is always a multiple of the
region's page size.

The following segment acquisition option constants are defined by RTEMS:

   * `RTEMS.WAIT' - task will wait for segment (default)

   * `RTEMS.NO_WAIT' - task should not wait

A clock tick is required to support the timeout functionality of this
directive.


File: ada_user.info,  Node: Region Manager REGION_RETURN_SEGMENT - Return segment to a region,  Next: Region Manager REGION_GET_SEGMENT_SIZE - Obtain size of a segment,  Prev: Region Manager REGION_GET_SEGMENT - Get segment from a region,  Up: Region Manager Directives

14.4.6 REGION_RETURN_SEGMENT - Return segment to a region
---------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Return_Segment (
        ID      : in     RTEMS.ID;
        Segment : in     RTEMS.Address;
        Result  :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - segment returned successfully
`RTEMS.INVALID_ADDRESS' - `segment' is NULL
`RTEMS.INVALID_ID' - invalid region id
`RTEMS.INVALID_ADDRESS' - segment address not in region

DESCRIPTION:
------------

This directive returns the segment specified by segment to the region
specified by id.  The returned segment is merged with its neighbors to
form the largest possible segment.  The first task on the wait queue is
examined to determine if its segment request can now be satisfied.  If
so, it is given a segment and unblocked.  This process is repeated
until the first task's segment request cannot be satisfied.

NOTES:
------

This directive will cause the calling task to be preempted if one or
more local tasks are waiting for a segment and the following conditions
exist:

   * a waiting task has a higher priority than the calling task

   * the size of the segment required by the waiting task is less than
     or equal to the size of the segment returned.


File: ada_user.info,  Node: Region Manager REGION_GET_SEGMENT_SIZE - Obtain size of a segment,  Next: Region Manager REGION_RESIZE_SEGMENT - Change size of a segment,  Prev: Region Manager REGION_RETURN_SEGMENT - Return segment to a region,  Up: Region Manager Directives

14.4.7 REGION_GET_SEGMENT_SIZE - Obtain size of a segment
---------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Get_Segment_Size (
        ID         : in     RTEMS.ID;
        Segment    : in     RTEMS.Address;
        Size       :    out RTEMS.Unsigned32;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - segment obtained successfully
`RTEMS.INVALID_ADDRESS' - `segment' is NULL
`RTEMS.INVALID_ADDRESS' - `size' is NULL
`RTEMS.INVALID_ID' - invalid region id
`RTEMS.INVALID_ADDRESS' - segment address not in region

DESCRIPTION:
------------

This directive obtains the size in bytes of the specified segment.

NOTES:
------

The actual length of the allocated segment may be larger than the
requested size because a segment size is always a multiple of the
region's page size.


File: ada_user.info,  Node: Region Manager REGION_RESIZE_SEGMENT - Change size of a segment,  Next: Dual-Ported Memory Manager,  Prev: Region Manager REGION_GET_SEGMENT_SIZE - Obtain size of a segment,  Up: Region Manager Directives

14.4.8 REGION_RESIZE_SEGMENT - Change size of a segment
-------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Region_Resize_Segment (
        ID         : in     RTEMS.ID;
        Segment    : in     RTEMS.Address;
        Size       : in     RTEMS.Unsigned32;
        Old_Size   :    out RTEMS.Unsigned32;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - segment obtained successfully
`RTEMS.INVALID_ADDRESS' - `segment' is NULL
`RTEMS.INVALID_ADDRESS' - `old_size' is NULL
`RTEMS.INVALID_ID' - invalid region id
`RTEMS.INVALID_ADDRESS' - segment address not in region
`RTEMS.UNSATISFIED' - unable to make segment larger

DESCRIPTION:
------------

This directive is used to increase or decrease the size of a segment.
When increasing the size of a segment, it is possible that there is not
memory available contiguous to the segment.  In this case, the request
is unsatisfied.

NOTES:
------

If an attempt to increase the size of a segment fails, then the
application may want to allocate a new segment of the desired size,
copy the contents of the original segment to the new, larger segment
and then return the original segment.


File: ada_user.info,  Node: Dual-Ported Memory Manager,  Next: Dual-Ported Memory Manager Introduction,  Prev: Region Manager REGION_RESIZE_SEGMENT - Change size of a segment,  Up: Top

15 Dual-Ported Memory Manager
*****************************

* Menu:

* Dual-Ported Memory Manager Introduction::
* Dual-Ported Memory Manager Background::
* Dual-Ported Memory Manager Operations::
* Dual-Ported Memory Manager Directives::


File: ada_user.info,  Node: Dual-Ported Memory Manager Introduction,  Next: Dual-Ported Memory Manager Background,  Prev: Dual-Ported Memory Manager,  Up: Dual-Ported Memory Manager

15.1 Introduction
=================

The dual-ported memory manager provides a mechanism for converting
addresses between internal and external representations for multiple
dual-ported memory areas (DPMA).  The directives provided by the
dual-ported memory manager are:

   * `rtems.port_create' - Create a port

   * `rtems.port_ident' - Get ID of a port

   * `rtems.port_delete' - Delete a port

   * `rtems.port_external_to_internal' - Convert external to internal
     address

   * `rtems.port_internal_to_external' - Convert internal to external
     address


File: ada_user.info,  Node: Dual-Ported Memory Manager Background,  Next: Dual-Ported Memory Manager Operations,  Prev: Dual-Ported Memory Manager Introduction,  Up: Dual-Ported Memory Manager

15.2 Background
===============

A dual-ported memory area (DPMA) is an contiguous block of RAM owned by
a particular processor but which can be accessed by other processors in
the system.  The owner accesses the memory using internal addresses,
while other processors must use external addresses.  RTEMS defines a
port as a particular mapping of internal and external addresses.

There are two system configurations in which dual-ported memory is
commonly found.  The first is tightly-coupled multiprocessor computer
systems where the dual-ported memory is shared between all nodes and is
used for inter-node communication.  The second configuration is computer
systems with intelligent peripheral controllers.  These controllers
typically utilize the DPMA for high-performance data transfers.


File: ada_user.info,  Node: Dual-Ported Memory Manager Operations,  Next: Dual-Ported Memory Manager Creating a Port,  Prev: Dual-Ported Memory Manager Background,  Up: Dual-Ported Memory Manager

15.3 Operations
===============

* Menu:

* Dual-Ported Memory Manager Creating a Port::
* Dual-Ported Memory Manager Obtaining Port IDs::
* Dual-Ported Memory Manager Converting an Address::
* Dual-Ported Memory Manager Deleting a DPMA Port::


File: ada_user.info,  Node: Dual-Ported Memory Manager Creating a Port,  Next: Dual-Ported Memory Manager Obtaining Port IDs,  Prev: Dual-Ported Memory Manager Operations,  Up: Dual-Ported Memory Manager Operations

15.3.1 Creating a Port
----------------------

The `rtems.port_create' directive creates a port into a DPMA with the
user-defined name.  The user specifies the association between internal
and external representations for the port being created.  RTEMS
allocates a Dual-Ported Memory Control Block (DPCB) from the DPCB free
list to maintain the newly created DPMA.  RTEMS also generates a unique
dual-ported memory port ID which is returned to the calling task.
RTEMS does not initialize the dual-ported memory area or access any
memory within it.


File: ada_user.info,  Node: Dual-Ported Memory Manager Obtaining Port IDs,  Next: Dual-Ported Memory Manager Converting an Address,  Prev: Dual-Ported Memory Manager Creating a Port,  Up: Dual-Ported Memory Manager Operations

15.3.2 Obtaining Port IDs
-------------------------

When a port is created, RTEMS generates a unique port ID and assigns it
to the created port until it is deleted.  The port ID may be obtained
by either of two methods.  First, as the result of an invocation of the
`rtems.port_create' directive, the task ID is stored in a user provided
location.  Second, the port ID may be obtained later using the
`rtems.port_ident' directive.  The port ID is used by other dual-ported
memory manager directives to access this port.


File: ada_user.info,  Node: Dual-Ported Memory Manager Converting an Address,  Next: Dual-Ported Memory Manager Deleting a DPMA Port,  Prev: Dual-Ported Memory Manager Obtaining Port IDs,  Up: Dual-Ported Memory Manager Operations

15.3.3 Converting an Address
----------------------------

The `rtems.port_external_to_internal' directive is used to convert an
address from external to internal representation for the specified port.
The `rtems.port_internal_to_external' directive is used to convert an
address from internal to external representation for the specified
port.  If an attempt is made to convert an address which lies outside
the specified DPMA, then the address to be converted will be returned.


File: ada_user.info,  Node: Dual-Ported Memory Manager Deleting a DPMA Port,  Next: Dual-Ported Memory Manager Directives,  Prev: Dual-Ported Memory Manager Converting an Address,  Up: Dual-Ported Memory Manager Operations

15.3.4 Deleting a DPMA Port
---------------------------

A port can be removed from the system and returned to RTEMS with the
`rtems.port_delete' directive.  When a port is deleted, its control
block is returned to the DPCB free list.


File: ada_user.info,  Node: Dual-Ported Memory Manager Directives,  Next: Dual-Ported Memory Manager PORT_CREATE - Create a port,  Prev: Dual-Ported Memory Manager Deleting a DPMA Port,  Up: Dual-Ported Memory Manager

15.4 Directives
===============

* Menu:

* Dual-Ported Memory Manager PORT_CREATE - Create a port::
* Dual-Ported Memory Manager PORT_IDENT - Get ID of a port::
* Dual-Ported Memory Manager PORT_DELETE - Delete a port::
* Dual-Ported Memory Manager PORT_EXTERNAL_TO_INTERNAL - Convert external to internal address::
* Dual-Ported Memory Manager PORT_INTERNAL_TO_EXTERNAL - Convert internal to external address::

This section details the dual-ported memory manager's directives.  A
subsection is dedicated to each of this manager's directives and
describes the calling sequence, related constants, usage, and status
codes.


File: ada_user.info,  Node: Dual-Ported Memory Manager PORT_CREATE - Create a port,  Next: Dual-Ported Memory Manager PORT_IDENT - Get ID of a port,  Prev: Dual-Ported Memory Manager Directives,  Up: Dual-Ported Memory Manager Directives

15.4.1 PORT_CREATE - Create a port
----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Port_Create (
        Name           : in     RTEMS.Name;
        Internal_Start : in     RTEMS.Address;
        External_Start : in     RTEMS.Address;
        Length         : in     RTEMS.Unsigned32;
        ID             :    out RTEMS.ID;
        Result         :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - port created successfully
`RTEMS.INVALID_NAME' - invalid port name
`RTEMS.INVALID_ADDRESS' - address not on four byte boundary
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.TOO_MANY' - too many DP memory areas created

DESCRIPTION:
------------

This directive creates a port which resides on the local node for the
specified DPMA.  The assigned port id is returned in id.  This port id
is used as an argument to other dual-ported memory manager directives
to convert addresses within this DPMA.

For control and maintenance of the port, RTEMS allocates and
initializes an DPCB from the DPCB free pool.  Thus memory from the
dual-ported memory area is not used to store the DPCB.

NOTES:
------

The internal_address and external_address parameters must be on a four
byte boundary.

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Dual-Ported Memory Manager PORT_IDENT - Get ID of a port,  Next: Dual-Ported Memory Manager PORT_DELETE - Delete a port,  Prev: Dual-Ported Memory Manager PORT_CREATE - Create a port,  Up: Dual-Ported Memory Manager Directives

15.4.2 PORT_IDENT - Get ID of a port
------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Port_Ident (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - port identified successfully
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.INVALID_NAME' - port name not found

DESCRIPTION:
------------

This directive obtains the port id associated with the specified name
to be acquired.  If the port name is not unique, then the port id will
match one of the DPMAs with that name.  However, this port id is not
guaranteed to correspond to the desired DPMA.  The port id is used to
access this DPMA in other dual-ported memory area related directives.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Dual-Ported Memory Manager PORT_DELETE - Delete a port,  Next: Dual-Ported Memory Manager PORT_EXTERNAL_TO_INTERNAL - Convert external to internal address,  Prev: Dual-Ported Memory Manager PORT_IDENT - Get ID of a port,  Up: Dual-Ported Memory Manager Directives

15.4.3 PORT_DELETE - Delete a port
----------------------------------

CALLING SEQUENCE:
-----------------

     procedure Port_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - port deleted successfully
`RTEMS.INVALID_ID' - invalid port id

DESCRIPTION:
------------

This directive deletes the dual-ported memory area specified by id.
The DPCB for the deleted dual-ported memory area is reclaimed by RTEMS.

NOTES:
------

This directive will not cause the calling task to be preempted.

The calling task does not have to be the task that created the port.
Any local task that knows the port id can delete the port.


File: ada_user.info,  Node: Dual-Ported Memory Manager PORT_EXTERNAL_TO_INTERNAL - Convert external to internal address,  Next: Dual-Ported Memory Manager PORT_INTERNAL_TO_EXTERNAL - Convert internal to external address,  Prev: Dual-Ported Memory Manager PORT_DELETE - Delete a port,  Up: Dual-Ported Memory Manager Directives

15.4.4 PORT_EXTERNAL_TO_INTERNAL - Convert external to internal address
-----------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Port_External_To_Internal (
        ID       : in     RTEMS.ID;
        External : in     RTEMS.Address;
        Internal :    out RTEMS.Address;
        Result   :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.INVALID_ADDRESS' - `internal' is NULL
`RTEMS.SUCCESSFUL' - successful conversion

DESCRIPTION:
------------

This directive converts a dual-ported memory address from external to
internal representation for the specified port.  If the given external
address is invalid for the specified port, then the internal address is
set to the given external address.

NOTES:
------

This directive is callable from an ISR.

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Dual-Ported Memory Manager PORT_INTERNAL_TO_EXTERNAL - Convert internal to external address,  Next: I/O Manager,  Prev: Dual-Ported Memory Manager PORT_EXTERNAL_TO_INTERNAL - Convert external to internal address,  Up: Dual-Ported Memory Manager Directives

15.4.5 PORT_INTERNAL_TO_EXTERNAL - Convert internal to external address
-----------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Port_Internal_To_External (
        ID       : in     RTEMS.ID;
        Internal : in     RTEMS.Address;
        External :    out RTEMS.Address;
        Result   :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.INVALID_ADDRESS' - `external' is NULL
`RTEMS.SUCCESSFUL' - successful conversion

DESCRIPTION:
------------

This directive converts a dual-ported memory address from internal to
external representation so that it can be passed to owner of the DPMA
represented by the specified port.  If the given internal address is an
invalid dual-ported address, then the external address is set to the
given internal address.

NOTES:
------

This directive is callable from an ISR.

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: I/O Manager,  Next: I/O Manager Introduction,  Prev: Dual-Ported Memory Manager PORT_INTERNAL_TO_EXTERNAL - Convert internal to external address,  Up: Top

16 I/O Manager
**************

* Menu:

* I/O Manager Introduction::
* I/O Manager Background::
* I/O Manager Operations::
* I/O Manager Directives::


File: ada_user.info,  Node: I/O Manager Introduction,  Next: I/O Manager Background,  Prev: I/O Manager,  Up: I/O Manager

16.1 Introduction
=================

The input/output interface manager provides a well-defined mechanism
for accessing device drivers and a structured methodology for
organizing device drivers.  The directives provided by the I/O manager
are:

   * `rtems.io_initialize' - Initialize a device driver

   * `rtems.io_register_driver' - Register a device driver

   * `rtems.io_unregister_driver' - Unregister a device driver

   * `rtems.io_register_name' - Register a device name

   * `rtems.io_lookup_name' - Look up a device name

   * `rtems.io_open' - Open a device

   * `rtems.io_close' - Close a device

   * `rtems.io_read' - Read from a device

   * `rtems.io_write' - Write to a device

   * `rtems.io_control' - Special device services


File: ada_user.info,  Node: I/O Manager Background,  Next: I/O Manager Device Driver Table,  Prev: I/O Manager Introduction,  Up: I/O Manager

16.2 Background
===============

* Menu:

* I/O Manager Device Driver Table::
* I/O Manager Major and Minor Device Numbers::
* I/O Manager Device Names::
* I/O Manager Device Driver Environment::
* I/O Manager Runtime Driver Registration::
* I/O Manager Device Driver Interface::
* I/O Manager Device Driver Initialization::


File: ada_user.info,  Node: I/O Manager Device Driver Table,  Next: I/O Manager Major and Minor Device Numbers,  Prev: I/O Manager Background,  Up: I/O Manager Background

16.2.1 Device Driver Table
--------------------------

Each application utilizing the RTEMS I/O manager must specify the
address of a Device Driver Table in its Configuration Table. This table
contains each device driver's entry points that is to be initialised by
RTEMS during initialization.  Each device driver may contain the
following entry points:

   * Initialization

   * Open

   * Close

   * Read

   * Write

   * Control

If the device driver does not support a particular entry point, then
that entry in the Configuration Table should be NULL.  RTEMS will return
`RTEMS.SUCCESSFUL' as the executive's and zero (0) as the device
driver's return code for these device driver entry points.

Applications can register and unregister drivers with the RTEMS I/O
manager avoiding the need to have all drivers statically defined and
linked into this table.

The `confdefs.h' entry `CONFIGURE_MAXIMUM_DRIVERS' configures the
number of driver slots available to the application.


File: ada_user.info,  Node: I/O Manager Major and Minor Device Numbers,  Next: I/O Manager Device Names,  Prev: I/O Manager Device Driver Table,  Up: I/O Manager Background

16.2.2 Major and Minor Device Numbers
-------------------------------------

Each call to the I/O manager must provide a device's major and minor
numbers as arguments.  The major number is the index of the requested
driver's entry points in the Device Driver Table, and is used to select
a specific device driver.  The exact usage of the minor number is
driver specific, but is commonly used to distinguish between a number
of devices controlled by the same driver.

The data types `rtems.device_major_number' and
`rtems.device_minor_number' are used to manipulate device major and
minor numbers, respectively.


File: ada_user.info,  Node: I/O Manager Device Names,  Next: I/O Manager Device Driver Environment,  Prev: I/O Manager Major and Minor Device Numbers,  Up: I/O Manager Background

16.2.3 Device Names
-------------------

The I/O Manager provides facilities to associate a name with a
particular device.  Directives are provided to register the name of a
device and to look up the major/minor number pair associated with a
device name.


File: ada_user.info,  Node: I/O Manager Device Driver Environment,  Next: I/O Manager Runtime Driver Registration,  Prev: I/O Manager Device Names,  Up: I/O Manager Background

16.2.4 Device Driver Environment
--------------------------------

Application developers, as well as device driver developers, must be
aware of the following regarding the RTEMS I/O Manager:

   * A device driver routine executes in the context of the invoking
     task.  Thus if the driver blocks, the invoking task blocks.

   * The device driver is free to change the modes of the invoking
     task, although the driver should restore them to their original
     values.

   * Device drivers may be invoked from ISRs.

   * Only local device drivers are accessible through the I/O manager.

   * A device driver routine may invoke all other RTEMS directives,
     including I/O directives, on both local and global objects.


Although the RTEMS I/O manager provides a framework for device drivers,
it makes no assumptions regarding the construction or operation of a
device driver.


File: ada_user.info,  Node: I/O Manager Runtime Driver Registration,  Next: I/O Manager Device Driver Interface,  Prev: I/O Manager Device Driver Environment,  Up: I/O Manager Background

16.2.5 Runtime Driver Registration
----------------------------------

Board support package and application developers can select wether a
device driver is statically entered into the default device table or
registered at runtime.

Dynamic registration helps applications where:

  1. The BSP and kernel libraries are common to a range of applications
     for a specific target platform. An application may be built upon a
     common library with all drivers. The application selects and
     registers the drivers. Uniform driver name lookup protects the
     application.

  2. The type and range of drivers may vary as the application probes a
     bus during initialization.

  3. Support for hot swap bus system such as Compact PCI.

  4. Support for runtime loadable driver modules.


File: ada_user.info,  Node: I/O Manager Device Driver Interface,  Next: I/O Manager Device Driver Initialization,  Prev: I/O Manager Runtime Driver Registration,  Up: I/O Manager Background

16.2.6 Device Driver Interface
------------------------------

When an application invokes an I/O manager directive, RTEMS determines
which device driver entry point must be invoked.  The information
passed by the application to RTEMS is then passed to the correct device
driver entry point.  RTEMS will invoke each device driver entry point
assuming it is compatible with the following prototype:

     function IO_Entry (
       Major          : in     RTEMS.Device_Major_Number;
       Minor          : in     RTEMS.Device_Major_Number;
       Argument_Block : in     RTEMS.Address
     ) return RTEMS.Status_Code;

The format and contents of the parameter block are device driver and
entry point dependent.

It is recommended that a device driver avoid generating error codes
which conflict with those used by application components.  A common
technique used to generate driver specific error codes is to make the
most significant part of the status indicate a driver specific code.


File: ada_user.info,  Node: I/O Manager Device Driver Initialization,  Next: I/O Manager Operations,  Prev: I/O Manager Device Driver Interface,  Up: I/O Manager Background

16.2.7 Device Driver Initialization
-----------------------------------

RTEMS automatically initializes all device drivers when multitasking is
initiated via the `rtems.initialize_executive' directive.  RTEMS
initializes the device drivers by invoking each device driver
initialization entry point with the following parameters:

major
     the major device number for this device driver.

minor
     zero.

argument_block
     will point to  the Configuration Table.


The returned status will be ignored by RTEMS.  If the driver cannot
successfully initialize the device, then it should invoke the
fatal_error_occurred directive.


File: ada_user.info,  Node: I/O Manager Operations,  Next: I/O Manager Register and Lookup Name,  Prev: I/O Manager Device Driver Initialization,  Up: I/O Manager

16.3 Operations
===============

* Menu:

* I/O Manager Register and Lookup Name::
* I/O Manager Accessing an Device Driver::


File: ada_user.info,  Node: I/O Manager Register and Lookup Name,  Next: I/O Manager Accessing an Device Driver,  Prev: I/O Manager Operations,  Up: I/O Manager Operations

16.3.1 Register and Lookup Name
-------------------------------

The `rtems.io_register' directive associates a name with the specified
device (i.e. major/minor number pair).  Device names are typically
registered as part of the device driver initialization sequence.  The
`rtems.io_lookup' directive is used to determine the major/minor number
pair associated with the specified device name.  The use of these
directives frees the application from being dependent on the arbitrary
assignment of major numbers in a particular application.  No device
naming conventions are dictated by RTEMS.


File: ada_user.info,  Node: I/O Manager Accessing an Device Driver,  Next: I/O Manager Directives,  Prev: I/O Manager Register and Lookup Name,  Up: I/O Manager Operations

16.3.2 Accessing an Device Driver
---------------------------------

The I/O manager provides directives which enable the application
program to utilize device drivers in a standard manner.  There is a
direct correlation between the RTEMS I/O manager directives
`rtems.io_initialize', `rtems.io_open', `rtems.io_close',
`rtems.io_read', `rtems.io_write', and `rtems.io_control' and the
underlying device driver entry points.


File: ada_user.info,  Node: I/O Manager Directives,  Next: I/O Manager IO_REGISTER_DRIVER - Register a device driver,  Prev: I/O Manager Accessing an Device Driver,  Up: I/O Manager

16.4 Directives
===============

* Menu:

* I/O Manager IO_REGISTER_DRIVER - Register a device driver::
* I/O Manager IO_UNREGISTER_DRIVER - Unregister a device driver::
* I/O Manager IO_INITIALIZE - Initialize a device driver::
* I/O Manager IO_REGISTER_NAME - Register a device::
* I/O Manager IO_LOOKUP_NAME - Lookup a device::
* I/O Manager IO_OPEN - Open a device::
* I/O Manager IO_CLOSE - Close a device::
* I/O Manager IO_READ - Read from a device::
* I/O Manager IO_WRITE - Write to a device::
* I/O Manager IO_CONTROL - Special device services::

This section details the I/O manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: I/O Manager IO_REGISTER_DRIVER - Register a device driver,  Next: I/O Manager IO_UNREGISTER_DRIVER - Unregister a device driver,  Prev: I/O Manager Directives,  Up: I/O Manager Directives

16.4.1 IO_REGISTER_DRIVER - Register a device driver
----------------------------------------------------

CALLING SEQUENCE:
-----------------

     No Ada implementation.

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully registered
`RTEMS.INVALID_ADDRESS' - invalid registered major pointer
`RTEMS.INVALID_ADDRESS' - invalid driver table
`RTEMS.INVALID_NUMBER' - invalid major device number
`RTEMS.TOO_MANY' - no available major device table slot
`RTEMS.RESOURCE_IN_USE' - major device number entry in use

DESCRIPTION:
------------

This directive attempts to add a new device driver to the Device Driver
Table. The user can specify a specific major device number via the
directive's `major' parameter, or let the registration routine find the
next available major device number by specifing a major number of `0'.
The selected major device number is returned via the `registered_major'
directive parameter. The directive automatically allocation major
device numbers from the highest value down.

This directive automatically invokes the IO_INITIALIZE directive if the
driver address table has an initialization and open entry.

The directive returns RTEMS.TOO_MANY if Device Driver Table is full,
and RTEMS.RESOURCE_IN_USE if a specific major device number is
requested and it is already in use.

NOTES:
------

The Device Driver Table size is specified in the Configuration Table
condiguration. This needs to be set to maximum size the application
requires.


File: ada_user.info,  Node: I/O Manager IO_UNREGISTER_DRIVER - Unregister a device driver,  Next: I/O Manager IO_INITIALIZE - Initialize a device driver,  Prev: I/O Manager IO_REGISTER_DRIVER - Register a device driver,  Up: I/O Manager Directives

16.4.2 IO_UNREGISTER_DRIVER - Unregister a device driver
--------------------------------------------------------

CALLING SEQUENCE:
-----------------

     No Ada implementation.

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully registered
`RTEMS.INVALID_NUMBER' - invalid major device number

DESCRIPTION:
------------

This directive removes a device driver from the Device Driver Table.

NOTES:
------

Currently no specific checks are made and the driver is not closed.


File: ada_user.info,  Node: I/O Manager IO_INITIALIZE - Initialize a device driver,  Next: I/O Manager IO_REGISTER_NAME - Register a device,  Prev: I/O Manager IO_UNREGISTER_DRIVER - Unregister a device driver,  Up: I/O Manager Directives

16.4.3 IO_INITIALIZE - Initialize a device driver
-------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Initialize (
        Major        : in     RTEMS.Device_Major_Number;
        Minor        : in     RTEMS.Device_Minor_Number;
        Argument     : in     RTEMS.Address;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.INVALID_NUMBER' - invalid major device number

DESCRIPTION:
------------

This directive calls the device driver initialization routine specified
in the Device Driver Table for this major number. This directive is
automatically invoked for each device driver when multitasking is
initiated via the initialize_executive directive.

A device driver initialization module is responsible for initializing
all hardware and data structures associated with a device. If
necessary, it can allocate memory to be used during other operations.

NOTES:
------

This directive may or may not cause the calling task to be preempted.
This is dependent on the device driver being initialized.


File: ada_user.info,  Node: I/O Manager IO_REGISTER_NAME - Register a device,  Next: I/O Manager IO_LOOKUP_NAME - Lookup a device,  Prev: I/O Manager IO_INITIALIZE - Initialize a device driver,  Up: I/O Manager Directives

16.4.4 IO_REGISTER_NAME - Register a device
-------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Register_Name (
        Name   : in     String;
        Major  : in     RTEMS.Device_Major_Number;
        Minor  : in     RTEMS.Device_Minor_Number;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.TOO_MANY' - too many devices registered

DESCRIPTION:
------------

This directive associates name with the specified major/minor number
pair.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: I/O Manager IO_LOOKUP_NAME - Lookup a device,  Next: I/O Manager IO_OPEN - Open a device,  Prev: I/O Manager IO_REGISTER_NAME - Register a device,  Up: I/O Manager Directives

16.4.5 IO_LOOKUP_NAME - Lookup a device
---------------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Lookup_Name (
        Name         : in     String;
        Device_Info  :    out RTEMS.Driver_Name_t_Pointer;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.UNSATISFIED' - name not registered

DESCRIPTION:
------------

This directive returns the major/minor number pair associated with the
given device name in `device_info'.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: I/O Manager IO_OPEN - Open a device,  Next: I/O Manager IO_CLOSE - Close a device,  Prev: I/O Manager IO_LOOKUP_NAME - Lookup a device,  Up: I/O Manager Directives

16.4.6 IO_OPEN - Open a device
------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Open (
        Major        : in     RTEMS.Device_Major_Number;
        Minor        : in     RTEMS.Device_Minor_Number;
        Argument     : in     RTEMS.Address;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.INVALID_NUMBER' - invalid major device number

DESCRIPTION:
------------

This directive calls the device driver open routine specified in the
Device Driver Table for this major number.  The open entry point is
commonly used by device drivers to provide exclusive access to a device.

NOTES:
------

This directive may or may not cause the calling task to be preempted.
This is dependent on the device driver being invoked.


File: ada_user.info,  Node: I/O Manager IO_CLOSE - Close a device,  Next: I/O Manager IO_READ - Read from a device,  Prev: I/O Manager IO_OPEN - Open a device,  Up: I/O Manager Directives

16.4.7 IO_CLOSE - Close a device
--------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Close (
        Major        : in     RTEMS.Device_Major_Number;
        Minor        : in     RTEMS.Device_Minor_Number;
        Argument     : in     RTEMS.Address;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.INVALID_NUMBER' - invalid major device number

DESCRIPTION:
------------

This directive calls the device driver close routine specified in the
Device Driver Table for this major number.  The close entry point is
commonly used by device drivers to relinquish exclusive access to a
device.

NOTES:
------

This directive may or may not cause the calling task to be preempted.
This is dependent on the device driver being invoked.


File: ada_user.info,  Node: I/O Manager IO_READ - Read from a device,  Next: I/O Manager IO_WRITE - Write to a device,  Prev: I/O Manager IO_CLOSE - Close a device,  Up: I/O Manager Directives

16.4.8 IO_READ - Read from a device
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Read (
        Major        : in     RTEMS.Device_Major_Number;
        Minor        : in     RTEMS.Device_Minor_Number;
        Argument     : in     RTEMS.Address;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.INVALID_NUMBER' - invalid major device number

DESCRIPTION:
------------

This directive calls the device driver read routine specified in the
Device Driver Table for this major number.  Read operations typically
require a buffer address as part of the argument parameter block.  The
contents of this buffer will be replaced with data from the device.

NOTES:
------

This directive may or may not cause the calling task to be preempted.
This is dependent on the device driver being invoked.


File: ada_user.info,  Node: I/O Manager IO_WRITE - Write to a device,  Next: I/O Manager IO_CONTROL - Special device services,  Prev: I/O Manager IO_READ - Read from a device,  Up: I/O Manager Directives

16.4.9 IO_WRITE - Write to a device
-----------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Write (
        Major        : in     RTEMS.Device_Major_Number;
        Minor        : in     RTEMS.Device_Minor_Number;
        Argument     : in     RTEMS.Address;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.INVALID_NUMBER' - invalid major device number

DESCRIPTION:
------------

This directive calls the device driver write routine specified in the
Device Driver Table for this major number.  Write operations typically
require a buffer address as part of the argument parameter block.  The
contents of this buffer will be sent to the device.

NOTES:
------

This directive may or may not cause the calling task to be preempted.
This is dependent on the device driver being invoked.


File: ada_user.info,  Node: I/O Manager IO_CONTROL - Special device services,  Next: Fatal Error Manager,  Prev: I/O Manager IO_WRITE - Write to a device,  Up: I/O Manager Directives

16.4.10 IO_CONTROL - Special device services
--------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure IO_Control (
        Major        : in     RTEMS.Device_Major_Number;
        Minor        : in     RTEMS.Device_Minor_Number;
        Argument     : in     RTEMS.Address;
        Result       :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - successfully initialized
`RTEMS.INVALID_NUMBER' - invalid major device number

DESCRIPTION:
------------

This directive calls the device driver I/O control routine specified in
the Device Driver Table for this major number.  The exact functionality
of the driver entry called by this directive is driver dependent.  It
should not be assumed that the control entries of two device drivers
are compatible.  For example, an RS-232 driver I/O control operation
may change the baud rate of a serial line, while an I/O control
operation for a floppy disk driver may cause a seek operation.

NOTES:
------

This directive may or may not cause the calling task to be preempted.
This is dependent on the device driver being invoked.


File: ada_user.info,  Node: Fatal Error Manager,  Next: Fatal Error Manager Introduction,  Prev: I/O Manager IO_CONTROL - Special device services,  Up: Top

17 Fatal Error Manager
**********************

* Menu:

* Fatal Error Manager Introduction::
* Fatal Error Manager Background::
* Fatal Error Manager Operations::
* Fatal Error Manager Directives::


File: ada_user.info,  Node: Fatal Error Manager Introduction,  Next: Fatal Error Manager Background,  Prev: Fatal Error Manager,  Up: Fatal Error Manager

17.1 Introduction
=================

The fatal error manager processes all fatal or irrecoverable errors.
The directive provided by the fatal error manager is:

   * `rtems.fatal_error_occurred' - Invoke the fatal error handler


File: ada_user.info,  Node: Fatal Error Manager Background,  Next: Fatal Error Manager Operations,  Prev: Fatal Error Manager Introduction,  Up: Fatal Error Manager

17.2 Background
===============

The fatal error manager is called upon detection of an irrecoverable
error condition by either RTEMS or the application software.  Fatal
errors can be detected from three sources:

   * the executive (RTEMS)

   * user system code

   * user application code

RTEMS automatically invokes the fatal error manager upon detection of
an error it considers to be fatal.  Similarly, the user should invoke
the fatal error manager upon detection of a fatal error.

Each status or dynamic user extension set may include a fatal error
handler.  The fatal error handler in the static extension set can be
used to provide access to debuggers and monitors which may be present
on the target hardware.  If any user-supplied fatal error handlers are
installed, the fatal error manager will invoke them.  If no user
handlers are configured or if all the user handler return control to the
fatal error manager, then the RTEMS default fatal error handler is
invoked.  If the default fatal error handler is invoked, then the
system state is marked as failed.

Although the precise behavior of the default fatal error handler is
processor specific, in general, it will disable all maskable
interrupts, place the error code in a known processor dependent place
(generally either on the stack or in a register), and halt the
processor.  The precise actions of the RTEMS fatal error are discussed
in the Default Fatal Error Processing chapter of the Applications
Supplement document for a specific target processor.


File: ada_user.info,  Node: Fatal Error Manager Operations,  Next: Fatal Error Manager Announcing a Fatal Error,  Prev: Fatal Error Manager Background,  Up: Fatal Error Manager

17.3 Operations
===============

* Menu:

* Fatal Error Manager Announcing a Fatal Error::


File: ada_user.info,  Node: Fatal Error Manager Announcing a Fatal Error,  Next: Fatal Error Manager Directives,  Prev: Fatal Error Manager Operations,  Up: Fatal Error Manager Operations

17.3.1 Announcing a Fatal Error
-------------------------------

The `rtems.fatal_error_occurred' directive is invoked when a fatal
error is detected.  Before invoking any user-supplied fatal error
handlers or the RTEMS fatal error handler, the
`rtems.fatal_error_occurred' directive stores useful information in the
variable `_Internal_errors_What_happened'.  This record contains three
pieces of information:

   * the source of the error (API or executive core),

   * whether the error was generated internally by the executive, and a

   * a numeric code to indicate the error type.

The error type indicator is dependent on the source of the error and
whether or not the error was internally generated by the executive.  If
the error was generated from an API, then the error code will be of
that API's error or status codes.  The status codes for the RTEMS API
are in cpukit/rtems/include/rtems/rtems/status.h.  Those for the POSIX
API can be found in <errno.h>.

The `rtems.fatal_error_occurred' directive is responsible for invoking
an optional user-supplied fatal error handler and/or the RTEMS fatal
error handler.  All fatal error handlers are passed an error code to
describe the error detected.

Occasionally, an application requires more sophisticated fatal error
processing such as passing control to a debugger.  For these cases, a
user-supplied fatal error handler can be specified in the RTEMS
configuration table.  The User Extension Table field fatal contains the
address of the fatal error handler to be executed when the
`rtems.fatal_error_occurred' directive is called.  If the field is set
to NULL or if the configured fatal error handler returns to the
executive, then the default handler provided by RTEMS is executed.
This default handler will halt execution on the processor where the
error occurred.


File: ada_user.info,  Node: Fatal Error Manager Directives,  Next: Fatal Error Manager FATAL_ERROR_OCCURRED - Invoke the fatal error handler,  Prev: Fatal Error Manager Announcing a Fatal Error,  Up: Fatal Error Manager

17.4 Directives
===============

* Menu:

* Fatal Error Manager FATAL_ERROR_OCCURRED - Invoke the fatal error handler::

This section details the fatal error manager's directives.  A
subsection is dedicated to each of this manager's directives and
describes the calling sequence, related constants, usage, and status
codes.


File: ada_user.info,  Node: Fatal Error Manager FATAL_ERROR_OCCURRED - Invoke the fatal error handler,  Next: Scheduling Concepts,  Prev: Fatal Error Manager Directives,  Up: Fatal Error Manager Directives

17.4.1 FATAL_ERROR_OCCURRED - Invoke the fatal error handler
------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Fatal_Error_Occurred (
        The_Error : in     RTEMS.Unsigned32
     );

DIRECTIVE STATUS CODES
----------------------

NONE

DESCRIPTION:
------------

This directive processes fatal errors.  If the FATAL error extension is
defined in the configuration table, then the user-defined error
extension is called.  If configured and the provided FATAL error
extension returns, then the RTEMS default error handler is invoked.
This directive can be invoked by RTEMS or by the user's application
code including initialization tasks, other tasks, and ISRs.

NOTES:
------

This directive supports local operations only.

Unless the user-defined error extension takes special actions such as
restarting the calling task, this directive WILL NOT RETURN to the
caller.

The user-defined extension for this directive may wish to initiate a
global shutdown.


File: ada_user.info,  Node: Scheduling Concepts,  Next: Scheduling Concepts Introduction,  Prev: Fatal Error Manager FATAL_ERROR_OCCURRED - Invoke the fatal error handler,  Up: Top

18 Scheduling Concepts
**********************

* Menu:

* Scheduling Concepts Introduction::
* Scheduling Concepts Scheduling Mechanisms::
* Scheduling Concepts Task State Transitions::


File: ada_user.info,  Node: Scheduling Concepts Introduction,  Next: Scheduling Concepts Scheduling Mechanisms,  Prev: Scheduling Concepts,  Up: Scheduling Concepts

18.1 Introduction
=================

The concept of scheduling in real-time systems dictates the ability to
provide immediate response to specific external events, particularly
the necessity of scheduling tasks to run within a specified time limit
after the occurrence of an event.  For example, software embedded in
life-support systems used to monitor hospital patients must take
instant action if a change in the patient's status is detected.

The component of RTEMS responsible for providing this capability is
appropriately called the scheduler.  The scheduler's sole purpose is to
allocate the all important resource of processor time to the various
tasks competing for attention.  The RTEMS scheduler allocates the
processor using a priority-based, preemptive algorithm augmented to
provide round-robin characteristics within individual priority groups.
The goal of this algorithm is to guarantee that the task which is
executing on the processor at any point in time is the one with the
highest priority among all tasks in the ready state.

There are two common methods of accomplishing the mechanics of this
algorithm.  Both ways involve a list or chain of tasks in the ready
state.  One method is to randomly place tasks in the ready chain
forcing the scheduler to scan the entire chain to determine which task
receives the processor.  The other method is to schedule the task by
placing it in the proper place on the ready chain based on the
designated scheduling criteria at the time it enters the ready state.
Thus, when the processor is free, the first task on the ready chain is
allocated the processor.  RTEMS schedules tasks using the second method
to guarantee faster response times to external events.


File: ada_user.info,  Node: Scheduling Concepts Scheduling Mechanisms,  Next: Scheduling Concepts Task Priority and Scheduling,  Prev: Scheduling Concepts Introduction,  Up: Scheduling Concepts

18.2 Scheduling Mechanisms
==========================

* Menu:

* Scheduling Concepts Task Priority and Scheduling::
* Scheduling Concepts Preemption::
* Scheduling Concepts Timeslicing::
* Scheduling Concepts Manual Round-Robin::
* Scheduling Concepts Dispatching Tasks::

RTEMS provides four mechanisms which allow the user to impact the task
scheduling process:

   * user-selectable task priority level

   * task preemption control

   * task timeslicing control

   * manual round-robin selection

Each of these methods provides a powerful capability to customize sets
of tasks to satisfy the unique and particular requirements encountered
in custom real-time applications.  Although each mechanism operates
independently, there is a precedence relationship which governs the
effects of scheduling modifications.  The evaluation order for
scheduling characteristics is always priority, preemption mode, and
timeslicing.  When reading the descriptions of timeslicing and manual
round-robin it is important to keep in mind that preemption (if
enabled) of a task by higher priority tasks will occur as required,
overriding the other factors presented in the description.


File: ada_user.info,  Node: Scheduling Concepts Task Priority and Scheduling,  Next: Scheduling Concepts Preemption,  Prev: Scheduling Concepts Scheduling Mechanisms,  Up: Scheduling Concepts Scheduling Mechanisms

18.2.1 Task Priority and Scheduling
-----------------------------------

The most significant of these mechanisms is the ability for the user to
assign a priority level to each individual task when it is created and
to alter a task's priority at run-time.  RTEMS provides 255 priority
levels.  Level 255 is the lowest priority and level 1 is the highest.
When a task is added to the ready chain, it is placed behind all other
tasks of the same priority.  This rule provides a round-robin within
priority group scheduling characteristic.  This means that in a group
of equal priority tasks, tasks will execute in the order they become
ready or FIFO order.  Even though there are ways to manipulate and
adjust task priorities, the most important rule to remember is:

   ` ' The RTEMS scheduler will always select the highest priority task
     that is ready to run when allocating the processor to a task.


File: ada_user.info,  Node: Scheduling Concepts Preemption,  Next: Scheduling Concepts Timeslicing,  Prev: Scheduling Concepts Task Priority and Scheduling,  Up: Scheduling Concepts Scheduling Mechanisms

18.2.2 Preemption
-----------------

Another way the user can alter the basic scheduling algorithm is by
manipulating the preemption mode flag (`RTEMS.PREEMPT_MASK') of
individual tasks.  If preemption is disabled for a task
(`RTEMS.NO_PREEMPT'), then the task will not relinquish control of the
processor until it terminates, blocks, or re-enables preemption.  Even
tasks which become ready to run and possess higher priority levels will
not be allowed to execute.  Note that the preemption setting has no
effect on the manner in which a task is scheduled.  It only applies
once a task has control of the processor.


File: ada_user.info,  Node: Scheduling Concepts Timeslicing,  Next: Scheduling Concepts Manual Round-Robin,  Prev: Scheduling Concepts Preemption,  Up: Scheduling Concepts Scheduling Mechanisms

18.2.3 Timeslicing
------------------

Timeslicing or round-robin scheduling is an additional method which can
be used to alter the basic scheduling algorithm.  Like preemption,
timeslicing is specified on a task by task basis using the timeslicing
mode flag (`RTEMS.TIMESLICE_MASK').  If timeslicing is enabled for a
task (`RTEMS.TIMESLICE'), then RTEMS will limit the amount of time the
task can execute before the processor is allocated to another task.
Each tick of the real-time clock reduces the currently running task's
timeslice.  When the execution time equals the timeslice, RTEMS will
dispatch another task of the same priority to execute.  If there are no
other tasks of the same priority ready to execute, then the current
task is allocated an additional timeslice and continues to run.
Remember that a higher priority task will preempt the task (unless
preemption is disabled) as soon as it is ready to run, even if the task
has not used up its entire timeslice.


File: ada_user.info,  Node: Scheduling Concepts Manual Round-Robin,  Next: Scheduling Concepts Dispatching Tasks,  Prev: Scheduling Concepts Timeslicing,  Up: Scheduling Concepts Scheduling Mechanisms

18.2.4 Manual Round-Robin
-------------------------

The final mechanism for altering the RTEMS scheduling algorithm is
called manual round-robin.  Manual round-robin is invoked by using the
`rtems.task_wake_after' directive with a time interval of
`RTEMS.YIELD_PROCESSOR'.  This allows a task to give up the processor
and be immediately returned to the ready chain at the end of its
priority group.  If no other tasks of the same priority are ready to
run, then the task does not lose control of the processor.


File: ada_user.info,  Node: Scheduling Concepts Dispatching Tasks,  Next: Scheduling Concepts Task State Transitions,  Prev: Scheduling Concepts Manual Round-Robin,  Up: Scheduling Concepts Scheduling Mechanisms

18.2.5 Dispatching Tasks
------------------------

The dispatcher is the RTEMS component responsible for allocating the
processor to a ready task.  In order to allocate the processor to one
task, it must be deallocated or retrieved from the task currently using
it.  This involves a concept called a context switch.  To perform a
context switch, the dispatcher saves the context of the current task
and restores the context of the task which has been allocated to the
processor.  Saving and restoring a task's context is the
storing/loading of all the essential information about a task to enable
it to continue execution without any effects of the interruption.  For
example, the contents of a task's register set must be the same when it
is given the processor as they were when it was taken away.  All of the
information that must be saved or restored for a context switch is
located either in the TCB or on the task's stacks.

Tasks that utilize a numeric coprocessor and are created with the
`RTEMS.FLOATING_POINT' attribute require additional operations during a
context switch.  These additional operations are necessary to save and
restore the floating point context of `RTEMS.FLOATING_POINT' tasks.  To
avoid unnecessary save and restore operations, the state of the numeric
coprocessor is only saved when a `RTEMS.FLOATING_POINT' task is
dispatched and that task was not the last task to utilize the
coprocessor.


File: ada_user.info,  Node: Scheduling Concepts Task State Transitions,  Next: Rate Monotonic Manager,  Prev: Scheduling Concepts Dispatching Tasks,  Up: Scheduling Concepts

18.3 Task State Transitions
===========================

Tasks in an RTEMS system must always be in one of the five allowable
task states.  These states are: executing, ready, blocked, dormant, and
non-existent.

A task occupies the non-existent state before a `rtems.task_create' has
been issued on its behalf.  A task enters the non-existent state from
any other state in the system when it is deleted with the
`rtems.task_delete' directive.  While a task occupies this state it
does not have a TCB or a task ID assigned to it; therefore, no other
tasks in the system may reference this task.

When a task is created via the `rtems.task_create' directive it enters
the dormant state.  This state is not entered through any other means.
Although the task exists in the system, it cannot actively compete for
system resources.  It will remain in the dormant state until it is
started via the `rtems.task_start' directive, at which time it enters
the ready state.  The task is now permitted to be scheduled for the
processor and to compete for other system resources.

          +-------------------------------------------------------------+
          |                         Non-existent                        |
          |  +-------------------------------------------------------+  |
          |  |                                                       |  |
          |  |                                                       |  |
          |  |      Creating        +---------+     Deleting         |  |
          |  | -------------------> | Dormant | -------------------> |  |
          |  |                      +---------+                      |  |
          |  |                           |                           |  |
          |  |                  Starting |                           |  |
          |  |                           |                           |  |
          |  |                           V          Deleting         |  |
          |  |             +-------> +-------+ ------------------->  |  |
          |  |  Yielding  /   +----- | Ready | ------+               |  |
          |  |           /   /       +-------+ <--+   \              |  |
          |  |          /   /                      \   \ Blocking    |  |
          |  |         /   / Dispatching   Readying \   \            |  |
          |  |        /   V                          \   V           |  |
          |  |      +-----------+    Blocking     +---------+        |  |
          |  |      | Executing | --------------> | Blocked |        |  |
          |  |      +-----------+                 +---------+        |  |
          |  |                                                       |  |
          |  |                                                       |  |
          |  +-------------------------------------------------------+  |
          |                         Non-existent                        |
          +-------------------------------------------------------------+

Figure   18.1: RTEMS Task States

A task occupies the blocked state whenever it is unable to be scheduled
to run.  A running task may block itself or be blocked by other tasks
in the system.  The running task blocks itself through voluntary
operations that cause the task to wait.  The only way a task can block
a task other than itself is with the `rtems.task_suspend' directive.  A
task enters the blocked state due to any of the following conditions:

   * A task issues a `rtems.task_suspend' directive which blocks either
     itself or another task in the system.

   * The running task issues a `rtems.message_queue_receive' directive
     with the wait option and the message queue is empty.

   * The running task issues an `rtems.event_receive' directive with
     the wait option and the currently pending events do not satisfy
     the request.

   * The running task issues a `rtems.semaphore_obtain' directive with
     the wait option and the requested semaphore is unavailable.

   * The running task issues a `rtems.task_wake_after' directive which
     blocks the task for the given time interval.  If the time interval
     specified is zero, the task yields the processor and remains in
     the ready state.

   * The running task issues a `rtems.task_wake_when' directive which
     blocks the task until the requested date and time arrives.

   * The running task issues a `rtems.region_get_segment' directive
     with the wait option and there is not an available segment large
     enough to satisfy the task's request.

   * The running task issues a `rtems.rate_monotonic_period' directive
     and must wait for the specified rate monotonic period to conclude.

A blocked task may also be suspended.  Therefore, both the suspension
and the blocking condition must be removed before the task becomes
ready to run again.

A task occupies the ready state when it is able to be scheduled to run,
but currently does not have control of the processor.  Tasks of the
same or higher priority will yield the processor by either becoming
blocked, completing their timeslice, or being deleted.  All tasks with
the same priority will execute in FIFO order.  A task enters the ready
state due to any of the following conditions:

   * A running task issues a `rtems.task_resume' directive for a task
     that is suspended and the task is not blocked waiting on any
     resource.

   * A running task issues a `rtems.message_queue_send',
     `rtems.message_queue_broadcast', or a `rtems.message_queue_urgent'
     directive which posts a message to the queue on which the blocked
     task is waiting.

   * A running task issues an `rtems.event_send' directive which sends
     an event condition to a task which is blocked waiting on that
     event condition.

   * A running task issues a `rtems.semaphore_release' directive which
     releases the semaphore on which the blocked task is waiting.

   * A timeout interval expires for a task which was blocked by a call
     to the `rtems.task_wake_after' directive.

   * A timeout period expires for a task which blocked by a call to the
     `rtems.task_wake_when' directive.

   * A running task issues a `rtems.region_return_segment' directive
     which releases a segment to the region on which the blocked task
     is waiting and a resulting segment is large enough to satisfy the
     task's request.

   * A rate monotonic period expires for a task which blocked by a call
     to the `rtems.rate_monotonic_period' directive.

   * A timeout interval expires for a task which was blocked waiting on
     a message, event, semaphore, or segment with a timeout specified.

   * A running task issues a directive which deletes a message queue, a
     semaphore, or a region on which the blocked task is waiting.

   * A running task issues a `rtems.task_restart' directive for the
     blocked task.

   * The running task, with its preemption mode enabled, may be made
     ready by issuing any of the directives that may unblock a task
     with a higher priority.  This directive may be issued from the
     running task itself or from an ISR.

     A ready task occupies the executing state when it has control of
     the CPU.  A task enters the executing state due to any of the
     following conditions:

   * The task is the highest priority ready task in the system.

   * The running task blocks and the task is next in the scheduling
     queue.  The task may be of equal priority as in round-robin
     scheduling or the task may possess the highest priority of the
     remaining ready tasks.

   * The running task may reenable its preemption mode and a task
     exists in the ready queue that has a higher priority than the
     running task.

   * The running task lowers its own priority and another task is of
     higher priority as a result.

   * The running task raises the priority of a task above its own and
     the running task is in preemption mode.



File: ada_user.info,  Node: Rate Monotonic Manager,  Next: Rate Monotonic Manager Introduction,  Prev: Scheduling Concepts Task State Transitions,  Up: Top

19 Rate Monotonic Manager
*************************

* Menu:

* Rate Monotonic Manager Introduction::
* Rate Monotonic Manager Background::
* Rate Monotonic Manager Operations::
* Rate Monotonic Manager Directives::


File: ada_user.info,  Node: Rate Monotonic Manager Introduction,  Next: Rate Monotonic Manager Background,  Prev: Rate Monotonic Manager,  Up: Rate Monotonic Manager

19.1 Introduction
=================

The rate monotonic manager provides facilities to implement tasks which
execute in a periodic fashion.  Critically, it also gathers information
about the execution of those periods and can provide important
statistics to the user which can be used to analyze and tune the
application.  The directives provided by the rate monotonic manager are:

   * `rtems.rate_monotonic_create' - Create a rate monotonic period

   * `rtems.rate_monotonic_ident' - Get ID of a period

   * `rtems.rate_monotonic_cancel' - Cancel a period

   * `rtems.rate_monotonic_delete' - Delete a rate monotonic period

   * `rtems.rate_monotonic_period' - Conclude current/Start next period

   * `rtems.rate_monotonic_get_status' - Obtain status from a period

   * `rtems.rate_monotonic_get_statistics' - Obtain statistics from a
     period

   * `rtems.rate_monotonic_reset_statistics' - Reset statistics for a
     period

   * `rtems.rate_monotonic_reset_all_statistics' - Reset statistics for
     all periods

   * `rtems.rate_monotonic_report_statistics' - Print period statistics
     report


File: ada_user.info,  Node: Rate Monotonic Manager Background,  Next: Rate Monotonic Manager Rate Monotonic Manager Required Support,  Prev: Rate Monotonic Manager Introduction,  Up: Rate Monotonic Manager

19.2 Background
===============

* Menu:

* Rate Monotonic Manager Rate Monotonic Manager Required Support::
* Rate Monotonic Manager Period Statistics::
* Rate Monotonic Manager Rate Monotonic Manager Definitions::
* Rate Monotonic Manager Rate Monotonic Scheduling Algorithm::
* Rate Monotonic Manager Schedulability Analysis::

The rate monotonic manager provides facilities to manage the execution
of periodic tasks.  This manager was designed to support application
designers who utilize the Rate Monotonic Scheduling Algorithm (RMS) to
ensure that their periodic tasks will meet their deadlines, even under
transient overload conditions.  Although designed for hard real-time
systems, the services provided by the rate monotonic manager may be
used by any application which requires periodic tasks.


File: ada_user.info,  Node: Rate Monotonic Manager Rate Monotonic Manager Required Support,  Next: Rate Monotonic Manager Period Statistics,  Prev: Rate Monotonic Manager Background,  Up: Rate Monotonic Manager Background

19.2.1 Rate Monotonic Manager Required Support
----------------------------------------------

A clock tick is required to support the functionality provided by this
manager.


File: ada_user.info,  Node: Rate Monotonic Manager Period Statistics,  Next: Rate Monotonic Manager Rate Monotonic Manager Definitions,  Prev: Rate Monotonic Manager Rate Monotonic Manager Required Support,  Up: Rate Monotonic Manager Background

19.2.2 Period Statistics
------------------------

This manager maintains a set of statistics on each period.  These
statistics are reset implictly at period creation time and may be reset
or obtained at any time by the application.  The following is a list of
the information kept:

   * `owner' is the id of the thread that owns this period.

   * `count' is the total number of periods executed.

   * `missed_count' is the number of periods that were missed.

   * `min_cpu_time' is the minimum amount of CPU execution time consumed
     on any execution of the periodic loop.

   * `max_cpu_time' is the maximum amount of CPU execution time consumed
     on any execution of the periodic loop.

   * `total_cpu_time' is the total amount of CPU execution time consumed
     by executions of the periodic loop.

   * `min_wall_time' is the minimum amount of wall time that passed on
     any execution of the periodic loop.

   * `max_wall_time' is the maximum amount of wall time that passed on
     any execution of the periodic loop.

   * `total_wall_time' is the total amount of wall time that passed
     during executions of the periodic loop.


The period statistics information is inexpensive to maintain and can
provide very useful insights into the execution characteristics of a
periodic task loop.  But it is just information.  The period statistics
reported must be analyzed by the user in terms of what the applications
is.  For example, in an application where priorities are assigned by
the Rate Monotonic Algorithm, it would be very undesirable for high
priority (i.e. frequency) tasks to miss their period.  Similarly, in
nearly any application, if a task were supposed to execute its periodic
loop every 10 milliseconds and it averaged 11 milliseconds, then
application requirements are not being met.

The information reported can be used to determine the "hot spots" in
the application.  Given a period's id, the user can determine the
length of that period.  From that information and the CPU usage, the
user can calculate the percentage of CPU time consumed by that periodic
task.  For example, a task executing for 20 milliseconds every 200
milliseconds is consuming 10 percent of the processor's execution time.
This is usually enough to make it a good candidate for optimization.

However, execution time alone is not enough to gauge the value of
optimizing a particular task.  It is more important to optimize a task
executing 2 millisecond every 10 milliseconds (20 percent of the CPU)
than one executing 10 milliseconds every 100 (10 percent of the CPU).
As a general rule of thumb, the higher frequency at which a task
executes, the more important it is to optimize that task.


File: ada_user.info,  Node: Rate Monotonic Manager Rate Monotonic Manager Definitions,  Next: Rate Monotonic Manager Rate Monotonic Scheduling Algorithm,  Prev: Rate Monotonic Manager Period Statistics,  Up: Rate Monotonic Manager Background

19.2.3 Rate Monotonic Manager Definitions
-----------------------------------------

A periodic task is one which must be executed at a regular interval.
The interval between successive iterations of the task is referred to
as its period.  Periodic tasks can be characterized by the length of
their period and execution time.  The period and execution time of a
task can be used to determine the processor utilization for that task.
Processor utilization is the percentage of processor time used and can
be calculated on a per-task or system-wide basis.  Typically, the task's
worst-case execution time will be less than its period.  For example, a
periodic task's requirements may state that it should execute for 10
milliseconds every 100 milliseconds.  Although the execution time may
be the average, worst, or best case, the worst-case execution time is
more appropriate for use when analyzing system behavior under transient
overload conditions.

In contrast, an aperiodic task executes at irregular intervals and has
only a soft deadline.  In other words, the deadlines for aperiodic
tasks are not rigid, but adequate response times are desirable.  For
example, an aperiodic task may process user input from a terminal.

Finally, a sporadic task is an aperiodic task with a hard deadline and
minimum interarrival time.  The minimum interarrival time is the
minimum period of time which exists between successive iterations of
the task.  For example, a sporadic task could be used to process the
pressing of a fire button on a joystick.  The mechanical action of the
fire button ensures a minimum time period between successive
activations, but the missile must be launched by a hard deadline.


File: ada_user.info,  Node: Rate Monotonic Manager Rate Monotonic Scheduling Algorithm,  Next: Rate Monotonic Manager Schedulability Analysis,  Prev: Rate Monotonic Manager Rate Monotonic Manager Definitions,  Up: Rate Monotonic Manager Background

19.2.4 Rate Monotonic Scheduling Algorithm
------------------------------------------

The Rate Monotonic Scheduling Algorithm (RMS) is important to real-time
systems designers because it allows one to guarantee that a set of
tasks is schedulable.  A set of tasks is said to be schedulable if all
of the tasks can meet their deadlines.  RMS provides a set of rules
which can be used to perform a guaranteed schedulability analysis for a
task set.  This analysis determines whether a task set is schedulable
under worst-case conditions and emphasizes the predictability of the
system's behavior.  It has been proven that:

     RMS is an optimal static priority algorithm for scheduling
     independent, preemptible, periodic tasks on a single processor.

RMS is optimal in the sense that if a set of tasks can be scheduled by
any static priority algorithm, then RMS will be able to schedule that
task set.  RMS bases it schedulability analysis on the processor
utilization level below which all deadlines can be met.

RMS calls for the static assignment of task priorities based upon their
period.  The shorter a task's period, the higher its priority.  For
example, a task with a 1 millisecond period has higher priority than a
task with a 100 millisecond period.  If two tasks have the same period,
then RMS does not distinguish between the tasks.  However, RTEMS
specifies that when given tasks of equal priority, the task which has
been ready longest will execute first.  RMS's priority assignment
scheme does not provide one with exact numeric values for task
priorities.  For example, consider the following task set and priority
assignments:

     +--------------------+---------------------+---------------------+
     |        Task        |       Period        |      Priority       |
     |                    |  (in milliseconds)  |                     |
     +--------------------+---------------------+---------------------+
     |         1          |         100         |         Low         |
     +--------------------+---------------------+---------------------+
     |         2          |          50         |       Medium        |
     +--------------------+---------------------+---------------------+
     |         3          |          50         |       Medium        |
     +--------------------+---------------------+---------------------+
     |         4          |          25         |        High         |
     +--------------------+---------------------+---------------------+

RMS only calls for task 1 to have the lowest priority, task 4 to have
the highest priority, and tasks 2 and 3 to have an equal priority
between that of tasks 1 and 4.  The actual RTEMS priorities assigned to
the tasks must only adhere to those guidelines.

Many applications have tasks with both hard and soft deadlines.  The
tasks with hard deadlines are typically referred to as the critical
task set, with the soft deadline tasks being the non-critical task set.
The critical task set can be scheduled using RMS, with the non-critical
tasks not executing under transient overload, by simply assigning
priorities such that the lowest priority critical task (i.e. longest
period) has a higher priority than the highest priority non-critical
task.  Although RMS may be used to assign priorities to the
non-critical tasks, it is not necessary.  In this instance,
schedulability is only guaranteed for the critical task set.


File: ada_user.info,  Node: Rate Monotonic Manager Schedulability Analysis,  Next: Rate Monotonic Manager Assumptions,  Prev: Rate Monotonic Manager Rate Monotonic Scheduling Algorithm,  Up: Rate Monotonic Manager Background

19.2.5 Schedulability Analysis
------------------------------

* Menu:

* Rate Monotonic Manager Assumptions::
* Rate Monotonic Manager Processor Utilization Rule::
* Rate Monotonic Manager Processor Utilization Rule Example::
* Rate Monotonic Manager First Deadline Rule::
* Rate Monotonic Manager First Deadline Rule Example::
* Rate Monotonic Manager Relaxation of Assumptions::
* Rate Monotonic Manager Further Reading::

RMS allows application designers to ensure that tasks can meet all
deadlines, even under transient overload, without knowing exactly when
any given task will execute by applying proven schedulability analysis
rules.


File: ada_user.info,  Node: Rate Monotonic Manager Assumptions,  Next: Rate Monotonic Manager Processor Utilization Rule,  Prev: Rate Monotonic Manager Schedulability Analysis,  Up: Rate Monotonic Manager Schedulability Analysis

19.2.5.1 Assumptions
....................

The schedulability analysis rules for RMS were developed based on the
following assumptions:

   * The requests for all tasks for which hard deadlines exist are
     periodic, with a constant interval between requests.

   * Each task must complete before the next request for it occurs.

   * The tasks are independent in that a task does not depend on the
     initiation or completion of requests for other tasks.

   * The execution time for each task without preemption or
     interruption is constant and does not vary.

   * Any non-periodic tasks in the system are special.  These tasks
     displace periodic tasks while executing and do not have hard,
     critical deadlines.

Once the basic schedulability analysis is understood, some of the above
assumptions can be relaxed and the side-effects accounted for.


File: ada_user.info,  Node: Rate Monotonic Manager Processor Utilization Rule,  Next: Rate Monotonic Manager Processor Utilization Rule Example,  Prev: Rate Monotonic Manager Assumptions,  Up: Rate Monotonic Manager Schedulability Analysis

19.2.5.2 Processor Utilization Rule
...................................

The Processor Utilization Rule requires that processor utilization be
calculated based upon the period and execution time of each task.  The
fraction of processor time spent executing task index is Time(index) /
Period(index).  The processor utilization can be calculated as follows:

     Utilization = 0

     for index = 1 to maximum_tasks
       Utilization = Utilization + (Time(index)/Period(index))

To ensure schedulability even under transient overload, the processor
utilization must adhere to the following rule:

     Utilization = maximum_tasks * (2**(1/maximum_tasks) - 1)

As the number of tasks increases, the above formula approaches ln(2)
for a worst-case utilization factor of approximately 0.693.  Many tasks
sets can be scheduled with a greater utilization factor.  In fact, the
average processor utilization threshold for a randomly generated task
set is approximately 0.88.


File: ada_user.info,  Node: Rate Monotonic Manager Processor Utilization Rule Example,  Next: Rate Monotonic Manager First Deadline Rule,  Prev: Rate Monotonic Manager Processor Utilization Rule,  Up: Rate Monotonic Manager Schedulability Analysis

19.2.5.3 Processor Utilization Rule Example
...........................................

This example illustrates the application of the Processor Utilization
Rule to an application with three critical periodic tasks.  The
following table details the RMS priority, period, execution time, and
processor utilization for each task:

         +------------+----------+--------+-----------+-------------+
         |    Task    |   RMS    | Period | Execution |  Processor  |
         |            | Priority |        |   Time    | Utilization |
         +------------+----------+--------+-----------+-------------+
         |     1      |   High   |  100   |    15     |    0.15     |
         +------------+----------+--------+-----------+-------------+
         |     2      |  Medium  |  200   |    50     |    0.25     |
         +------------+----------+--------+-----------+-------------+
         |     3      |   Low    |  300   |   100     |    0.33     |
         +------------+----------+--------+-----------+-------------+

The total processor utilization for this task set is 0.73 which is
below the upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by the
Processor Utilization Rule.  Therefore, this task set is guaranteed to
be schedulable using RMS.


File: ada_user.info,  Node: Rate Monotonic Manager First Deadline Rule,  Next: Rate Monotonic Manager First Deadline Rule Example,  Prev: Rate Monotonic Manager Processor Utilization Rule Example,  Up: Rate Monotonic Manager Schedulability Analysis

19.2.5.4 First Deadline Rule
............................

If a given set of tasks do exceed the processor utilization upper limit
imposed by the Processor Utilization Rule, they can still be guaranteed
to meet all their deadlines by application of the First Deadline Rule.
This rule can be stated as follows:

For a given set of independent periodic tasks, if each task meets its
first deadline when all tasks are started at the same time, then the
deadlines will always be met for any combination of start times.

A key point with this rule is that ALL periodic tasks are assumed to
start at the exact same instant in time.  Although this assumption may
seem to be invalid,  RTEMS makes it quite easy to ensure.  By having a
non-preemptible user initialization task, all application tasks,
regardless of priority, can be created and started before the
initialization deletes itself.  This technique ensures that all tasks
begin to compete for execution time at the same instant - when the user
initialization task deletes itself.


File: ada_user.info,  Node: Rate Monotonic Manager First Deadline Rule Example,  Next: Rate Monotonic Manager Relaxation of Assumptions,  Prev: Rate Monotonic Manager First Deadline Rule,  Up: Rate Monotonic Manager Schedulability Analysis

19.2.5.5 First Deadline Rule Example
....................................

The First Deadline Rule can ensure schedulability even when the
Processor Utilization Rule fails.  The example below is a modification
of the Processor Utilization Rule example where task execution time has
been increased from 15 to 25 units.  The following table details the
RMS priority, period, execution time, and processor utilization for
each task:

         +------------+----------+--------+-----------+-------------+
         |    Task    |   RMS    | Period | Execution |  Processor  |
         |            | Priority |        |   Time    | Utilization |
         +------------+----------+--------+-----------+-------------+
         |     1      |   High   |  100   |    25     |    0.25     |
         +------------+----------+--------+-----------+-------------+
         |     2      |  Medium  |  200   |    50     |    0.25     |
         +------------+----------+--------+-----------+-------------+
         |     3      |   Low    |  300   |   100     |    0.33     |
         +------------+----------+--------+-----------+-------------+

The total processor utilization for the modified task set is 0.83 which
is above the upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by
the Processor Utilization Rule.  Therefore, this task set is not
guaranteed to be schedulable using RMS.  However, the First Deadline
Rule can guarantee the schedulability of this task set.  This rule
calls for one to examine each occurrence of deadline until either all
tasks have met their deadline or one task failed to meet its first
deadline.  The following table details the time of each deadline
occurrence, the maximum number of times each task may have run, the
total execution time, and whether all the deadlines have been met.

     +----------+------+------+------+----------------------+---------------+
     | Deadline | Task | Task | Task |        Total         | All Deadlines |
     |   Time   |  1   |  2   |  3   |    Execution Time    |     Met?      |
     +----------+------+------+------+----------------------+---------------+
     |   100    |  1   |  1   |  1   |  25 + 50 + 100 = 175 |      NO       |
     +----------+------+------+------+----------------------+---------------+
     |   200    |  2   |  1   |  1   |  50 + 50 + 100 = 200 |     YES       |
     +----------+------+------+------+----------------------+---------------+

The key to this analysis is to recognize when each task will execute.
For example	at time 100, task 1 must have met its first deadline,
but tasks 2 and 3 may also have begun execution.  In this example, at
time 100 tasks 1 and 2 have completed execution and thus have met their
first deadline.  Tasks 1 and 2 have used (25 + 50) = 75 time units,
leaving (100 - 75) = 25 time units for task 3 to begin.  Because task 3
takes 100 ticks to execute, it will not have completed execution at
time 100.  Thus at time 100, all of the tasks except task 3 have met
their first deadline.

At time 200, task 1 must have met its second deadline and task 2 its
first deadline.  As a result, of the first 200 time units, task 1 uses
(2 * 25) = 50 and task 2 uses 50, leaving (200 - 100) time units for
task 3.  Task 3 requires 100 time units to execute, thus it will have
completed execution at time 200.  Thus, all of the tasks have met their
first deadlines at time 200, and the task set is schedulable using the
First Deadline Rule.


File: ada_user.info,  Node: Rate Monotonic Manager Relaxation of Assumptions,  Next: Rate Monotonic Manager Further Reading,  Prev: Rate Monotonic Manager First Deadline Rule Example,  Up: Rate Monotonic Manager Schedulability Analysis

19.2.5.6 Relaxation of Assumptions
..................................

The assumptions used to develop the RMS schedulability rules are
uncommon in most real-time systems.  For example, it was assumed that
tasks have constant unvarying execution time.  It is possible to relax
this assumption, simply by using the worst-case execution time of each
task.

Another assumption is that the tasks are independent.  This means that
the tasks do not wait for one another or contend for resources.  This
assumption can be relaxed by accounting for the amount of time a task
spends waiting to acquire resources.  Similarly, each task's execution
time must account for any I/O performed and any RTEMS directive calls.

In addition, the assumptions did not account for the time spent
executing interrupt service routines.  This can be accounted for by
including all the processor utilization by interrupt service routines
in the utilization calculation.  Similarly, one should also account for
the impact of delays in accessing local memory caused by direct memory
access and other processors accessing local dual-ported memory.

The assumption that nonperiodic tasks are used only for initialization
or failure-recovery can be relaxed by placing all periodic tasks in the
critical task set.  This task set can be scheduled and analyzed using
RMS.  All nonperiodic tasks are placed in the non-critical task set.
Although the critical task set can be guaranteed to execute even under
transient overload, the non-critical task set is not guaranteed to
execute.

In conclusion, the application designer must be fully cognizant of the
system and its run-time behavior when performing schedulability
analysis for a system using RMS.  Every hardware and software factor
which impacts the execution time of each task must be accounted for in
the schedulability analysis.


File: ada_user.info,  Node: Rate Monotonic Manager Further Reading,  Next: Rate Monotonic Manager Operations,  Prev: Rate Monotonic Manager Relaxation of Assumptions,  Up: Rate Monotonic Manager Schedulability Analysis

19.2.5.7 Further Reading
........................

For more information on Rate Monotonic Scheduling and its
schedulability analysis, the reader is referred to the following:

   ` ' `C. L. Liu and J. W. Layland. "Scheduling Algorithms for
     Multiprogramming in a Hard Real Time Environment." Journal of the
     Association of Computing Machinery. January 1973. pp. 46-61.'

   ` ' `John Lehoczky, Lui Sha, and Ye Ding. "The Rate Monotonic
     Scheduling Algorithm: Exact Characterization and Average Case
     Behavior."  IEEE Real-Time Systems Symposium. 1989. pp. 166-171.'

   ` ' `Lui Sha and John Goodenough. "Real-Time Scheduling Theory and
     Ada."  IEEE Computer. April 1990. pp. 53-62.'

   ` ' `Alan Burns. "Scheduling hard real-time systems: a review."
     Software Engineering Journal. May 1991. pp. 116-128.'


File: ada_user.info,  Node: Rate Monotonic Manager Operations,  Next: Rate Monotonic Manager Creating a Rate Monotonic Period,  Prev: Rate Monotonic Manager Further Reading,  Up: Rate Monotonic Manager

19.3 Operations
===============

* Menu:

* Rate Monotonic Manager Creating a Rate Monotonic Period::
* Rate Monotonic Manager Manipulating a Period::
* Rate Monotonic Manager Obtaining the Status of a Period::
* Rate Monotonic Manager Canceling a Period::
* Rate Monotonic Manager Deleting a Rate Monotonic Period::
* Rate Monotonic Manager Examples::
* Rate Monotonic Manager Simple Periodic Task::
* Rate Monotonic Manager Task with Multiple Periods::


File: ada_user.info,  Node: Rate Monotonic Manager Creating a Rate Monotonic Period,  Next: Rate Monotonic Manager Manipulating a Period,  Prev: Rate Monotonic Manager Operations,  Up: Rate Monotonic Manager Operations

19.3.1 Creating a Rate Monotonic Period
---------------------------------------

The `rtems.rate_monotonic_create' directive creates a rate monotonic
period which is to be used by the calling task to delineate a period.
RTEMS allocates a Period Control Block (PCB) from the PCB free list.
This data structure is used by RTEMS to manage the newly created rate
monotonic period.  RTEMS returns a unique period ID to the application
which is used by other rate monotonic manager directives to access this
rate monotonic period.


File: ada_user.info,  Node: Rate Monotonic Manager Manipulating a Period,  Next: Rate Monotonic Manager Obtaining the Status of a Period,  Prev: Rate Monotonic Manager Creating a Rate Monotonic Period,  Up: Rate Monotonic Manager Operations

19.3.2 Manipulating a Period
----------------------------

The `rtems.rate_monotonic_period' directive is used to establish and
maintain periodic execution utilizing a previously created rate
monotonic period.   Once initiated by the `rtems.rate_monotonic_period'
directive, the period is said to run until it either expires or is
reinitiated.  The state of the rate monotonic period results in one of
the following scenarios:

   * If the rate monotonic period is running, the calling task will be
     blocked for the remainder of the outstanding period and, upon
     completion of that period, the period will be reinitiated with the
     specified period.

   * If the rate monotonic period is not currently running and has not
     expired, it is initiated with a length of period ticks and the
     calling task returns immediately.

   * If the rate monotonic period has expired before the task invokes
     the `rtems.rate_monotonic_period' directive, the period will be
     initiated with a length of period ticks and the calling task
     returns immediately with a timeout error status.



File: ada_user.info,  Node: Rate Monotonic Manager Obtaining the Status of a Period,  Next: Rate Monotonic Manager Canceling a Period,  Prev: Rate Monotonic Manager Manipulating a Period,  Up: Rate Monotonic Manager Operations

19.3.3 Obtaining the Status of a Period
---------------------------------------

If the `rtems.rate_monotonic_period' directive is invoked with a period
of `RTEMS.PERIOD_STATUS' ticks, the current state of the specified rate
monotonic period will be returned.  The following table details the
relationship between the period's status and the directive status code
returned by the `rtems.rate_monotonic_period' directive:

   * `RTEMS.SUCCESSFUL' - period is running

   * `RTEMS.TIMEOUT' - period has expired

   * `RTEMS.NOT_DEFINED' - period has never been initiated

Obtaining the status of a rate monotonic period does not alter the
state or length of that period.


File: ada_user.info,  Node: Rate Monotonic Manager Canceling a Period,  Next: Rate Monotonic Manager Deleting a Rate Monotonic Period,  Prev: Rate Monotonic Manager Obtaining the Status of a Period,  Up: Rate Monotonic Manager Operations

19.3.4 Canceling a Period
-------------------------

The `rtems.rate_monotonic_cancel' directive is used to stop the period
maintained by the specified rate monotonic period.  The period is
stopped and the rate monotonic period can be reinitiated using the
`rtems.rate_monotonic_period' directive.


File: ada_user.info,  Node: Rate Monotonic Manager Deleting a Rate Monotonic Period,  Next: Rate Monotonic Manager Examples,  Prev: Rate Monotonic Manager Canceling a Period,  Up: Rate Monotonic Manager Operations

19.3.5 Deleting a Rate Monotonic Period
---------------------------------------

The `rtems.rate_monotonic_delete' directive is used to delete a rate
monotonic period.  If the period is running and has not expired, the
period is automatically canceled.  The rate monotonic period's control
block is returned to the PCB free list when it is deleted.  A rate
monotonic period can be deleted by a task other than the task which
created the period.


File: ada_user.info,  Node: Rate Monotonic Manager Examples,  Next: Rate Monotonic Manager Simple Periodic Task,  Prev: Rate Monotonic Manager Deleting a Rate Monotonic Period,  Up: Rate Monotonic Manager Operations

19.3.6 Examples
---------------

The following sections illustrate common uses of rate monotonic periods
to construct periodic tasks.


File: ada_user.info,  Node: Rate Monotonic Manager Simple Periodic Task,  Next: Rate Monotonic Manager Task with Multiple Periods,  Prev: Rate Monotonic Manager Examples,  Up: Rate Monotonic Manager Operations

19.3.7 Simple Periodic Task
---------------------------

This example consists of a single periodic task which, after
initialization, executes every 100 clock ticks.

     rtems_task Periodic_task(rtems_task_argument arg)
     {
       rtems_name        name;
       rtems_id          period;
       rtems_status_code status;

       name = rtems_build_name( 'P', 'E', 'R', 'D' );

       status = rtems_rate_monotonic_create( name, &period );
       if ( status != RTEMS_STATUS_SUCCESSFUL ) {
         printf( "rtems_monotonic_create failed with status of %d.\n", rc );
         exit( 1 );
       }


       while ( 1 ) {
         if ( rtems_rate_monotonic_period( period, 100 ) == RTEMS_TIMEOUT )
           break;

         /* Perform some periodic actions */
       }

       /* missed period so delete period and SELF */

       status = rtems_rate_monotonic_delete( period );
       if ( status != RTEMS_STATUS_SUCCESSFUL ) {
         printf( "rtems_rate_monotonic_delete failed with status of %d.\n", status );
         exit( 1 );
       }

       status = rtems_task_delete( SELF );    /* should not return */
       printf( "rtems_task_delete returned with status of %d.\n", status );
       exit( 1 );
     }

The above task creates a rate monotonic period as part of its
initialization.  The first time the loop is executed, the
`rtems.rate_monotonic_period' directive will initiate the period for
100 ticks and return immediately.  Subsequent invocations of the
`rtems.rate_monotonic_period' directive will result in the task
blocking for the remainder of the 100 tick period.  If, for any reason,
the body of the loop takes more than 100 ticks to execute, the
`rtems.rate_monotonic_period' directive will return the `RTEMS.TIMEOUT'
status.  If the above task misses its deadline, it will delete the rate
monotonic period and itself.


File: ada_user.info,  Node: Rate Monotonic Manager Task with Multiple Periods,  Next: Rate Monotonic Manager Directives,  Prev: Rate Monotonic Manager Simple Periodic Task,  Up: Rate Monotonic Manager Operations

19.3.8 Task with Multiple Periods
---------------------------------

This example consists of a single periodic task which, after
initialization, performs two sets of actions every 100 clock ticks.
The first set of actions is performed in the first forty clock ticks of
every 100 clock ticks, while the second set of actions is performed
between the fortieth and seventieth clock ticks.  The last thirty clock
ticks are not used by this task.

     rtems_task Periodic_task(rtems_task_argument arg)
     {
       rtems_name        name_1, name_2;
       rtems_id          period_1, period_2;
       rtems_status_code status;

       name_1 = rtems_build_name( 'P', 'E', 'R', '1' );
       name_2 = rtems_build_name( 'P', 'E', 'R', '2' );

       (void ) rtems_rate_monotonic_create( name_1, &period_1 );
       (void ) rtems_rate_monotonic_create( name_2, &period_2 );

       while ( 1 ) {
         if ( rtems_rate_monotonic_period( period_1, 100 ) == TIMEOUT )
           break;

         if ( rtems_rate_monotonic_period( period_2, 40 ) == TIMEOUT )
           break;

         /*
          *  Perform first set of actions between clock
          *  ticks 0 and 39 of every 100 ticks.
          */

         if ( rtems_rate_monotonic_period( period_2, 30 ) == TIMEOUT )
           break;

         /*
          *  Perform second set of actions between clock 40 and 69
          *  of every 100 ticks.  THEN ...
          *
          *  Check to make sure we didn't miss the period_2 period.
          */

         if ( rtems_rate_monotonic_period( period_2, STATUS ) == TIMEOUT )
           break;

         (void) rtems_rate_monotonic_cancel( period_2 );
       }

       /* missed period so delete period and SELF */

       (void ) rtems_rate_monotonic_delete( period_1 );
       (void ) rtems_rate_monotonic_delete( period_2 );
       (void ) task_delete( SELF );
     }

The above task creates two rate monotonic periods as part of its
initialization.  The first time the loop is executed, the
`rtems.rate_monotonic_period' directive will initiate the period_1
period for 100 ticks and return immediately.  Subsequent invocations of
the `rtems.rate_monotonic_period' directive for period_1 will result in
the task blocking for the remainder of the 100 tick period.  The
period_2 period is used to control the execution time of the two sets
of actions within each 100 tick period established by period_1.  The
`rtems.rate_monotonic_cancel( period_2 )' call is performed to ensure
that the period_2 period does not expire while the task is blocked on
the period_1 period.  If this cancel operation were not performed,
every time the `rtems.rate_monotonic_period( period_2, 40 )' call is
executed, except for the initial one, a directive status of
`RTEMS.TIMEOUT' is returned.  It is important to note that every time
this call is made, the period_2 period will be initiated immediately
and the task will not block.

If, for any reason, the task misses any deadline, the
`rtems.rate_monotonic_period' directive will return the `RTEMS.TIMEOUT'
directive status.  If the above task misses its deadline, it will
delete the rate monotonic periods and itself.


File: ada_user.info,  Node: Rate Monotonic Manager Directives,  Next: Rate Monotonic Manager RATE_MONOTONIC_CREATE - Create a rate monotonic period,  Prev: Rate Monotonic Manager Task with Multiple Periods,  Up: Rate Monotonic Manager

19.4 Directives
===============

* Menu:

* Rate Monotonic Manager RATE_MONOTONIC_CREATE - Create a rate monotonic period::
* Rate Monotonic Manager RATE_MONOTONIC_IDENT - Get ID of a period::
* Rate Monotonic Manager RATE_MONOTONIC_CANCEL - Cancel a period::
* Rate Monotonic Manager RATE_MONOTONIC_DELETE - Delete a rate monotonic period::
* Rate Monotonic Manager RATE_MONOTONIC_PERIOD - Conclude current/Start next period::
* Rate Monotonic Manager RATE_MONOTONIC_GET_STATUS - Obtain status from a period::
* Rate Monotonic Manager RATE_MONOTONIC_GET_STATISTICS - Obtain statistics from a period::
* Rate Monotonic Manager RATE_MONOTONIC_RESET_STATISTICS - Reset statistics for a period::
* Rate Monotonic Manager RATE_MONOTONIC_RESET_ALL_STATISTICS - Reset statistics for all periods::
* Rate Monotonic Manager RATE_MONOTONIC_REPORT_STATISTICS - Print period statistics report::

This section details the rate monotonic manager's directives.  A
subsection is dedicated to each of this manager's directives and
describes the calling sequence, related constants, usage, and status
codes.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_CREATE - Create a rate monotonic period,  Next: Rate Monotonic Manager RATE_MONOTONIC_IDENT - Get ID of a period,  Prev: Rate Monotonic Manager Directives,  Up: Rate Monotonic Manager Directives

19.4.1 RATE_MONOTONIC_CREATE - Create a rate monotonic period
-------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Create (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - rate monotonic period created successfully
`RTEMS.INVALID_NAME' - invalid period name
`RTEMS.TOO_MANY' - too many periods created

DESCRIPTION:
------------

This directive creates a rate monotonic period.  The assigned rate
monotonic id is returned in id.  This id is used to access the period
with other rate monotonic manager directives.  For control and
maintenance of the rate monotonic period, RTEMS allocates a PCB from
the local PCB free pool and initializes it.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_IDENT - Get ID of a period,  Next: Rate Monotonic Manager RATE_MONOTONIC_CANCEL - Cancel a period,  Prev: Rate Monotonic Manager RATE_MONOTONIC_CREATE - Create a rate monotonic period,  Up: Rate Monotonic Manager Directives

19.4.2 RATE_MONOTONIC_IDENT - Get ID of a period
------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Ident (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - period identified successfully
`RTEMS.INVALID_NAME' - period name not found

DESCRIPTION:
------------

This directive obtains the period id associated with the period name to
be acquired.  If the period name is not unique, then the period id will
match one of the periods with that name.  However, this period id is
not guaranteed to correspond to the desired period.  The period id is
used to access this period in other rate monotonic manager directives.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_CANCEL - Cancel a period,  Next: Rate Monotonic Manager RATE_MONOTONIC_DELETE - Delete a rate monotonic period,  Prev: Rate Monotonic Manager RATE_MONOTONIC_IDENT - Get ID of a period,  Up: Rate Monotonic Manager Directives

19.4.3 RATE_MONOTONIC_CANCEL - Cancel a period
----------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Cancel (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - period canceled successfully
`RTEMS.INVALID_ID' - invalid rate monotonic period id
`RTEMS.NOT_OWNER_OF_RESOURCE' - rate monotonic period not created by
calling task

DESCRIPTION:
------------

This directive cancels the rate monotonic period id.  This period will
be reinitiated by the next invocation of `rtems.rate_monotonic_period'
with id.

NOTES:
------

This directive will not cause the running task to be preempted.

The rate monotonic period specified by id must have been created by the
calling task.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_DELETE - Delete a rate monotonic period,  Next: Rate Monotonic Manager RATE_MONOTONIC_PERIOD - Conclude current/Start next period,  Prev: Rate Monotonic Manager RATE_MONOTONIC_CANCEL - Cancel a period,  Up: Rate Monotonic Manager Directives

19.4.4 RATE_MONOTONIC_DELETE - Delete a rate monotonic period
-------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - period deleted successfully
`RTEMS.INVALID_ID' - invalid rate monotonic period id

DESCRIPTION:
------------

This directive deletes the rate monotonic period specified by id.  If
the period is running, it is automatically canceled.  The PCB for the
deleted period is reclaimed by RTEMS.

NOTES:
------

This directive will not cause the running task to be preempted.

A rate monotonic period can be deleted by a task other than the task
which created the period.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_PERIOD - Conclude current/Start next period,  Next: Rate Monotonic Manager RATE_MONOTONIC_GET_STATUS - Obtain status from a period,  Prev: Rate Monotonic Manager RATE_MONOTONIC_DELETE - Delete a rate monotonic period,  Up: Rate Monotonic Manager Directives

19.4.5 RATE_MONOTONIC_PERIOD - Conclude current/Start next period
-----------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Period (
        ID      : in     RTEMS.ID;
        Length  : in     RTEMS.Interval;
        Result  :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - period initiated successfully
`RTEMS.INVALID_ID' - invalid rate monotonic period id
`RTEMS.NOT_OWNER_OF_RESOURCE' - period not created by calling task
`RTEMS.NOT_DEFINED' - period has never been initiated (only possible
when period is set to PERIOD_STATUS)
`RTEMS.TIMEOUT' - period has expired

DESCRIPTION:
------------

This directive initiates the rate monotonic period id with a length of
period ticks.  If id is running, then the calling task will block for
the remainder of the period before reinitiating the period with the
specified period.  If id was not running (either expired or never
initiated), the period is immediately initiated and the directive
returns immediately.

If invoked with a period of `RTEMS.PERIOD_STATUS' ticks, the current
state of id will be returned.  The directive status indicates the
current state of the period.  This does not alter the state or period
of the period.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_GET_STATUS - Obtain status from a period,  Next: Rate Monotonic Manager RATE_MONOTONIC_GET_STATISTICS - Obtain statistics from a period,  Prev: Rate Monotonic Manager RATE_MONOTONIC_PERIOD - Conclude current/Start next period,  Up: Rate Monotonic Manager Directives

19.4.6 RATE_MONOTONIC_GET_STATUS - Obtain status from a period
--------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Get_Status (
        ID      : in     RTEMS.ID;
        Status  :    out RTEMS.Rate_Monotonic_Period_Status;
        Result  :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - period initiated successfully
`RTEMS.INVALID_ID' - invalid rate monotonic period id
`RTEMS.INVALID_ADDRESS' - invalid address of status
DESCRIPTION:
------------

This directive returns status information associated with the rate
monotonic period id in the following data record:

     type Rate_Monotonic_Period_Status is
        begin
           Owner                      : RTEMS.ID;
           State                      : RTEMS.Rate_Monotonic_Period_States;
           Since_Last_Period          : RTEMS.Unsigned32;
           Executed_Since_Last_Period : RTEMS.Unsigned32;
        end record;

A configure time option can be used to select whether the time
information is given in ticks or seconds and nanoseconds.  The default
is seconds and nanoseconds.  If the period's state is
`RATE_MONOTONIC_INACTIVE', both time values will be set to 0.
Otherwise, both time values will contain time information since the
last invocation of the `rtems.rate_monotonic_period' directive.  More
specifically, the (ticks_)since_last_period value contains the elapsed
time which has occurred since the last invocation of the
`rtems.rate_monotonic_period' directive and the
(ticks_)executed_since_last_period contains how much processor time the
owning task has consumed since the invocation of the
`rtems.rate_monotonic_period' directive.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_GET_STATISTICS - Obtain statistics from a period,  Next: Rate Monotonic Manager RATE_MONOTONIC_RESET_STATISTICS - Reset statistics for a period,  Prev: Rate Monotonic Manager RATE_MONOTONIC_GET_STATUS - Obtain status from a period,  Up: Rate Monotonic Manager Directives

19.4.7 RATE_MONOTONIC_GET_STATISTICS - Obtain statistics from a period
----------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     NOT SUPPORTED FROM Ada BINDING

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - period initiated successfully
`RTEMS.INVALID_ID' - invalid rate monotonic period id
`RTEMS.INVALID_ADDRESS' - invalid address of statistics
DESCRIPTION:
------------

This directive returns statistics information associated with the rate
monotonic period id in the following data record:

     NOT SUPPORTED FROM Ada BINDING

This directive returns the current statistics information for the
period instance assocaited with `id'.  The information returned is
indicated by the structure above.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_RESET_STATISTICS - Reset statistics for a period,  Next: Rate Monotonic Manager RATE_MONOTONIC_RESET_ALL_STATISTICS - Reset statistics for all periods,  Prev: Rate Monotonic Manager RATE_MONOTONIC_GET_STATISTICS - Obtain statistics from a period,  Up: Rate Monotonic Manager Directives

19.4.8 RATE_MONOTONIC_RESET_STATISTICS - Reset statistics for a period
----------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Reset_Statistics (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - period initiated successfully
`RTEMS.INVALID_ID' - invalid rate monotonic period id
DESCRIPTION:
------------

This directive resets the statistics information associated with this
rate monotonic period instance.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_RESET_ALL_STATISTICS - Reset statistics for all periods,  Next: Rate Monotonic Manager RATE_MONOTONIC_REPORT_STATISTICS - Print period statistics report,  Prev: Rate Monotonic Manager RATE_MONOTONIC_RESET_STATISTICS - Reset statistics for a period,  Up: Rate Monotonic Manager Directives

19.4.9 RATE_MONOTONIC_RESET_ALL_STATISTICS - Reset statistics for all periods
-----------------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Reset_All_Statistics;

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive resets the statistics information associated with all
rate monotonic period instances.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Rate Monotonic Manager RATE_MONOTONIC_REPORT_STATISTICS - Print period statistics report,  Next: Barrier Manager,  Prev: Rate Monotonic Manager RATE_MONOTONIC_RESET_ALL_STATISTICS - Reset statistics for all periods,  Up: Rate Monotonic Manager Directives

19.4.10 RATE_MONOTONIC_REPORT_STATISTICS - Print period statistics report
-------------------------------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Rate_Monotonic_Report_Statistics;

DIRECTIVE STATUS CODES:
-----------------------

NONE

DESCRIPTION:
------------

This directive prints a report on all active periods which have
executed at least one period. The following is an example of the output
generated by this directive.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Barrier Manager,  Next: Barrier Manager Introduction,  Prev: Rate Monotonic Manager RATE_MONOTONIC_REPORT_STATISTICS - Print period statistics report,  Up: Top

20 Barrier Manager
******************

* Menu:

* Barrier Manager Introduction::
* Barrier Manager Background::
* Barrier Manager Operations::
* Barrier Manager Directives::


File: ada_user.info,  Node: Barrier Manager Introduction,  Next: Barrier Manager Background,  Prev: Barrier Manager,  Up: Barrier Manager

20.1 Introduction
=================

The barrier manager provides a unique synchronization capability which
can be used to have a set of tasks block and be unblocked as a set.
The directives provided by the barrier manager are:

   * `rtems.barrier_create' -  Create a barrier

   * `rtems.barrier_ident' - Get ID of a barrier

   * `rtems.barrier_delete' - Delete a barrier

   * `rtems.barrier_wait' - Wait at a barrier

   * `rtems.barrier_release' - Release a barrier


File: ada_user.info,  Node: Barrier Manager Background,  Next: Barrier Manager Automatic Versus Manual Barriers,  Prev: Barrier Manager Introduction,  Up: Barrier Manager

20.2 Background
===============

* Menu:

* Barrier Manager Automatic Versus Manual Barriers::
* Barrier Manager Building a Barrier Attribute Set::

A barrier can be viewed as a gate at which tasks wait until the gate is
opened.  This has many analogies in the real world.  Horses and other
farm animals may approach a closed gate and gather in front of it,
waiting for someone to open the gate so they may proceed.  Similarly,
cticket holders gather at the gates of arenas before concerts or
sporting events waiting for the arena personnel to open the gates so
they may enter.

Barriers are useful during application initialization.  Each
application task can perform its local initialization before waiting
for the application as a whole to be initialized.  Once all tasks have
completed their independent initializations, the "application ready"
barrier can be released.


File: ada_user.info,  Node: Barrier Manager Automatic Versus Manual Barriers,  Next: Barrier Manager Building a Barrier Attribute Set,  Prev: Barrier Manager Background,  Up: Barrier Manager Background

20.2.1 Automatic Versus Manual Barriers
---------------------------------------

Just as with a real-world gate, barriers may be configured to be
manually opened or automatically opened.  All tasks calling the
`rtems.barrier_wait' directive will block until a controlling task
invokes the `rtems.barrier_release' directive.

Automatic barriers are created with a limit to the number of tasks
which may simultaneously block at the barrier.  Once this limit is
reached, all of the tasks are released.  For example, if the automatic
limit is ten tasks, then the first nine tasks calling the
`rtems.barrier_wait' directive will block.  When the tenth task calls
the `rtems.barrier_wait' directive, the nine blocked tasks will be
released and the tenth task returns to the caller without blocking.


File: ada_user.info,  Node: Barrier Manager Building a Barrier Attribute Set,  Next: Barrier Manager Operations,  Prev: Barrier Manager Automatic Versus Manual Barriers,  Up: Barrier Manager Background

20.2.2 Building a Barrier Attribute Set
---------------------------------------

In general, an attribute set is built by a bitwise OR of the desired
attribute components.  The following table lists the set of valid
barrier attributes:

   * `RTEMS.BARRIER_AUTOMATIC_RELEASE' - automatically release the
     barrier when the configured number of tasks are blocked

   * `RTEMS.BARRIER_MANUAL_RELEASE' - only release the barrier when the
     application invokes the `rtems.barrier_release' directive.
     (default)


NOTE: Barriers only support FIFO blocking order because all waiting
tasks are released as a set.  Thus the released tasks will all become
ready to execute at the same time and compete for the processor based
upon their priority.

Attribute values are specifically designed to be mutually exclusive,
therefore bitwise OR and addition operations are equivalent as long as
each attribute appears exactly once in the component list.  An
attribute listed as a default is not required to appear in the
attribute list, although it is a good programming practice to specify
default attributes.  If all defaults are desired, the attribute
`RTEMS.DEFAULT_ATTRIBUTES' should be specified on this call.

This example demonstrates the attribute_set parameter needed to create a
barrier with the automatic release policy.  The `attribute_set'
parameter passed to the `rtems.barrier_create' directive will be
`RTEMS.BARRIER_AUTOMATIC_RELEASE'.  In this case, the user must also
specify the maximum_waiters parameter.


File: ada_user.info,  Node: Barrier Manager Operations,  Next: Barrier Manager Creating a Barrier,  Prev: Barrier Manager Building a Barrier Attribute Set,  Up: Barrier Manager

20.3 Operations
===============

* Menu:

* Barrier Manager Creating a Barrier::
* Barrier Manager Obtaining Barrier IDs::
* Barrier Manager Waiting at a Barrier::
* Barrier Manager Releasing a Barrier::
* Barrier Manager Deleting a Barrier::


File: ada_user.info,  Node: Barrier Manager Creating a Barrier,  Next: Barrier Manager Obtaining Barrier IDs,  Prev: Barrier Manager Operations,  Up: Barrier Manager Operations

20.3.1 Creating a Barrier
-------------------------

The `rtems.barrier_create' directive creates a barrier with a
user-specified name and the desired attributes.  RTEMS allocates a
Barrier Control Block (BCB) from the BCB free list.  This data
structure is used by RTEMS to manage the newly created barrier.  Also,
a unique barrier ID is generated and returned to the calling task.


File: ada_user.info,  Node: Barrier Manager Obtaining Barrier IDs,  Next: Barrier Manager Waiting at a Barrier,  Prev: Barrier Manager Creating a Barrier,  Up: Barrier Manager Operations

20.3.2 Obtaining Barrier IDs
----------------------------

When a barrier is created, RTEMS generates a unique barrier ID and
assigns it to the created barrier until it is deleted.  The barrier ID
may be obtained by either of two methods.  First, as the result of an
invocation of the `rtems.barrier_create' directive, the barrier ID is
stored in a user provided location.  Second, the barrier ID may be
obtained later using the `rtems.barrier_ident' directive.  The barrier
ID is used by other barrier manager directives to access this barrier.


File: ada_user.info,  Node: Barrier Manager Waiting at a Barrier,  Next: Barrier Manager Releasing a Barrier,  Prev: Barrier Manager Obtaining Barrier IDs,  Up: Barrier Manager Operations

20.3.3 Waiting at a Barrier
---------------------------

The `rtems.barrier_wait' directive is used to wait at the specified
barrier.  Since a barrier is, by definition, never immediately, the
task may wait forever for the barrier to be released or it may specify
a timeout.  Specifying a timeout limits the interval the task will wait
before returning with an error status code.

If the barrier is configured as automatic and there are already one
less then the maximum number of waiters, then the call will unblock all
tasks waiting at the barrier and the caller will return immediately.

When the task does wait to acquire the barrier, then it is placed in
the barrier's task wait queue in FIFO order.  All tasks waiting on a
barrier are returned an error code when the barrier is deleted.


File: ada_user.info,  Node: Barrier Manager Releasing a Barrier,  Next: Barrier Manager Deleting a Barrier,  Prev: Barrier Manager Waiting at a Barrier,  Up: Barrier Manager Operations

20.3.4 Releasing a Barrier
--------------------------

The `rtems.barrier_release' directive is used to release the specified
barrier.  When the `rtems.barrier_release' is invoked, all tasks
waiting at the barrier are immediately made ready to execute and begin
to compete for the processor to execute.


File: ada_user.info,  Node: Barrier Manager Deleting a Barrier,  Next: Barrier Manager Directives,  Prev: Barrier Manager Releasing a Barrier,  Up: Barrier Manager Operations

20.3.5 Deleting a Barrier
-------------------------

The `rtems.barrier_delete' directive removes a barrier from the system
and frees its control block.  A barrier can be deleted by any local
task that knows the barrier's ID.  As a result of this directive, all
tasks blocked waiting for the barrier to be released, will be readied
and returned a status code which indicates that the barrier was
deleted.  Any subsequent references to the barrier's name and ID are
invalid.


File: ada_user.info,  Node: Barrier Manager Directives,  Next: Barrier Manager BARRIER_CREATE - Create a barrier,  Prev: Barrier Manager Deleting a Barrier,  Up: Barrier Manager

20.4 Directives
===============

* Menu:

* Barrier Manager BARRIER_CREATE - Create a barrier::
* Barrier Manager BARRIER_IDENT - Get ID of a barrier::
* Barrier Manager BARRIER_DELETE - Delete a barrier::
* Barrier Manager BARRIER_OBTAIN - Acquire a barrier::
* Barrier Manager BARRIER_RELEASE - Release a barrier::

This section details the barrier manager's directives.  A subsection is
dedicated to each of this manager's directives and describes the
calling sequence, related constants, usage, and status codes.


File: ada_user.info,  Node: Barrier Manager BARRIER_CREATE - Create a barrier,  Next: Barrier Manager BARRIER_IDENT - Get ID of a barrier,  Prev: Barrier Manager Directives,  Up: Barrier Manager Directives

20.4.1 BARRIER_CREATE - Create a barrier
----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Barrier_Create (
        Name            : in     RTEMS.Name;
        Attribute_Set   : in     RTEMS.Attribute;
        Maximum_Waiters : in     RTEMS.Unsigned32;
        ID              :    out RTEMS.ID;
        Result          :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - barrier created successfully
`RTEMS.INVALID_NAME' - invalid barrier name
`RTEMS.INVALID_ADDRESS' - `id' is NULL
`RTEMS.TOO_MANY' - too many barriers created

DESCRIPTION:
------------

This directive creates a barrier which resides on the local node. The
created barrier has the user-defined name specified in `name' and the
initial count specified in `count'.  For control and maintenance of the
barrier, RTEMS allocates and initializes a BCB.  The RTEMS-assigned
barrier id is returned in `id'.  This barrier id is used with other
barrier related directives to access the barrier.

`RTEMS.BARRIER_MANUAL_RELEASE' - only release

Specifying `RTEMS.BARRIER_AUTOMATIC_RELEASE' in `attribute_set' causes
tasks calling the `rtems.barrier_wait' directive to block until there
are `maximum_waiters - 1' tasks waiting at the barrier.  When the
`maximum_waiters' task invokes the `rtems.barrier_wait' directive, the
previous `maximum_waiters - 1' tasks are automatically released and the
caller returns.

In contrast, when the `RTEMS.BARRIER_MANUAL_RELEASE' attribute is
specified, there is no limit on the number of tasks that will block at
the barrier. Only when the `rtems.barrier_release' directive is invoked,
are the tasks waiting at the barrier unblocked.

NOTES:
------

This directive will not cause the calling task to be preempted.

The following barrier attribute constants are defined by RTEMS:

   * `RTEMS.BARRIER_AUTOMATIC_RELEASE' - automatically release the
     barrier when the configured number of tasks are blocked

   * `RTEMS.BARRIER_MANUAL_RELEASE' - only release the barrier when the
     application invokes the `rtems.barrier_release' directive.
     (default)



File: ada_user.info,  Node: Barrier Manager BARRIER_IDENT - Get ID of a barrier,  Next: Barrier Manager BARRIER_DELETE - Delete a barrier,  Prev: Barrier Manager BARRIER_CREATE - Create a barrier,  Up: Barrier Manager Directives

20.4.2 BARRIER_IDENT - Get ID of a barrier
------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Barrier_Ident (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - barrier identified successfully
`RTEMS.INVALID_NAME' - barrier name not found
`RTEMS.INVALID_NODE' - invalid node id

DESCRIPTION:
------------

This directive obtains the barrier id associated with the barrier name.
If the barrier name is not unique, then the barrier id will match one
of the barriers with that name.  However, this barrier id is not
guaranteed to correspond to the desired barrier.  The barrier id is used
by other barrier related directives to access the barrier.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Barrier Manager BARRIER_DELETE - Delete a barrier,  Next: Barrier Manager BARRIER_OBTAIN - Acquire a barrier,  Prev: Barrier Manager BARRIER_IDENT - Get ID of a barrier,  Up: Barrier Manager Directives

20.4.3 BARRIER_DELETE - Delete a barrier
----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Barrier_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' -  barrier deleted successfully
`RTEMS.INVALID_ID' - invalid barrier id

DESCRIPTION:
------------

This directive deletes the barrier specified by `id'.  All tasks
blocked waiting for the barrier to be released will be readied and
returned a status code which indicates that the barrier was deleted.
The BCB for this barrier is reclaimed by RTEMS.

NOTES:
------

The calling task will be preempted if it is enabled by the task's
execution mode and a higher priority local task is waiting on the
deleted barrier.  The calling task will NOT be preempted if all of the
tasks that are waiting on the barrier are remote tasks.

The calling task does not have to be the task that created the barrier.
Any local task that knows the barrier id can delete the barrier.


File: ada_user.info,  Node: Barrier Manager BARRIER_OBTAIN - Acquire a barrier,  Next: Barrier Manager BARRIER_RELEASE - Release a barrier,  Prev: Barrier Manager BARRIER_DELETE - Delete a barrier,  Up: Barrier Manager Directives

20.4.4 BARRIER_OBTAIN - Acquire a barrier
-----------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Barrier_Wait (
        ID         : in     RTEMS.ID;
        Timeout    : in     RTEMS.Interval;
        Result     :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - barrier obtained successfully
`RTEMS.UNSATISFIED' - barrier not available
`RTEMS.TIMEOUT' - timed out waiting for barrier
`RTEMS.OBJECT_WAS_DELETED' - barrier deleted while waiting
`RTEMS.INVALID_ID' - invalid barrier id

DESCRIPTION:
------------

This directive acquires the barrier specified by id.  The `RTEMS.WAIT'
and `RTEMS.NO_WAIT' components of the options parameter indicate
whether the calling task wants to wait for the barrier to become
available or return immediately if the barrier is not currently
available.  With either `RTEMS.WAIT' or `RTEMS.NO_WAIT', if the current
barrier count is positive, then it is decremented by one and the
barrier is successfully acquired by returning immediately with a
successful return code.

Conceptually, the calling task should always be thought of as blocking
when it makes this call and being unblocked when the barrier is
released.  If the barrier is configured for manual release, this rule
of thumb will always be valid.  If the barrier is configured for
automatic release, all callers will block except for the one which is
the Nth task which trips the automatic release condition.

The timeout parameter specifies the maximum interval the calling task is
willing to be blocked waiting for the barrier.  If it is set to
`RTEMS.NO_TIMEOUT', then the calling task will wait forever.  If the
barrier is available or the `RTEMS.NO_WAIT' option component is set,
then timeout is ignored.

NOTES:
------

The following barrier acquisition option constants are defined by RTEMS:

   * `RTEMS.WAIT' - task will wait for barrier (default)

   * `RTEMS.NO_WAIT' - task should not wait

A clock tick is required to support the timeout functionality of this
directive.


File: ada_user.info,  Node: Barrier Manager BARRIER_RELEASE - Release a barrier,  Next: Board Support Packages,  Prev: Barrier Manager BARRIER_OBTAIN - Acquire a barrier,  Up: Barrier Manager Directives

20.4.5 BARRIER_RELEASE - Release a barrier
------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Barrier_Release (
        ID       : in     RTEMS.ID;
        Released :    out RTEMS.Unsigned32;
        Result   :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' - barrier released successfully
`RTEMS.INVALID_ID' - invalid barrier id
DESCRIPTION:
------------

This directive releases the barrier specified by id.  All tasks waiting
at the barrier will be unblocked.  If the running task's preemption
mode is enabled and one of the unblocked tasks has a higher priority
than the running task.

NOTES:
------

The calling task may be preempted if it causes a higher priority task
to be made ready for execution.


File: ada_user.info,  Node: Board Support Packages,  Next: Board Support Packages Introduction,  Prev: Barrier Manager BARRIER_RELEASE - Release a barrier,  Up: Top

21 Board Support Packages
*************************

* Menu:

* Board Support Packages Introduction::
* Board Support Packages Reset and Initialization::
* Board Support Packages Device Drivers::
* Board Support Packages User Extensions::
* Board Support Packages Multiprocessor Communications Interface (MPCI)::


File: ada_user.info,  Node: Board Support Packages Introduction,  Next: Board Support Packages Reset and Initialization,  Prev: Board Support Packages,  Up: Board Support Packages

21.1 Introduction
=================

A board support package (BSP) is a collection of user-provided
facilities which interface RTEMS and an application with a specific
hardware platform.  These facilities may  include hardware
initialization, device drivers, user extensions, and a Multiprocessor
Communications Interface (MPCI).  However, a minimal BSP need only
support processor reset and initialization and, if needed, a clock tick.


File: ada_user.info,  Node: Board Support Packages Reset and Initialization,  Next: Board Support Packages Interrupt Stack Requirements,  Prev: Board Support Packages Introduction,  Up: Board Support Packages

21.2 Reset and Initialization
=============================

* Menu:

* Board Support Packages Interrupt Stack Requirements::
* Board Support Packages Processors with a Separate Interrupt Stack::
* Board Support Packages Processors Without a Separate Interrupt Stack::

An RTEMS based application is initiated or re-initiated when the
processor is reset.  This initialization code is responsible for
preparing the target platform for the RTEMS application.  Although the
exact actions performed by the initialization code are highly processor
and target dependent, the logical functionality of these actions are
similar across a variety of processors and target platforms.

Normally, the BSP and some of the application initialization is
intertwined in the RTEMS initialization sequence controlled by the
shared function `boot_card()'.

The reset application initialization code is executed first when the
processor is reset.  All of the hardware must be initialized to a
quiescent state by this software before initializing RTEMS.  When in
quiescent state, devices do not generate any interrupts or require any
servicing by the application.  Some of the hardware components may be
initialized in this code as well as any application initialization that
does not involve calls to RTEMS directives.

The processor's Interrupt Vector Table which will be used by the
application may need to be set to the required value by the reset
application initialization code.  Because interrupts are enabled
automatically by RTEMS as part of the context switch to the first task,
the Interrupt Vector Table MUST be set before this directive is invoked
to ensure correct interrupt vectoring.  The processor's Interrupt Vector
Table must be accessible by RTEMS as it will be modified by the when
installing user Interrupt Service Routines (ISRs) On some CPUs, RTEMS
installs it's own Interrupt Vector Table as part of initialization and
thus these requirements are met automatically.  The reset code which is
executed before the call to any RTEMS initialization routines has the
following requirements:

   * Must not make any blocking RTEMS directive calls.

   * If the processor supports multiple privilege levels, must leave
     the processor in the most privileged, or supervisory, state.

   * Must allocate a stack of sufficient size to execute the
     initialization and shutdown of the system.  This stack area will
     NOT be used by any task once the system is initialized.  This
     stack is often reserved via the linker script or in the assembly
     language start up file.

   * Must initialize the stack pointer for the initialization process to
     that allocated.

   * Must initialize the processor's Interrupt Vector Table.

   * Must disable all maskable interrupts.

   * If the processor supports a separate interrupt stack, must allocate
     the interrupt stack and initialize the interrupt stack pointer.


At the end of the initialization sequence, RTEMS does not return to the
BSP initialization code, but instead context switches to the highest
priority task to begin application execution.  This task is typically a
User Initialization Task which is responsible for performing both local
and global application initialization which is dependent on RTEMS
facilities.  It is also responsible for initializing any higher level
RTEMS services the application uses such as networking and blocking
device drivers.


File: ada_user.info,  Node: Board Support Packages Interrupt Stack Requirements,  Next: Board Support Packages Processors with a Separate Interrupt Stack,  Prev: Board Support Packages Reset and Initialization,  Up: Board Support Packages Reset and Initialization

21.2.1 Interrupt Stack Requirements
-----------------------------------

The worst-case stack usage by interrupt service routines must be taken
into account when designing an application.  If the processor supports
interrupt nesting, the stack usage must include the deepest nest level.
The worst-case stack usage must account for the following requirements:

   * Processor's interrupt stack frame

   * Processor's subroutine call stack frame

   * RTEMS system calls

   * Registers saved on stack

   * Application subroutine calls

The size of the interrupt stack must be greater than or equal to the
confugured minimum stack size.


File: ada_user.info,  Node: Board Support Packages Processors with a Separate Interrupt Stack,  Next: Board Support Packages Processors Without a Separate Interrupt Stack,  Prev: Board Support Packages Interrupt Stack Requirements,  Up: Board Support Packages Reset and Initialization

21.2.2 Processors with a Separate Interrupt Stack
-------------------------------------------------

Some processors support a separate stack for interrupts.  When an
interrupt is vectored and the interrupt is not nested, the processor
will automatically switch from the current stack to the interrupt stack.
The size of this stack is based solely on the worst-case stack usage by
interrupt service routines.

The dedicated interrupt stack for the entire application on some
architectures is supplied and initialized by the reset and
initialization code of the user's Board Support Package.  Whether
allocated and initialized by the BSP or RTEMS, since all ISRs use this
stack, the stack size must take into account the worst case stack usage
by any combination of nested ISRs.


File: ada_user.info,  Node: Board Support Packages Processors Without a Separate Interrupt Stack,  Next: Board Support Packages Device Drivers,  Prev: Board Support Packages Processors with a Separate Interrupt Stack,  Up: Board Support Packages Reset and Initialization

21.2.3 Processors Without a Separate Interrupt Stack
----------------------------------------------------

Some processors do not support a separate stack for interrupts.  In this
case, without special assistance every task's stack must include enough
space to handle the task's worst-case stack usage as well as the
worst-case interrupt stack usage.  This is necessary because the
worst-case interrupt nesting could occur while any task is executing.

On many processors without dedicated hardware managed interrupt stacks,
RTEMS manages a dedicated interrupt stack in software.  If this
capability is supported on a CPU, then it is logically equivalent to
the processor supporting a separate interrupt stack in hardware.


File: ada_user.info,  Node: Board Support Packages Device Drivers,  Next: Board Support Packages Clock Tick Device Driver,  Prev: Board Support Packages Processors Without a Separate Interrupt Stack,  Up: Board Support Packages

21.3 Device Drivers
===================

* Menu:

* Board Support Packages Clock Tick Device Driver::

Device drivers consist of control software for special peripheral
devices and provide a logical interface for the application developer.
The RTEMS I/O manager provides directives which allow applications to
access these device drivers in a consistent fashion.  A Board Support
Package may include device drivers to access the hardware on the target
platform.  These devices typically include serial and parallel ports,
counter/timer peripherals, real-time clocks, disk interfaces, and
network controllers.

For more information on device drivers, refer to the I/O Manager
chapter.


File: ada_user.info,  Node: Board Support Packages Clock Tick Device Driver,  Next: Board Support Packages User Extensions,  Prev: Board Support Packages Device Drivers,  Up: Board Support Packages Device Drivers

21.3.1 Clock Tick Device Driver
-------------------------------

Most RTEMS applications will include a clock tick device driver which
invokes the `rtems.clock_tick' directive at regular intervals.  The
clock tick is necessary if the application is to utilize timeslicing,
the clock manager, the timer manager, the rate monotonic manager, or
the timeout option on blocking directives.

The clock tick is usually provided as an interrupt from a counter/timer
or a real-time clock device.  When a counter/timer is used to provide
the clock tick, the device is typically programmed to operate in
continuous mode.  This mode selection causes the device to
automatically reload the initial count and continue the countdown
without programmer intervention.  This reduces the overhead required to
manipulate the counter/timer in the clock tick ISR and increases the
accuracy of tick occurrences.  The initial count can be based on the
microseconds_per_tick field in the RTEMS Configuration Table.  An
alternate approach is to set the initial count for a fixed time period
(such as one millisecond) and have the ISR invoke `rtems.clock_tick' on
the configured `microseconds_per_tick' boundaries.  Obviously, this can
induce some error if the configured `microseconds_per_tick' is not
evenly divisible by the chosen clock interrupt quantum.

It is important to note that the interval between clock ticks directly
impacts the granularity of RTEMS timing operations.  In addition, the
frequency of clock ticks is an important factor in the overall level of
system overhead.  A high clock tick frequency results in less processor
time being available for task execution due to the increased number of
clock tick ISRs.


File: ada_user.info,  Node: Board Support Packages User Extensions,  Next: Board Support Packages Multiprocessor Communications Interface (MPCI),  Prev: Board Support Packages Clock Tick Device Driver,  Up: Board Support Packages

21.4 User Extensions
====================

RTEMS allows the application developer to augment selected features by
invoking user-supplied extension routines when the following system
events occur:

   * Task creation

   * Task initiation

   * Task reinitiation

   * Task deletion

   * Task context switch

   * Post task context switch

   * Task begin

   * Task exits

   * Fatal error detection

User extensions can be used to implement a wide variety of functions
including execution profiling, non-standard coprocessor support, debug
support, and error detection and recovery.  For example, the context of
a non-standard numeric coprocessor may be maintained via the user
extensions.  In this example, the task creation and deletion extensions
are responsible for allocating and deallocating the context area, the
task initiation and reinitiation extensions would be responsible for
priming the context area, and the task context switch extension would
save and restore the context of the device.

For more information on user extensions, refer to the *note User
Extensions Manager:: chapter.


File: ada_user.info,  Node: Board Support Packages Multiprocessor Communications Interface (MPCI),  Next: Board Support Packages Tightly-Coupled Systems,  Prev: Board Support Packages User Extensions,  Up: Board Support Packages

21.5 Multiprocessor Communications Interface (MPCI)
===================================================

* Menu:

* Board Support Packages Tightly-Coupled Systems::
* Board Support Packages Loosely-Coupled Systems::
* Board Support Packages Systems with Mixed Coupling::
* Board Support Packages Heterogeneous Systems::

RTEMS requires that an MPCI layer be provided when a multiple node
application is developed.  This MPCI layer must provide an efficient
and reliable communications mechanism between the multiple nodes.
Tasks on different nodes communicate and synchronize with one another
via the MPCI.  Each MPCI layer must be tailored to support the
architecture of the target platform.

For more information on the MPCI, refer to the Multiprocessing Manager
chapter.


File: ada_user.info,  Node: Board Support Packages Tightly-Coupled Systems,  Next: Board Support Packages Loosely-Coupled Systems,  Prev: Board Support Packages Multiprocessor Communications Interface (MPCI),  Up: Board Support Packages Multiprocessor Communications Interface (MPCI)

21.5.1 Tightly-Coupled Systems
------------------------------

A tightly-coupled system is a multiprocessor configuration in which the
processors communicate solely via shared global memory.  The MPCI can
simply place the RTEMS packets in the shared memory space.  The two
primary considerations when designing an MPCI for a tightly-coupled
system are data consistency and informing another node of a packet.

The data consistency problem may be solved using atomic "test and set"
operations to provide a "lock" in the shared memory.  It is important
to minimize the length of time any particular processor locks a shared
data structure.

The problem of informing another node of a packet can be addressed
using one of two techniques.  The first technique is to use an
interprocessor interrupt capability to cause an interrupt on the
receiving node.  This technique requires that special support hardware
be provided by either the processor itself or the target platform.  The
second technique is to have a node poll for arrival of packets.  The
drawback to this technique is the overhead associated with polling.


File: ada_user.info,  Node: Board Support Packages Loosely-Coupled Systems,  Next: Board Support Packages Systems with Mixed Coupling,  Prev: Board Support Packages Tightly-Coupled Systems,  Up: Board Support Packages Multiprocessor Communications Interface (MPCI)

21.5.2 Loosely-Coupled Systems
------------------------------

A loosely-coupled system is a multiprocessor configuration in which the
processors communicate via some type of communications link which is
not shared global memory.  The MPCI sends the RTEMS packets across the
communications link to the destination node.  The characteristics of
the communications link vary widely and have a significant impact on
the MPCI layer.  For example, the bandwidth of the communications link
has an obvious impact on the maximum MPCI throughput.

The characteristics of a shared network, such as Ethernet, lend
themselves to supporting an MPCI layer.  These networks provide both
the point-to-point and broadcast capabilities which are expected by
RTEMS.


File: ada_user.info,  Node: Board Support Packages Systems with Mixed Coupling,  Next: Board Support Packages Heterogeneous Systems,  Prev: Board Support Packages Loosely-Coupled Systems,  Up: Board Support Packages Multiprocessor Communications Interface (MPCI)

21.5.3 Systems with Mixed Coupling
----------------------------------

A mixed-coupling system is a multiprocessor configuration in which the
processors communicate via both shared memory and communications links.
A unique characteristic of mixed-coupling systems is that a node may
not have access to all communication methods.  There may be multiple
shared memory areas and communication links.  Therefore, one of the
primary functions of the MPCI layer is to efficiently route RTEMS
packets between nodes.  This routing may be based on numerous
algorithms. In addition, the router may provide alternate
communications paths in the event of an overload or a partial failure.


File: ada_user.info,  Node: Board Support Packages Heterogeneous Systems,  Next: User Extensions Manager,  Prev: Board Support Packages Systems with Mixed Coupling,  Up: Board Support Packages Multiprocessor Communications Interface (MPCI)

21.5.4 Heterogeneous Systems
----------------------------

Designing an MPCI layer for a heterogeneous system requires special
considerations by the developer.  RTEMS is designed to eliminate many
of the problems associated with sharing data in a heterogeneous
environment.  The MPCI layer need only address the representation of
thirty-two (32) bit unsigned quantities.

For more information on supporting a heterogeneous system, refer the
Supporting Heterogeneous Environments in the Multiprocessing Manager
chapter.


File: ada_user.info,  Node: User Extensions Manager,  Next: User Extensions Manager Introduction,  Prev: Board Support Packages Heterogeneous Systems,  Up: Top

22 User Extensions Manager
**************************

* Menu:

* User Extensions Manager Introduction::
* User Extensions Manager Background::
* User Extensions Manager Operations::
* User Extensions Manager Directives::


File: ada_user.info,  Node: User Extensions Manager Introduction,  Next: User Extensions Manager Background,  Prev: User Extensions Manager,  Up: User Extensions Manager

22.1 Introduction
=================

The RTEMS User Extensions Manager allows the application developer to
augment the executive by allowing them to supply extension routines
which are invoked at critical system events.  The directives provided
by the user extensions manager are:

   * `rtems.extension_create' - Create an extension set

   * `rtems.extension_ident' - Get ID of an extension set

   * `rtems.extension_delete' - Delete an extension set


File: ada_user.info,  Node: User Extensions Manager Background,  Next: User Extensions Manager Extension Sets,  Prev: User Extensions Manager Introduction,  Up: User Extensions Manager

22.2 Background
===============

* Menu:

* User Extensions Manager Extension Sets::
* User Extensions Manager TCB Extension Area::
* User Extensions Manager Extensions::
* User Extensions Manager Order of Invocation::

User extension routines are invoked when the following system events
occur:

   * Task creation

   * Task initiation

   * Task reinitiation

   * Task deletion

   * Task context switch

   * Post task context switch

   * Task begin

   * Task exits

   * Fatal error detection

These extensions are invoked as a function with arguments that are
appropriate to the system event.


File: ada_user.info,  Node: User Extensions Manager Extension Sets,  Next: User Extensions Manager TCB Extension Area,  Prev: User Extensions Manager Background,  Up: User Extensions Manager Background

22.2.1 Extension Sets
---------------------

An extension set is defined as a set of routines which are invoked at
each of the critical system events at which user extension routines are
invoked.  Together a set of these routines typically perform a specific
functionality such as performance monitoring or debugger support.
RTEMS is informed of the entry points which constitute an extension set
via the following record:

     type Extensions_Table is
        record
           Task_Create      : RTEMS.Task_Create_Extension;
           Task_Start       : RTEMS.Task_Start_Extension;
           Task_Restart     : RTEMS.Task_Restart_Extension;
           Task_Delete      : RTEMS.Task_Delete_Extension;
           Task_Switch      : RTEMS.Task_Switch_Extension;
           Task_Post_Switch : RTEMS.Task_Post_Switch_Extension;
           Task_Begin       : RTEMS.Task_Begin_Extension;
           Task_Exitted     : RTEMS.Task_Exitted_Extension;
           Fatal            : RTEMS.Fatal_Error_Extension;
        end record;

RTEMS allows the user to have multiple extension sets active at the
same time.  First, a single static extension set may be defined as the
application's User Extension Table which is included as part of the
Configuration Table.  This extension set is active for the entire life
of the system and may not be deleted.  This extension set is especially
important because it is the only way the application can provided a
FATAL error extension which is invoked if RTEMS fails during the
initialize_executive directive.  The static extension set is optional
and may be configured as NULL if no static extension set is required.

Second, the user can install dynamic extensions using the
`rtems.extension_create' directive.  These extensions are RTEMS objects
in that they have a name, an ID, and can be dynamically created and
deleted.  In contrast to the static extension set, these extensions can
only be created and installed after the initialize_executive directive
successfully completes execution.  Dynamic extensions are useful for
encapsulating the functionality of an extension set.  For example, the
application could use extensions to manage a special coprocessor, do
performance monitoring, and to do stack bounds checking.  Each of these
extension sets could be written and installed independently of the
others.

All user extensions are optional and RTEMS places no naming
restrictions on the user. The user extension entry points are copied
into an internal RTEMS structure. This means the user does not need to
keep the table after creating it, and changing the handler entry points
dynamically in a table once created has no effect. Creating a table
local to a function can save space in space limited applications.

Extension switches do not effect the context switch overhead if no
switch handler is installed.


File: ada_user.info,  Node: User Extensions Manager TCB Extension Area,  Next: User Extensions Manager Extensions,  Prev: User Extensions Manager Extension Sets,  Up: User Extensions Manager Background

22.2.2 TCB Extension Area
-------------------------

RTEMS provides for a pointer to a user-defined data area for each
extension set to be linked to each task's control block.  This set of
pointers is an extension of the TCB and can be used to store additional
data required by the user's extension functions.  It is also possible
for a user extension to utilize the notepad locations associated with
each task although this may conflict with application usage of those
particular notepads.

The TCB extension is an array of pointers in the TCB. The index into
the table can be obtained from the extension id returned when the
extension is created:

     There is currently no example for Ada.

The number of pointers in the area is the same as the number of user
extension sets configured.  This allows an application to augment the
TCB with user-defined information.  For example, an application could
implement task profiling by storing timing statistics in the TCB's
extended memory area.  When a task context switch is being executed,
the TASK_SWITCH extension could read a real-time clock to calculate how
long the task being swapped out has run as well as timestamp the
starting time for the task being swapped in.

If used, the extended memory area for the TCB should be allocated and
the TCB extension pointer should be set at the time the task is created
or started by either the TASK_CREATE or TASK_START extension.  The
application is responsible for managing this extended memory area for
the TCBs.  The memory may be reinitialized by the TASK_RESTART
extension and should be deallocated by the TASK_DELETE extension when
the task is deleted.  Since the TCB extension buffers would most likely
be of a fixed size, the RTEMS partition manager could be used to manage
the application's extended memory area.  The application could create a
partition of fixed size TCB extension buffers and use the partition
manager's allocation and deallocation directives to obtain and release
the extension buffers.


File: ada_user.info,  Node: User Extensions Manager Extensions,  Next: User Extensions Manager TASK_CREATE Extension,  Prev: User Extensions Manager TCB Extension Area,  Up: User Extensions Manager Background

22.2.3 Extensions
-----------------

* Menu:

* User Extensions Manager TASK_CREATE Extension::
* User Extensions Manager TASK_START Extension::
* User Extensions Manager TASK_RESTART Extension::
* User Extensions Manager TASK_DELETE Extension::
* User Extensions Manager TASK_SWITCH Extension::
* User Extensions Manager TASK_BEGIN Extension::
* User Extensions Manager TASK_EXITTED Extension::
* User Extensions Manager FATAL Error Extension::

The sections that follow will contain a description of each extension.
Each section will contain a prototype of a function with the
appropriate calling sequence for the corresponding extension.  The
names given for the Ada subprogram and its arguments are all defined by
the user.  The names used in the examples were arbitrarily chosen and
impose no naming conventions on the user.


File: ada_user.info,  Node: User Extensions Manager TASK_CREATE Extension,  Next: User Extensions Manager TASK_START Extension,  Prev: User Extensions Manager Extensions,  Up: User Extensions Manager Extensions

22.2.3.1 TASK_CREATE Extension
..............................

The TASK_CREATE extension directly corresponds to the
`rtems.task_create' directive.  If this extension is defined in any
static or dynamic extension set and a task is being created, then the
extension routine will automatically be invoked by RTEMS.  The
extension should have a prototype similar to the following:

     function User_Task_Create (
        Current_Task : in     RTEMS.TCB_Pointer;
        New_Task     : in     RTEMS.TCB_Pointer
     ) returns Boolean;

where `current_task' can be used to access the TCB for the currently
executing task, and new_task can be used to access the TCB for the new
task being created.  This extension is invoked from the
`rtems.task_create' directive after `new_task' has been completely
initialized, but before it is placed on a ready TCB chain.

The user extension is expected to return the boolean value `true' if it
successfully executed and `false' otherwise.  A task create user
extension will frequently attempt to allocate resources.  If this
allocation fails, then the extension should return `false' and the
entire task create operation will fail.


File: ada_user.info,  Node: User Extensions Manager TASK_START Extension,  Next: User Extensions Manager TASK_RESTART Extension,  Prev: User Extensions Manager TASK_CREATE Extension,  Up: User Extensions Manager Extensions

22.2.3.2 TASK_START Extension
.............................

The TASK_START extension directly corresponds to the task_start
directive.  If this extension is defined in any static or dynamic
extension set and a task is being started, then the extension routine
will automatically be invoked by RTEMS.  The extension should have a
prototype similar to the following:

     procedure User_Task_Start (
        Current_Task : in     RTEMS.TCB_Pointer;
        Started_Task : in     RTEMS.TCB_Pointer
     );

where current_task can be used to access the TCB for the currently
executing task, and started_task can be used to access the TCB for the
dormant task being started. This extension is invoked from the
task_start directive after started_task has been made ready to start
execution, but before it is placed on a ready TCB chain.


File: ada_user.info,  Node: User Extensions Manager TASK_RESTART Extension,  Next: User Extensions Manager TASK_DELETE Extension,  Prev: User Extensions Manager TASK_START Extension,  Up: User Extensions Manager Extensions

22.2.3.3 TASK_RESTART Extension
...............................

The TASK_RESTART extension directly corresponds to the task_restart
directive.  If this extension is defined in any static or dynamic
extension set and a task is being restarted, then the extension should
have a prototype similar to the following:

     procedure User_Task_Restart (
        Current_Task   : in     RTEMS.TCB_Pointer;
        Restarted_Task : in     RTEMS.TCB_Pointer
     );

where current_task can be used to access the TCB for the currently
executing task, and restarted_task can be used to access the TCB for
the task being restarted. This extension is invoked from the
task_restart directive after restarted_task has been made ready to
start execution, but before it is placed on a ready TCB chain.


File: ada_user.info,  Node: User Extensions Manager TASK_DELETE Extension,  Next: User Extensions Manager TASK_SWITCH Extension,  Prev: User Extensions Manager TASK_RESTART Extension,  Up: User Extensions Manager Extensions

22.2.3.4 TASK_DELETE Extension
..............................

The TASK_DELETE extension is associated with the task_delete directive.
If this extension is defined in any static or dynamic extension set and
a task is being deleted, then the extension routine will automatically
be invoked by RTEMS.  The extension should have a prototype similar to
the following:

     procedure User_Task_Delete (
        Current_Task : in     RTEMS.TCB_Pointer;
        Deleted_Task : in     RTEMS.TCB_Pointer
     );

where current_task can be used to access the TCB for the currently
executing task, and deleted_task can be used to access the TCB for the
task being deleted. This extension is invoked from the task_delete
directive after the TCB has been removed from a ready TCB chain, but
before all its resources including the TCB have been returned to their
respective free pools.  This extension should not call any RTEMS
directives if a task is deleting itself (current_task is equal to
deleted_task).


File: ada_user.info,  Node: User Extensions Manager TASK_SWITCH Extension,  Next: User Extensions Manager TASK_BEGIN Extension,  Prev: User Extensions Manager TASK_DELETE Extension,  Up: User Extensions Manager Extensions

22.2.3.5 TASK_SWITCH Extension
..............................

The TASK_SWITCH extension corresponds to a task context switch.  If
this extension is defined in any static or dynamic extension set and a
task context switch is in progress, then the extension routine will
automatically be invoked by RTEMS.  The extension should have a
prototype similar to the following:

     procedure User_Task_Switch (
        Current_Task : in     RTEMS.TCB_Pointer;
        Heir_Task    : in     RTEMS.TCB_Pointer
     );

where current_task can be used to access the TCB for the task that is
being swapped out, and heir_task can be used to access the TCB for the
task being swapped in.  This extension is invoked from RTEMS'
dispatcher routine after the current_task context has been saved, but
before the heir_task context has been restored.  This extension should
not call any RTEMS directives.


File: ada_user.info,  Node: User Extensions Manager TASK_BEGIN Extension,  Next: User Extensions Manager TASK_EXITTED Extension,  Prev: User Extensions Manager TASK_SWITCH Extension,  Up: User Extensions Manager Extensions

22.2.3.6 TASK_BEGIN Extension
.............................

The TASK_BEGIN extension is invoked when a task begins execution.  It
is invoked immediately before the body of the starting procedure and
executes in the context in the task.  This user extension have a
prototype similar to the following:

     procedure User_Task_Begin (
        Current_Task : in     RTEMS.TCB_Pointer
     );

where current_task can be used to access the TCB for the currently
executing task which has begun.  The distinction between the TASK_BEGIN
and TASK_START extension is that the TASK_BEGIN extension is executed
in the context of the actual task while the TASK_START extension is
executed in the context of the task performing the task_start
directive.  For most extensions, this is not a critical distinction.


File: ada_user.info,  Node: User Extensions Manager TASK_EXITTED Extension,  Next: User Extensions Manager FATAL Error Extension,  Prev: User Extensions Manager TASK_BEGIN Extension,  Up: User Extensions Manager Extensions

22.2.3.7 TASK_EXITTED Extension
...............................

The TASK_EXITTED extension is invoked when a task exits the body of the
starting procedure by either an implicit or explicit return statement.
This user extension have a prototype similar to the following:

     procedure User_Task_Exitted (
        Current_Task : in     RTEMS.TCB_Pointer
     );

where current_task can be used to access the TCB for the currently
executing task which has just exitted.

Although exiting of task is often considered to be a fatal error, this
extension allows recovery by either restarting or deleting the exiting
task.  If the user does not wish to recover, then a fatal error may be
reported.  If the user does not provide a TASK_EXITTED extension or the
provided handler returns control to RTEMS, then the RTEMS default
handler will be used.  This default handler invokes the directive
fatal_error_occurred with the `RTEMS.TASK_EXITTED' directive status.


File: ada_user.info,  Node: User Extensions Manager FATAL Error Extension,  Next: User Extensions Manager Order of Invocation,  Prev: User Extensions Manager TASK_EXITTED Extension,  Up: User Extensions Manager Extensions

22.2.3.8 FATAL Error Extension
..............................

The FATAL error extension is associated with the fatal_error_occurred
directive.  If this extension is defined in any static or dynamic
extension set and the fatal_error_occurred directive has been invoked,
then this extension will be called.  This extension should have a
prototype similar to the following:

     procedure User_Fatal_Error (
        Error : in     RTEMS.Unsigned32
     );

where the_error is the error code passed to the fatal_error_occurred
directive. This extension is invoked from the fatal_error_occurred
directive.

If defined, the user's FATAL error extension is invoked before RTEMS'
default fatal error routine is invoked and the processor is stopped.
For example, this extension could be used to pass control to a debugger
when a fatal error occurs.  This extension should not call any RTEMS
directives.


File: ada_user.info,  Node: User Extensions Manager Order of Invocation,  Next: User Extensions Manager Operations,  Prev: User Extensions Manager FATAL Error Extension,  Up: User Extensions Manager Background

22.2.4 Order of Invocation
--------------------------

When one of the critical system events occur, the user extensions are
invoked in either "forward" or "reverse" order.  Forward order
indicates that the static extension set is invoked followed by the
dynamic extension sets in the order in which they were created.
Reverse order means that the dynamic extension sets are invoked in the
opposite of the order in which they were created followed by the static
extension set.  By invoking the extension sets in this order,
extensions can be built upon one another.  At the following system
events, the extensions are invoked in forward order:

   * Task creation

   * Task initiation

   * Task reinitiation

   * Task deletion

   * Task context switch

   * Post task context switch

   * Task begins to execute

At the following system events, the extensions are invoked in reverse
order:

   * Task deletion

   * Fatal error detection

At these system events, the extensions are invoked in reverse order to
insure that if an extension set is built upon another, the more
complicated extension is invoked before the extension set it is built
upon.  For example, by invoking the static extension set last it is
known that the "system" fatal error extension will be the last fatal
error extension executed.  Another example is use of the task delete
extension by the Standard C Library.  Extension sets which are
installed after the Standard C Library will operate correctly even if
they utilize the C Library because the C Library's TASK_DELETE
extension is invoked after that of the other extensions.


File: ada_user.info,  Node: User Extensions Manager Operations,  Next: User Extensions Manager Creating an Extension Set,  Prev: User Extensions Manager Order of Invocation,  Up: User Extensions Manager

22.3 Operations
===============

* Menu:

* User Extensions Manager Creating an Extension Set::
* User Extensions Manager Obtaining Extension Set IDs::
* User Extensions Manager Deleting an Extension Set::


File: ada_user.info,  Node: User Extensions Manager Creating an Extension Set,  Next: User Extensions Manager Obtaining Extension Set IDs,  Prev: User Extensions Manager Operations,  Up: User Extensions Manager Operations

22.3.1 Creating an Extension Set
--------------------------------

The `rtems.extension_create' directive creates and installs an
extension set by allocating a Extension Set Control Block (ESCB),
assigning the extension set a user-specified name, and assigning it an
extension set ID.  Newly created extension sets are immediately
installed and are invoked upon the next system even supporting an
extension.


File: ada_user.info,  Node: User Extensions Manager Obtaining Extension Set IDs,  Next: User Extensions Manager Deleting an Extension Set,  Prev: User Extensions Manager Creating an Extension Set,  Up: User Extensions Manager Operations

22.3.2 Obtaining Extension Set IDs
----------------------------------

When an extension set is created, RTEMS generates a unique extension
set ID and assigns it to the created extension set until it is deleted.
The extension ID may be obtained by either of two methods.  First, as
the result of an invocation of the `rtems.extension_create' directive,
the extension set ID is stored in a user provided location.  Second,
the extension set ID may be obtained later using the
`rtems.extension_ident' directive.  The extension set ID is used by
other directives to manipulate this extension set.


File: ada_user.info,  Node: User Extensions Manager Deleting an Extension Set,  Next: User Extensions Manager Directives,  Prev: User Extensions Manager Obtaining Extension Set IDs,  Up: User Extensions Manager Operations

22.3.3 Deleting an Extension Set
--------------------------------

The `rtems.extension_delete' directive is used to delete an extension
set.  The extension set's control block is returned to the ESCB free
list when it is deleted.  An extension set can be deleted by a task
other than the task which created the extension set.  Any subsequent
references to the extension's name and ID are invalid.


File: ada_user.info,  Node: User Extensions Manager Directives,  Next: User Extensions Manager EXTENSION_CREATE - Create a extension set,  Prev: User Extensions Manager Deleting an Extension Set,  Up: User Extensions Manager

22.4 Directives
===============

* Menu:

* User Extensions Manager EXTENSION_CREATE - Create a extension set::
* User Extensions Manager EXTENSION_IDENT - Get ID of a extension set::
* User Extensions Manager EXTENSION_DELETE - Delete a extension set::

This section details the user extension manager's directives.  A
subsection is dedicated to each of this manager's directives and
describes the calling sequence, related constants, usage, and status
codes.


File: ada_user.info,  Node: User Extensions Manager EXTENSION_CREATE - Create a extension set,  Next: User Extensions Manager EXTENSION_IDENT - Get ID of a extension set,  Prev: User Extensions Manager Directives,  Up: User Extensions Manager Directives

22.4.1 EXTENSION_CREATE - Create a extension set
------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Extension_Create (
        Name   : in     RTEMS.Name;
        Table  : in     RTEMS.Extensions_Table_Pointer;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' -  extension set created successfully
`RTEMS.INVALID_NAME' - invalid extension set name
`RTEMS.TOO_MANY' - too many extension sets created

DESCRIPTION:
------------

This directive creates a extension set.  The assigned extension set id
is returned in id.  This id is used to access the extension set with
other user extension manager directives.  For control and maintenance
of the extension set, RTEMS allocates an ESCB from the local ESCB free
pool and initializes it.

NOTES:
------

This directive will not cause the calling task to be preempted.


File: ada_user.info,  Node: User Extensions Manager EXTENSION_IDENT - Get ID of a extension set,  Next: User Extensions Manager EXTENSION_DELETE - Delete a extension set,  Prev: User Extensions Manager EXTENSION_CREATE - Create a extension set,  Up: User Extensions Manager Directives

22.4.2 EXTENSION_IDENT - Get ID of a extension set
--------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Extension_Ident (
        Name   : in     RTEMS.Name;
        ID     :    out RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' -  extension set identified successfully
`RTEMS.INVALID_NAME' - extension set name not found

DESCRIPTION:
------------

This directive obtains the extension set id associated with the
extension set name to be acquired.  If the extension set name is not
unique, then the extension set id will match one of the extension sets
with that name.  However, this extension set id is not guaranteed to
correspond to the desired extension set.  The extension set id is used
to access this extension set in other extension set related directives.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: User Extensions Manager EXTENSION_DELETE - Delete a extension set,  Next: Configuring a System,  Prev: User Extensions Manager EXTENSION_IDENT - Get ID of a extension set,  Up: User Extensions Manager Directives

22.4.3 EXTENSION_DELETE - Delete a extension set
------------------------------------------------

CALLING SEQUENCE:
-----------------

     procedure Extension_Delete (
        ID     : in     RTEMS.ID;
        Result :    out RTEMS.Status_Codes
     );

DIRECTIVE STATUS CODES:
-----------------------

`RTEMS.SUCCESSFUL' -  extension set deleted successfully
`RTEMS.INVALID_ID' - invalid extension set id

DESCRIPTION:
------------

This directive deletes the extension set specified by id.  If the
extension set is running, it is automatically canceled.  The ESCB for
the deleted extension set is reclaimed by RTEMS.

NOTES:
------

This directive will not cause the running task to be preempted.

A extension set can be deleted by a task other than the task which
created the extension set.

NOTES:
------

This directive will not cause the running task to be preempted.


File: ada_user.info,  Node: Configuring a System,  Next: Configuring a System Introduction,  Prev: User Extensions Manager EXTENSION_DELETE - Delete a extension set,  Up: Top

23 Configuring a System
***********************

* Menu:

* Configuring a System Introduction::
* Configuring a System Automatic Generation of System Configuration::
* Configuring a System Configuration Table::
* Configuring a System RTEMS API Configuration Table::
* Configuring a System POSIX API Configuration Table::
* Configuring a System CPU Dependent Information Table::
* Configuring a System Initialization Task Table::
* Configuring a System Driver Address Table::
* Configuring a System User Extensions Table::
* Configuring a System Multiprocessor Configuration Table::
* Configuring a System Multiprocessor Communications Interface Table::
* Configuring a System Determining Memory Requirements::
* Configuring a System Sizing the RTEMS RAM Workspace::


File: ada_user.info,  Node: Configuring a System Introduction,  Next: Configuring a System Automatic Generation of System Configuration,  Prev: Configuring a System,  Up: Configuring a System

23.1 Introduction
=================

RTEMS must be configured for an application.  This configuration
information encompasses a variety of information including the length
of each clock tick, the maximum number of each RTEMS object that can be
created, the application initialization tasks, and the device drivers
in the application.  This information is placed in data structures that
are given to RTEMS at system initialization time.  This chapter details
the format of these data structures as well as a simpler mechanism to
automate the generation of these structures.

System configuration is ALWAYS done from C.  When developing an Ada
application, the user is responsible for creating at least one C file
which contains the Ada run-time initialization and the RTEMS System
Configuration.  There is no Ada binding for RTEMS System Configuration
information.  Thus all examples and data structures shown in this
chapter are in C.


File: ada_user.info,  Node: Configuring a System Automatic Generation of System Configuration,  Next: Configuring a System Library Support Definitions,  Prev: Configuring a System Introduction,  Up: Configuring a System

23.2 Automatic Generation of System Configuration
=================================================

* Menu:

* Configuring a System Library Support Definitions::
* Configuring a System Basic System Information::
* Configuring a System Idle Task Configuration::
* Configuring a System Device Driver Table::
* Configuring a System Multiprocessing Configuration::
* Configuring a System Classic API Configuration::
* Configuring a System Classic API Initialization Tasks Table Configuration::
* Configuring a System POSIX API Configuration::
* Configuring a System POSIX Initialization Threads Table Configuration::
* Configuring a System ITRON API Configuration::
* Configuring a System ITRON Initialization Task Table Configuration::
* Configuring a System Ada Tasks::

RTEMS provides the `rtems/confdefs.h' C language header file that based
on the setting of a variety of macros can automatically produce nearly
all of the configuration tables required by an RTEMS application.
Rather than building the individual tables by hand, the application
simply specifies the values for the configuration parameters it wishes
to set.  In the following example, the configuration information for a
simple system with a message queue and a time slice of 50 milliseconds
is configured:

     #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
     #define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER

     #define CONFIGURE_MICROSECONDS_PER_TICK   1000 /* 1 millisecond */
     #define CONFIGURE_TICKS_PER_TIMESLICE       50 /* 50 milliseconds */

     #define CONFIGURE_MAXIMUM_TASKS 4
     #define CONFIGURE_RTEMS_INIT_TASKS_TABLE

This system will begin execution with the single initialization task
named `Init'.  It will be configured to have both a console device
driver (for standard I/O) and a clock tick device driver.

For each configuration parameter in the configuration tables, the macro
corresponding to that field is discussed.  Most systems can be easily
configured using the `rtems/confdefs.h' mechanism.

The `CONFIGURE_INIT' constant must be defined in order to make
`rtems/confdefs.h' instantiate the configuration data structures.  This
can only be defined in one source file per application that includes
`rtems/confdefs.h' or the symbol table will be instantiated multiple
times and linking errors produced.

The user should be aware that the defaults are intentionally set as low
as possible.  By default, no application resources are configured.  The
`rtems/confdefs.h' file ensures that at least one application tasks or
thread is configured and that at least one of the initialization
task/thread tables is configured.

The `rtems/confdefs.h' file estimates the amount of memory required for
the RTEMS Executive Workspace.  This estimate is only as accurate as
the information given to `rtems/confdefs.h' and may be either too high
or too low for a variety of reasons.  Some of the reasons that
`rtems/confdefs.h' may reserve too much memory for RTEMS are:

   * All tasks/threads are assumed to be floating point.

Conversely, there are many more reasons, the resource estimate could be
too low:

   * Task/thread stacks greater than minimum size must be accounted for
     explicitly by developer.

   * Memory for messages is not included.

   * Device driver requirements are not included.

   * Network stack requirements are not included.

   * Requirements for add-on libraries are not included.

In general, `rtems/confdefs.h' is very accurate when given enough
information.  However, it is quite easy to use a library and not
account for its resources.

The following subsection list all of the constants which can be set by
the user.


File: ada_user.info,  Node: Configuring a System Library Support Definitions,  Next: Configuring a System Basic System Information,  Prev: Configuring a System Automatic Generation of System Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.1 Library Support Definitions
----------------------------------

This section defines the file system and IO library related
configuration parameters supported by `rtems/confdefs.h'.

   * `CONFIGURE_MALLOC_STATISTICS' is defined when the application
     wishes to enable the gathering of more detailed statistics on the
     C Malloc Family of routines.

   * `CONFIGURE_MALLOC_BSP_SUPPORTS_SBRK' is defined by a BSP to
     indicate that it does not allocate all available memory to the C
     Program Heap used by the Malloc Family of routines.  If defined,
     when `malloc()' is unable to allocate memory, it will call the BSP
     supplied `sbrk()' to obtain more memory.

   * `CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS' is set to the maximum
     number of files that can be concurrently open.  Libio requires a
     Classic RTEMS semaphore for each file descriptor as well as one
     global one.  The default value is 3 file descriptors which is
     enough to support standard input, output, and error output.

   * `CONFIGURE_TERMIOS_DISABLED' is defined if the software
     implementing POSIX termios functionality is not going to be used
     by this application.  By default, this is not defined and
     resources are reserved for the termios functionality.

   * `CONFIGURE_NUMBER_OF_TERMIOS_PORTS' is set to the number of ports
     using the termios functionality.  Each concurrently active termios
     port requires resources.  By default, this is set to 1 so a
     console port can be used.

   * `CONFIGURE_HAS_OWN_MOUNT_TABLE' is defined when the application
     provides their own filesystem mount table.  The mount table is an
     array of `rtems_filesystem_mount_table_t' entries pointed to by
     the global variable `rtems_filesystem_mount_table'.  The number of
     entries in this table is in an integer variable named
     `rtems_filesystem_mount_table_t'.

   * `CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM' is defined if the
     application wishes to use the full functionality IMFS.  By
     default, the miniIMFS is used.  The miniIMFS is a minimal
     functionality subset of the In-Memory FileSystem (IMFS).  The
     miniIMFS is comparable in functionality to the pseudo-filesystem
     name space provided before RTEMS release 4.5.0.  The miniIMFS
     supports only directories and device nodes and is smaller in
     executable code size than the full IMFS.

   * `CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM' is defined if the
     application wishes to use the device-only filesytem. The
     device-only filesystem supports only device nodes and is smaller
     in executable code size than the full IMFS and miniIMFS.

   * `CONFIGURE_APPLICATION_DISABLE_FILESYSTEM' is defined if the
     application dose not intend to use any kind of filesystem
     supports(including printf family).

   * `CONFIGURED_STACK_CHECKER_ENABLED' is defined when the application
     wishes to enable run-time stack bounds checking.  This increases
     the time required to create tasks as well as adding overhead to
     each context switch.  By default, this is not defined and thus
     stack checking is disabled.  NOTE: In 4.9 and older, this was named
     `STACK_CHECKER_ON'



File: ada_user.info,  Node: Configuring a System Basic System Information,  Next: Configuring a System Idle Task Configuration,  Prev: Configuring a System Library Support Definitions,  Up: Configuring a System Automatic Generation of System Configuration

23.2.2 Basic System Information
-------------------------------

This section defines the general system configuration parameters
supported by `rtems/confdefs.h'.

   * `CONFIGURE_HAS_OWN_CONFIGURATION_TABLE' should only be defined if
     the application is providing their own complete set of
     configuration tables.

   * `CONFIGURE_EXECUTIVE_RAM_WORK_AREA' is the base address of the
     RTEMS RAM Workspace.  By default, this value is NULL indicating
     that the BSP is to determine the location of the RTEMS RAM
     Workspace.

   * `CONFIGURE_UNIFIED_WORK_AREAS' configures RTEMS to use a single
     memory pool for the RTEMS Workspace and C Program Heap.  If not
     defined, there will be separate memory pools for the RTEMS
     Workspace and C Program Heap.  Having separate pools does have
     some advantages in the event a task blows a stack or writes
     outside its memory area. However, in low memory systems the
     overhead of the two pools plus the potential for unused memory in
     either pool is very undesirable.

     In high memory environments, this is desirable when you want to
     use the RTEMS "unlimited" objects option.  You will be able to
     create objects until you run out of all available memory rather
     then just until you run out of RTEMS Workspace.

   * `CONFIGURE_MICROSECONDS_PER_TICK' is the length of time between
     clock ticks.  By default, this is set to 10000 microseconds.

   * `CONFIGURE_TICKS_PER_TIMESLICE' is the length of the timeslice
     quantum in ticks for each task.  By default, this is 50.

   * `CONFIGURE_MAXIMUM_PRIORITY' is the maximum numeric priority of
     any task in the system and one less that the number of priority
     levels in the system.  The numerically greatest priority is the
     logically lowest priority in the system and will thus be used by
     the IDLE task.  Valid values for this configuration parameter must
     be one (1) less than than a power of two (2) between 4 and 256
     inclusively.  In other words, valid values are 3, 7, 31, 63, 127,
     and 255.  Reducing the number of priorities in the system reduces
     the amount of memory allocated from the RTEMS Workspace.  By
     default, RTEMS supports 256 priority levels ranging from 0 to 255
     so the default value for this field is 255.

   * `CONFIGURE_MINIMUM_TASK_STACK_SIZE' is set to the number of bytes
     the application wants the minimum stack size to be for every task
     or thread in the system.  By default, this is set to the
     recommended minimum stack size for this processor.

   * `CONFIGURE_INTERRUPT_STACK_SIZE' is set to the size of the
     interrupt stack.  The interrupt stack size is usually set by the
     BSP but since this memory may be allocated from the RTEMS Ram
     Workspace, it must be accounted for.  The default for this field
     is the configured minimum stack size.  [NOTE: In some BSPs,
     changing this constant does NOT change the size of the interrupt
     stack, only the amount of memory reserved for it.] If not
     specified, the interrupt stack will be of minimum size.  The
     default value is the configured minimum stack size.

   * `CONFIGURE_TASK_STACK_ALLOCATOR' may point to a user provided
     routine to allocate task stacks.  The default value for this field
     is NULL which indicates that task stacks will be allocated from
     the RTEMS Workspace.

   * `CONFIGURE_TASK_STACK_DEALLOCATOR' may point to a user provided
     routine to free task stacks.  The default value for this field is
     NULL which indicates that task stacks will be allocated from the
     RTEMS Workspace.

   * `CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY' indicates whether RTEMS
     should zero the RTEMS Workspace and C Program Heap as part of its
     initialization.  If set to TRUE, the Workspace is zeroed.
     Otherwise, it is not.  Unless overridden by the BSP, the default
     value for this field is FALSE.

   * `CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE' is a helper macro which is
     used to assist in computing the total amount of memory required
     for message buffers.  Each message queue will have its own
     configuration with maximum message size and maximum number of
     pending messages.  The interface for this macro is as follows:

          CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE(max_messages, size_per)

     Where `max_messages' is the maximum number of pending messages and
     `size_per' is the size in bytes of the user message.

   * `CONFIGURE_MESSAGE_BUFFER_MEMORY' is set to the number of bytes
     the application requires to be reserved for pending message queue
     buffers.  This value should include memory for all buffers across
     all APIs.  The default value is 0.

     The following illustrates how the help macro
     `CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE' can be used to assist in
     calculating the message buffer memory required.  In this example,
     there are two message queues used in this application.  The first
     message queue has maximum of 24 pending messages with the message
     structure defined by the type `one_message_type'.  The other
     message queue has maximum of 500 pending messages with the message
     structure defined by the type `other_message_type'.


          #define CONFIGURE_MESSAGE_BUFFER_MEMORY \
           (CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \
              24, sizeof(one_message_type) + \
            CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \
              500, sizeof(other_message_type) \
           )

   * `CONFIGURE_MEMORY_OVERHEAD' is set to the number of kilobytes the
     application wishes to add to the requirements calculated by
     `rtems/confdefs.h'.  The default value is 0.

   * `CONFIGURE_EXTRA_TASK_STACKS' is set to the number of bytes the
     applications wishes to add to the task stack requirements
     calculated by `rtems/confdefs.h'.  This parameter is very
     important.  If the application creates tasks with stacks larger
     then the minimum, then that memory is NOT accounted for by
     `rtems/confdefs.h'.  The default value is 0.


NOTE: The required size of the Executive RAM Work Area is calculated
automatically when using the `rtems/confdefs.h' mechanism.


File: ada_user.info,  Node: Configuring a System Idle Task Configuration,  Next: Configuring a System Device Driver Table,  Prev: Configuring a System Basic System Information,  Up: Configuring a System Automatic Generation of System Configuration

23.2.3 Idle Task Configuration
------------------------------

This section defines the IDLE task related configuration parameters
supported by `rtems/confdefs.h'.

   * `CONFIGURE_IDLE_TASK_BODY' is set to the method name corresponding
     to the application specific IDLE thread body.  If not specified,
     the BSP or RTEMS default IDLE thread body will be used.  The
     default value is NULL.

   * `CONFIGURE_IDLE_TASK_STACK_SIZE' is set to the desired stack size
     for the IDLE task.  If not specified, the IDLE task will have a
     stack of minimum size.  The default value is the configured
     minimum stack size.

   * `CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION' is set to indicate
     that the user has configured NO user initialization tasks or
     threads and that the user provided IDLE task will perform
     application initialization and then transform itself into an IDLE
     task.  If you use this option be careful, the user IDLE task
     CANNOT block at all during the initialization sequence.  Further,
     once application initialization is complete, it must make itself
     preemptible and enter an IDLE body loop.  By default, this is not
     the mode of operation and the user is assumed to provide one or
     more initialization tasks.



File: ada_user.info,  Node: Configuring a System Device Driver Table,  Next: Configuring a System Multiprocessing Configuration,  Prev: Configuring a System Idle Task Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.4 Device Driver Table
--------------------------

This section defines the configuration parameters related to the
automatic generation of a Device Driver Table.  As `rtems/confdefs.h'
only is aware of a small set of standard device drivers, the generated
Device Driver Table is suitable for simple applications with no custom
device drivers.

   * `CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE' is defined if the
     application wishes to provide their own Device Driver Table.  The
     table generated is an array of `rtems_driver_address_table'
     entries named `Device_drivers'.  By default, this is not defined
     indicating the `rtems/confdefs.h' is providing the device driver
     table.

   * `CONFIGURE_MAXIMUM_DRIVERS' is defined as the number of device
     drivers per node.  By default, this is set to 10.

   * `CONFIGURE_MAXIMUM_DEVICES' is defined to the number of individual
     devices that may be registered in the system.  By default, this is
     set to 4.

   * `CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER' is defined if the
     application wishes to include the Console Device Driver.  This
     device driver is responsible for providing standard input and
     output using "/dev/console".  By default, this is not defined.

   * `CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER' is defined if the
     application wishes to include the Clock Device Driver.  This
     device driver is responsible for providing a regular interrupt
     which invokes the `rtems_clock_tick' directive.  By default, this
     is not defined.

   * `CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER' is defined if the
     application wishes to include the Timer Driver.  This device
     driver is used to benchmark execution times by the RTEMS Timing
     Test Suites.  By default, this is not defined.

   * `CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER' is defined when
     the application does NOT want the Clock Device Driver and is NOT
     using the Timer Driver.  The inclusion or exclusion of the Clock
     Driver must be explicit in typical user applications.  This is
     intended to prevent the common user error of using the Hello World
     example as the baseline for an application and leaving out a clock
     tick source.

   * `CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER' is defined if the
     application wishes to include the Real-Time Clock Driver.  By
     default, this is not defined.

   * `CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER' is defined if the
     application wishes to include the Watchdog Driver.  By default,
     this is not defined.

   * `CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER' is defined if
     the application wishes to include the BSP's Frame Buffer Device
     Driver.  Most BSPs do not provide a Frame Buffer Device Driver.
     If this is defined and the BSP does not have this device driver,
     then the user will get a link time error for an undefined symbol.
     By default, this is not defined.

   * `CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER' is defined if the
     application wishes to include the Stub Device Driver.  This device
     driver simply provides entry points that return successful and is
     primarily a test fixture.  By default, this is not defined.

   * `CONFIGURE_BSP_PREREQUISITE_DRIVERS' is defined if the BSP has
     device drivers it needs to include in the Device Driver Table.
     This should be defined to the set of device driver entries that
     will be placed in the table at the FRONT of the Device Driver Table
     and initialized before any other drivers INCLUDING any application
     prerequisite drivers.  By default,this is not defined.

   * `CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS' is defined if the
     application has device drivers it needs to include in the Device
     Driver Table.  This should be defined to the set of device driver
     entries that will be placed in the table at the FRONT of the
     Device Driver Table and initialized before any other drivers
     EXCEPT any BSP prerequisite drivers.  By default,this is not
     defined.

   * `CONFIGURE_APPLICATION_EXTRA_DRIVERS' is defined if the
     application has device drivers it needs to include in the Device
     Driver Table.  This should be defined to the set of device driver
     entries that will be placed in the table at the END of the Device
     Driver Table.  By default,this is not defined.



File: ada_user.info,  Node: Configuring a System Multiprocessing Configuration,  Next: Configuring a System Classic API Configuration,  Prev: Configuring a System Device Driver Table,  Up: Configuring a System Automatic Generation of System Configuration

23.2.5 Multiprocessing Configuration
------------------------------------

This section defines the multiprocessing related system configuration
parameters supported by `rtems/confdefs.h'.  This class of
Configuration Constants are only applicable if
`CONFIGURE_MP_APPLICATION' is defined.

   * `CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE' is defined if the
     application wishes to provide their own Multiprocessing
     Configuration Table.  The generated table is named
     `Multiprocessing_configuration'.  By default, this is not defined.

   * `CONFIGURE_MP_NODE_NUMBER' is the node number of this node in a
     multiprocessor system.  The default node number is `NODE_NUMBER'
     which is set directly in RTEMS test Makefiles.

   * `CONFIGURE_MP_MAXIMUM_NODES' is the maximum number of nodes in a
     multiprocessor system.  The default is 2.

   * `CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS' is the maximum number of
     concurrently active global objects in a multiprocessor system.
     The default is 32.

   * `CONFIGURE_MP_MAXIMUM_PROXIES' is the maximum number of
     concurrently active thread/task proxies in a multiprocessor
     system.  The default is 32.

   * `CONFIGURE_MP_MPCI_TABLE_POINTER' is the pointer to the MPCI
     Configuration Table.  The default value of this field is
     `&MPCI_table'.


File: ada_user.info,  Node: Configuring a System Classic API Configuration,  Next: Configuring a System Classic API Initialization Tasks Table Configuration,  Prev: Configuring a System Multiprocessing Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.6 Classic API Configuration
--------------------------------

This section defines the Classic API related system configuration
parameters supported by `rtems/confdefs.h'.

   * `CONFIGURE_MAXIMUM_TASKS' is the maximum number of Classic API
     tasks that can be concurrently active.  The default for this field
     is 0.

   * `CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS' should be defined if the
     user does not want to have support for Classic API Notepads in
     their application.  By default, this is not defined and Classic API
     Notepads are supported.

   * `CONFIGURE_MAXIMUM_TIMERS' is the maximum number of Classic API
     timers that can be concurrently active.  The default for this
     field is 0.

   * `CONFIGURE_MAXIMUM_SEMAPHORES' is the maximum number of Classic
     API semaphores that can be concurrently active.  The default for
     this field is 0.

   * `CONFIGURE_MAXIMUM_MESSAGE_QUEUES' is the maximum number of
     Classic API message queues that can be concurrently active.  The
     default for this field is 0.

   * `CONFIGURE_MAXIMUM_PARTITIONS' is the maximum number of Classic
     API partitions that can be concurrently active.  The default for
     this field is 0.

   * `CONFIGURE_MAXIMUM_REGIONS' is the maximum number of Classic API
     regions that can be concurrently active.  The default for this
     field is 0.

   * `CONFIGURE_MAXIMUM_PORTS' is the maximum number of Classic API
     ports that can be concurrently active.  The default for this field
     is 0.

   * `CONFIGURE_MAXIMUM_PERIODS' is the maximum number of Classic API
     rate monotonic periods that can be concurrently active.  The
     default for this field is 0.

   * `CONFIGURE_MAXIMUM_USER_EXTENSIONS' is the maximum number of
     Classic API user extensions that can be concurrently active.  The
     default for this field is 0.



File: ada_user.info,  Node: Configuring a System Classic API Initialization Tasks Table Configuration,  Next: Configuring a System POSIX API Configuration,  Prev: Configuring a System Classic API Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.7 Classic API Initialization Tasks Table Configuration
-----------------------------------------------------------

The `rtems/confdefs.h' configuration system can automatically generate
an Initialization Tasks Table named `Initialization_tasks' with a
single entry.  The following parameters control the generation of that
table.

   * `CONFIGURE_RTEMS_INIT_TASKS_TABLE' is defined if the user wishes
     to use a Classic RTEMS API Initialization Task Table.  The
     application may choose to use the initialization tasks or threads
     table from another API.  By default, this field is not defined as
     the user MUST select their own API for initialization tasks.

   * `CONFIGURE_HAS_OWN_INIT_TASK_TABLE' is defined if the user wishes
     to define their own Classic API Initialization Tasks Table.  This
     table should be named `Initialization_tasks'.  By default, this is
     not defined.

   * `CONFIGURE_INIT_TASK_NAME' is the name of the single
     initialization task defined by the Classic API Initialization
     Tasks Table.  By default the value is `rtems_build_name( 'U', 'I',
     '1', ' ' )'.

   * `CONFIGURE_INIT_TASK_STACK_SIZE' is the stack size of the single
     initialization task defined by the Classic API Initialization
     Tasks Table.  By default value is the configured minimum stack
     size.

   * `CONFIGURE_INIT_TASK_PRIORITY' is the initial priority of the
     single initialization task defined by the Classic API
     Initialization Tasks Table.  By default the value is 1 which is
     the highest priority in the Classic API.

   * `CONFIGURE_INIT_TASK_ATTRIBUTES' is the task attributes of the
     single initialization task defined by the Classic API
     Initialization Tasks Table.  By default the value is
     `RTEMS_DEFAULT_ATTRIBUTES'.

   * `CONFIGURE_INIT_TASK_ENTRY_POINT' is the entry point (a.k.a.
     function name) of the single initialization task defined by the
     Classic API Initialization Tasks Table.  By default the value is
     `Init'.

   * `CONFIGURE_INIT_TASK_INITIAL_MODES' is the initial execution mode
     of the single initialization task defined by the Classic API
     Initialization Tasks Table.  By default the value is
     `RTEMS_NO_PREEMPT'.

   * `CONFIGURE_INIT_TASK_ARGUMENTS' is the task argument of the single
     initialization task defined by the Classic API Initialization
     Tasks Table.  By default the value is 0.



File: ada_user.info,  Node: Configuring a System POSIX API Configuration,  Next: Configuring a System POSIX Initialization Threads Table Configuration,  Prev: Configuring a System Classic API Initialization Tasks Table Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.8 POSIX API Configuration
------------------------------

The parameters in this section are used to configure resources for the
RTEMS POSIX API.  They are only relevant if the POSIX API is enabled at
configure time using the `--enable-posix' option.

   * `CONFIGURE_MAXIMUM_POSIX_THREADS' is the maximum number of POSIX
     API threads that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_MUTEXES' is the maximum number of POSIX
     API mutexes that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES' is the maximum
     number of POSIX API condition variables that can be concurrently
     active.  The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_KEYS' is the maximum number of POSIX API
     keys that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_TIMERS' is the maximum number of POSIX
     API timers that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS' is the maximum number of
     POSIX API queued signals that can be concurrently active.  The
     default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES' is the maximum number of
     POSIX API message queues that can be concurrently active.  The
     default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS' is the maximum
     number of POSIX API message queue descriptors that can be
     concurrently active.
     `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS' should be
     greater than or equal to `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES'.
     The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_SEMAPHORES' is the maximum number of
     POSIX API semaphores that can be concurrently active.  The default
     is 0.

   * `CONFIGURE_MAXIMUM_POSIX_BARRIERS' is the maximum number of POSIX
     API barriers that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_SPINLOCKS' is the maximum number of POSIX
     API spinlocks that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_POSIX_RWLOCKS' is the maximum number of POSIX
     API read-write locks that can be concurrently active.  The default
     is 0.



File: ada_user.info,  Node: Configuring a System POSIX Initialization Threads Table Configuration,  Next: Configuring a System ITRON API Configuration,  Prev: Configuring a System POSIX API Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.9 POSIX Initialization Threads Table Configuration
-------------------------------------------------------

The `rtems/confdefs.h' configuration system can automatically generate
a POSIX Initialization Threads Table named
`POSIX_Initialization_threads' with a single entry.  The following
parameters control the generation of that table.

   * `CONFIGURE_POSIX_INIT_THREAD_TABLE' is defined if the user wishes
     to use a POSIX API Initialization Threads Table.  The application
     may choose to use the initialization tasks or threads table from
     another API.  By default, this field is not defined as the user
     MUST select their own API for initialization tasks.

   * `CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE' is defined if the user
     wishes to define their own POSIX API Initialization Threads Table.
     This table should be named `POSIX_Initialization_threads'.  By
     default, this is not defined.

   * `CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT' is the entry point
     (a.k.a. function name) of the single initialization thread defined
     by the POSIX API Initialization Threads Table.  By default the
     value is `POSIX_Init'.

   * `CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE' is the stack size of the
     single initialization thread defined by the POSIX API
     Initialization Threads Table.  By default value is twice the
     configured minimum stack size.



File: ada_user.info,  Node: Configuring a System ITRON API Configuration,  Next: Configuring a System ITRON Initialization Task Table Configuration,  Prev: Configuring a System POSIX Initialization Threads Table Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.10 ITRON API Configuration
-------------------------------

The parameters in this section are used to configure resources for the
RTEMS ITRON API.  They are only relevant if the POSIX API is enabled at
configure time using the `--enable-itron' option.

   * `CONFIGURE_MAXIMUM_ITRON_TASKS' is the maximum number of ITRON API
     tasks that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_ITRON_SEMAPHORES' is the maximum number of
     ITRON API semaphores that can be concurrently active.  The default
     is 0.

   * `CONFIGURE_MAXIMUM_ITRON_EVENTFLAGS' is the maximum number of
     ITRON API eventflags that can be concurrently active.  The default
     is 0.

   * `CONFIGURE_MAXIMUM_ITRON_MAILBOXES' is the maximum number of ITRON
     API mailboxes that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_ITRON_MESSAGE_BUFFERS' is the maximum number of
     ITRON API message buffers that can be concurrently active.  The
     default is 0.

   * `CONFIGURE_MAXIMUM_ITRON_PORTS' is the maximum number of ITRON API
     ports that can be concurrently active.  The default is 0.

   * `CONFIGURE_MAXIMUM_ITRON_MEMORY_POOLS' is the maximum number of
     ITRON API memory pools that can be concurrently active.  The
     default is 0.

   * `CONFIGURE_MAXIMUM_ITRON_FIXED_MEMORY_POOLS' is the maximum number
     of ITRON API fixed memory pools that can be concurrently active.
     The default is 0.



File: ada_user.info,  Node: Configuring a System ITRON Initialization Task Table Configuration,  Next: Configuring a System Ada Tasks,  Prev: Configuring a System ITRON API Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.11 ITRON Initialization Task Table Configuration
-----------------------------------------------------

The `rtems/confdefs.h' configuration system can automatically generate
an ITRON Initialization Tasks Table named `ITRON_Initialization_tasks'
with a single entry.  The following parameters control the generation
of that table.

   * `CONFIGURE_ITRON_INIT_TASK_TABLE' is defined if the user wishes to
     use a ITRON API Initialization Tasks Table.  The application may
     choose to use the initialization tasks or threads table from
     another API.  By default, this field is not defined as the user
     MUST select their own API for initialization tasks.

   * `CONFIGURE_ITRON_HAS_OWN_INIT_TASK_TABLE' is defined if the user
     wishes to define their own ITRON API Initialization Tasks Table.
     This table should be named `ITRON_Initialization_tasks'.  By
     default, this is not defined.

   * `CONFIGURE_ITRON_INIT_TASK_ENTRY_POINT' is the entry point (a.k.a.
     function name) of the single initialization task defined by the
     ITRON API Initialization Tasks Table.  By default the value is
     `ITRON_Init'.

   * `CONFIGURE_ITRON_INIT_TASK_ATTRIBUTES' is the attribute set of the
     single initialization task defined by the ITRON API Initialization
     Tasks Table.  By default the value is `TA_HLNG'.

   * `CONFIGURE_ITRON_INIT_TASK_PRIORITY' is the initial priority of
     the single initialization task defined by the ITRON API
     Initialization Tasks Table.  By default the value is `1' which is
     the highest priority in the ITRON API.

   * `CONFIGURE_ITRON_INIT_TASK_STACK_SIZE' is the stack size of the
     single initialization task defined by the ITRON API Initialization
     Tasks Table.  By default value is the configured minimum stack
     size.



File: ada_user.info,  Node: Configuring a System Ada Tasks,  Next: Configuring a System Configuration Table,  Prev: Configuring a System ITRON Initialization Task Table Configuration,  Up: Configuring a System Automatic Generation of System Configuration

23.2.12 Ada Tasks
-----------------

This section defines the system configuration parameters supported by
`rtems/confdefs.h' related to configuring RTEMS to support a task using
Ada tasking with GNAT.

   * `CONFIGURE_GNAT_RTEMS' is defined to inform RTEMS that the GNAT
     Ada run-time is to be used by the application.  This configuration
     parameter is critical as it makes `rtems/confdefs.h' configure the
     resources (mutexes and keys) used implicitly by the GNAT run-time.
     By default, this parameter is not defined.

   * `CONFIGURE_MAXIMUM_ADA_TASKS' is the number of Ada tasks that can
     be concurrently active in the system.  By default, when
     `CONFIGURE_GNAT_RTEMS' is defined, this is set to 20.

   * `CONFIGURE_MAXIMUM_FAKE_ADA_TASKS' is the number of "fake" Ada
     tasks that can be concurrently active in the system.  A "fake" Ada
     task is a non-Ada task that makes calls back into Ada code and thus
     implicitly uses the Ada run-time.



File: ada_user.info,  Node: Configuring a System Configuration Table,  Next: Configuring a System RTEMS API Configuration Table,  Prev: Configuring a System Ada Tasks,  Up: Configuring a System

23.3 Configuration Table
========================

The RTEMS Configuration Table is used to tailor an application for its
specific needs.  For example, the user can configure the number of
device drivers or which APIs may be used.  THe address of the
user-defined Configuration Table is passed as an argument to the
`rtems_initialize_executive' directive, which MUST be the first RTEMS
directive called.  The RTEMS Configuration Table is defined in the
following C structure:

     typedef struct {
       void                           *work_space_start;
       uintptr_t                       work_space_size;
       uint32_t                        maximum_extensions;
       uint32_t                        microseconds_per_tick;
       uint32_t                        ticks_per_timeslice;
       void                          (*idle_task)( void );
       uint32_t                        idle_task_stack_size;
       uint32_t                        interrupt_stack_size;
       void *                        (*stack_allocate_hook)( size_t );
       void                          (*stack_free_hook)( void * );
       bool                            do_zero_of_workspace;
       uint32_t                        maximum_drivers;
       uint32_t                        number_of_device_drivers;
       rtems_driver_address_table     *Device_driver_table;
       uint32_t                        number_of_initial_extensions;
       rtems_extensions_table         *User_extension_table;
     #if defined(RTEMS_MULTIPROCESSING)
       rtems_multiprocessing_table    *User_multiprocessing_table;
     #endif
       rtems_api_configuration_table  *RTEMS_api_configuration;
       posix_api_configuration_table  *POSIX_api_configuration;
       itron_api_configuration        *ITRON_api_configuration;
     } rtems_configuration_table;

work_space_start
     is the address of the RTEMS RAM Workspace.  This area contains
     items such as the various object control blocks (TCBs, QCBs, ...)
     and task stacks.  If the address is not aligned on a four-word
     boundary, then RTEMS will invoke the fatal error handler during
     `rtems_initialize_executive'.  When using the `rtems/confdefs.h'
     mechanism for configuring an RTEMS application, the value for this
     field corresponds to the setting of the macro
     `CONFIGURE_EXECUTIVE_RAM_WORK_AREA' which defaults to `NULL'.
     Normally, this field should be configured as `NULL' as BSPs will
     assign memory for the RTEMS RAM Workspace as part of system
     initialization.

work_space_size
     is the calculated size of the RTEMS RAM Workspace.  The section
     Sizing the RTEMS RAM Workspace details how to arrive at this
     number.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_EXECUTIVE_RAM_SIZE' and is calculated based on the
     other system configuration settings.

microseconds_per_tick
     is number of microseconds per clock tick.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_MICROSECONDS_PER_TICK'.  If not defined by the
     application, then the `CONFIGURE_MICROSECONDS_PER_TICK' macro
     defaults to 10000 (10 milliseconds).

ticks_per_timeslice
     is the number of clock ticks for a timeslice.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_TICKS_PER_TIMESLICE'.

idle_task
     is the address of the optional user provided routine which is used
     as the system's IDLE task.  If this field is not NULL, then the
     RTEMS default IDLE task is not used.  This field may be NULL to
     indicate that the default IDLE is to be used.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_IDLE_TASK_BODY'.

idle_task_stack_size
     is the size of the RTEMS idle task stack in bytes.  If this number
     is less than the configured minimum stack size, then the idle
     task's stack will be set to the minimum.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_IDLE_TASK_STACK_SIZE'.

interrupt_stack_size
     is the size of the RTEMS interrupt stack in bytes.  If this number
     is less than configured minimum stack size, then the interrupt
     stack will be set to the minimum.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_INTERRUPT_STACK_SIZE'.

stack_allocate_hook
     may point to a user provided routine to allocate task stacks.  The
     default is to allocate task stacks from the RTEMS Workspace.  When
     using the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the value for this field corresponds to the setting
     of the macro `CONFIGURE_TASK_STACK_ALLOCATOR'.

stack_free_hook
     may point to a user provided routine to free task stacks.  The
     default is to allocate task stacks from the RTEMS Workspace.  When
     using the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the value for this field corresponds to the setting
     of the macro `CONFIGURE_TASK_STACK_DEALLOCATOR'.

do_zero_of_workspace
     indicates whether RTEMS should zero the RTEMS Workspace and C
     Program Heap as part of its initialization.  If set to TRUE, the
     Workspace is zeroed.  Otherwise, it is not.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY'.

maximum_drivers
     is the maximum number of device drivers that can be registered.
     When using the `rtems/confdefs.h' mechanism for configuring an
     RTEMS application, the value for this field corresponds to the
     setting of the macro `CONFIGURE_MAXIMUM_DRIVERS'.

number_of_device_drivers
     is the number of device drivers for the system.  There should be
     the same number of entries in the Device Driver Table.  If this
     field is zero, then the `User_driver_address_table' entry should
     be NULL.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field is
     calculated automatically based on the number of entries in the
     Device Driver Table.  This calculation is based on the assumption
     that the Device Driver Table is named `Device_drivers' and defined
     in C.  This table may be generated automatically for simple
     applications using only the device drivers that correspond to the
     following macros:

        * `CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER'

        * `CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER'

        * `CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER'

        * `CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER'

        * `CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER'


     Note that network device drivers are not configured in the Device
     Driver Table.

Device_driver_table
     is the address of the Device Driver Table.  This table contains
     the entry points for each device driver.  If the
     number_of_device_drivers field is zero, then this entry should be
     NULL. The format of this table will be discussed below.  When
     using the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the Device Driver Table is assumed to be named
     `Device_drivers' and defined in C.  If the application is providing
     its own Device Driver Table, then the macro
     `CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE' must be defined to indicate
     this and prevent `rtems/confdefs.h' from generating the table.

number_of_initial_extensions
     is the number of initial user extensions.  There should be the
     same number of entries as in the User_extension_table.  If this
     field is zero, then the User_driver_address_table entry should be
     NULL.  When using the `rtems/confdefs.h' mechanism for configuring
     an RTEMS application, the value for this field corresponds to the
     setting of the macro `CONFIGURE_NUMBER_OF_INITIAL_EXTENSIONS'
     which is set automatically by `rtems/confdefs.h' based on the size
     of the User Extensions Table.

User_extension_table
     is the address of the User Extension Table.  This table contains
     the entry points for the static set of optional user extensions.
     If no user extensions are configured, then this entry should be
     NULL.  The format of this table will be discussed below.  When
     using the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the User Extensions Table is named
     `Configuration_Initial_Extensions' and defined in confdefs.h.  It
     is initialized based on the following macros:

        * `CONFIGURE_INITIAL_EXTENSIONS'

        * `STACK_CHECKER_EXTENSION'


     The application may configure one or more initial user extension
     sets by setting the `CONFIGURE_INITIAL_EXTENSIONS' macro.  By
     defining the `STACK_CHECKER_EXTENSION' macro, the task stack bounds
     checking user extension set is automatically included in the
     application.

User_multiprocessing_table
     is the address of the Multiprocessor Configuration Table.  This
     table contains information needed by RTEMS only when used in a
     multiprocessor configuration.  This field must be NULL when RTEMS
     is used in a single processor configuration.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the Multiprocessor Configuration Table is automatically generated
     when the `CONFIGURE_MP_APPLICATION' is defined.  If
     `CONFIGURE_MP_APPLICATION' is not defined, the this entry is set
     to NULL.  The generated table has the name
     `Multiprocessing_configuration'.

RTEMS_api_configuration
     is the address of the RTEMS API Configuration Table.  This table
     contains information needed by the RTEMS API.  This field should be
     NULL if the RTEMS API is not used.  [NOTE: Currently the RTEMS API
     is required to support support components such as BSPs and
     libraries which use this API.]  This table is built automatically
     and this entry filled in, if using the `rtems/confdefs.h'
     application configuration mechanism.  The generated table has the
     name `Configuration_RTEMS_API'.

POSIX_api_configuration
     is the address of the POSIX API Configuration Table.  This table
     contains information needed by the POSIX API.  This field should be
     NULL if the POSIX API is not used.  This table is built
     automatically and this entry filled in, if using the
     `rtems/confdefs.h' application configuration mechanism.  The
     `rtems/confdefs.h' application mechanism will fill this field in
     with the address of the `Configuration_POSIX_API' table of POSIX
     API is configured and NULL if the POSIX API is not configured.



File: ada_user.info,  Node: Configuring a System RTEMS API Configuration Table,  Next: Configuring a System POSIX API Configuration Table,  Prev: Configuring a System Configuration Table,  Up: Configuring a System

23.4 RTEMS API Configuration Table
==================================

The RTEMS API Configuration Table is used to configure the managers
which constitute the RTEMS API for a particular application.  For
example, the user can configure the maximum number of tasks for this
application. The RTEMS API Configuration Table is defined in the
following C structure:

     typedef struct {
       uint32_t  maximum_tasks;
       uint32_t  maximum_timers;
       uint32_t  maximum_semaphores;
       uint32_t  maximum_message_queues;
       uint32_t  maximum_partitions;
       uint32_t  maximum_regions;
       uint32_t  maximum_ports;
       uint32_t  maximum_periods;
       uint32_t  maximum_barriers;
       uint32_t  number_of_initialization_tasks;
       rtems_initialization_tasks_table *User_initialization_tasks_table;
     } rtems_api_configuration_table;

maximum_tasks
     is the maximum number of tasks that can be concurrently active
     (created) in the system including initialization tasks.  When
     using the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the value for this field corresponds to the setting
     of the macro `CONFIGURE_MAXIMUM_TASKS'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_TASKS' macro defaults to
     0.

maximum_timers
     is the maximum number of timers that can be concurrently active in
     the system.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro `CONFIGURE_MAXIMUM_TIMERS'.
     If not defined by the application, then the
     `CONFIGURE_MAXIMUM_TIMERS' macro defaults to 0.

maximum_semaphores
     is the maximum number of semaphores that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_SEMAPHORES'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_SEMAPHORES' macro
     defaults to 0.

maximum_message_queues
     is the maximum number of message queues that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_MESSAGE_QUEUES'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_MESSAGE_QUEUES' macro
     defaults to 0.

maximum_partitions
     is the maximum number of partitions that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_PARTITIONS'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_PARTITIONS' macro
     defaults to 0.

maximum_regions
     is the maximum number of regions that can be concurrently active
     in the system.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_REGIONS'.  If not defined by the application,
     then the `CONFIGURE_MAXIMUM_REGIONS' macro defaults to 0.

maximum_ports
     is the maximum number of ports into dual-port memory areas that
     can be concurrently active in the system.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_PORTS'.  If not defined by the application,
     then the `CONFIGURE_MAXIMUM_PORTS' macro defaults to 0.

number_of_initialization_tasks
     is the number of initialization tasks configured.  At least one
     RTEMS initialization task or POSIX initializatin must be configured
     in order for the user's application to begin executing.  When
     using the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the user must define the
     `CONFIGURE_RTEMS_INIT_TASKS_TABLE' to indicate that there is one
     or more RTEMS initialization task.  If the application only has
     one RTEMS initialization task, then the automatically generated
     Initialization Task Table will be sufficient.  The following
     macros correspond to the single initialization task:

        * `CONFIGURE_INIT_TASK_NAME' - is the name of the task.  If
          this macro is not defined by the application, then this
          defaults to the task name of `"UI1 "' for User Initialization
          Task 1.

        * `CONFIGURE_INIT_TASK_STACK_SIZE' - is the stack size of the
          single initialization task.  If this macro is not defined by
          the application, then this defaults to configured minimum
          stack size.

        * `CONFIGURE_INIT_TASK_PRIORITY' - is the initial priority of
          the single initialization task.  If this macro is not defined
          by the application, then this defaults to 1.

        * `CONFIGURE_INIT_TASK_ATTRIBUTES' - is the attributes of the
          single initialization task.  If this macro is not defined by
          the application, then this defaults to
          `RTEMS_DEFAULT_ATTRIBUTES'.

        * `CONFIGURE_INIT_TASK_ENTRY_POINT' - is the entry point of the
          single initialization task.  If this macro is not defined by
          the application, then this defaults to the C language routine
          `Init'.

        * `CONFIGURE_INIT_TASK_INITIAL_MODES' - is the initial execution
          modes of the single initialization task.  If this macro is
          not defined by the application, then this defaults to
          `RTEMS_NO_PREEMPT'.

        * `CONFIGURE_INIT_TASK_ARGUMENTS' - is the argument passed to
          the of the single initialization task.  If this macro is not
          defined by the application, then this defaults to 0.


     has the option to have  value for this field corresponds to the
     setting of the macro `'.

User_initialization_tasks_table
     is the address of the Initialization Task Table. This table
     contains the information needed to create and start each of the
     initialization tasks.  The format of this table will be discussed
     below.  When using the `rtems/confdefs.h' mechanism for configuring
     an RTEMS application, the value for this field corresponds to the
     setting of the macro `CONFIGURE_EXECUTIVE_RAM_WORK_AREA'.



File: ada_user.info,  Node: Configuring a System POSIX API Configuration Table,  Next: Configuring a System CPU Dependent Information Table,  Prev: Configuring a System RTEMS API Configuration Table,  Up: Configuring a System

23.5 POSIX API Configuration Table
==================================

The POSIX API Configuration Table is used to configure the managers
which constitute the POSIX API for a particular application.  For
example, the user can configure the maximum number of threads for this
application. The POSIX API Configuration Table is defined in the
following C structure:

     typedef struct {
       void       *(*thread_entry)(void *);
     } posix_initialization_threads_table;

     typedef struct {
       int                                 maximum_threads;
       int                                 maximum_mutexes;
       int                                 maximum_condition_variables;
       int                                 maximum_keys;
       int                                 maximum_timers;
       int                                 maximum_queued_signals;
       int                                 maximum_message_queues;
       int                                 maximum_message_queue_descriptors;
       int                                 maximum_semaphores;
       int                                 maximum_barriers;
       int                                 maximum_rwlocks;
       int                                 maximum_spinlocks;
       int                                 number_of_initialization_threads;
       posix_initialization_threads_table *User_initialization_tasks_table;
     } posix_api_configuration_table;

maximum_threads
     is the maximum number of threads that can be concurrently active
     (created) in the system including initialization threads.  When
     using the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the value for this field corresponds to the setting
     of the macro `CONFIGURE_MAXIMUM_POSIX_THREADS'.  If not defined by
     the application, then the `CONFIGURE_MAXIMUM_POSIX_THREADS' macro
     defaults to 0.

maximum_mutexes
     is the maximum number of mutexes that can be concurrently active
     in the system.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_MUTEXES'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_MUTEXES' macro
     defaults to 0.

maximum_condition_variables
     is the maximum number of condition variables that can be
     concurrently active in the system.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES'.  If not defined by
     the application, then the
     `CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES' macro defaults to 0.

maximum_keys
     is the maximum number of keys that can be concurrently active in
     the system.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_KEYS'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_KEYS' macro
     defaults to 0.

maximum_timers
     is the maximum number of POSIX timers that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_TIMERS'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_TIMERS' macro
     defaults to 0.

maximum_queued_signals
     is the maximum number of queued signals that can be concurrently
     pending in the system.  When using the `rtems/confdefs.h'
     mechanism for configuring an RTEMS application, the value for this
     field corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS'
     macro defaults to 0.

maximum_message_queues
     is the maximum number of POSIX message queues that can be
     concurrently active in the system.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES'
     macro defaults to 0.

maximum_message_queue_descriptors
     is the maximum number of POSIX message queue descriptors that can
     be concurrently active in the system.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS'.  If not
     defined by the application, then the
     `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS' macro defaults
     to the value of `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES'

maximum_semaphores
     is the maximum number of POSIX semaphore that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_SEMAPHORES'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_SEMAPHORES' macro
     defaults to 0.

maximum_barriers
     is the maximum number of POSIX barriers that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_BARRIERS'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_BARRIERS' macro
     defaults to 0.

maximum_rwlocks
     is the maximum number of POSIX rwlocks that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_SPINLOCKS'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_SPINLOCKS' macro
     defaults to 0.

maximum_spinlocks
     is the maximum number of POSIX spinlocks that can be concurrently
     active in the system.  When using the `rtems/confdefs.h' mechanism
     for configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES'.  If not defined by the
     application, then the `CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES'
     macro defaults to 0.

number_of_initialization_threads
     is the number of initialization threads configured.  At least one
     initialization threads must be configured.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the user must define the `CONFIGURE_POSIX_INIT_THREAD_TABLE' to
     indicate that there is one or more POSIX initialization thread.
     If the application only has one POSIX initialization thread, then
     the automatically generated POSIX Initialization Thread Table will
     be sufficient.  The following macros correspond to the single
     initialization task:

        * `CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT' - is the entry
          point of the thread.  If this macro is not defined by the
          application, then this defaults to the C routine `POSIX_Init'.

        * `CONFIGURE_POSIX_INIT_TASK_STACK_SIZE' - is the stack size of
          the single initialization thread.  If this macro is not
          defined by the application, then this defaults to twice the
          configured minimum stack size.


User_initialization_threads_table
     is the address of the Initialization Threads Table. This table
     contains the information needed to create and start each of the
     initialization threads.  The format of each entry in this table is
     defined in the `posix_initialization_threads_table' structure.
     When using the `rtems/confdefs.h' mechanism for configuring an
     RTEMS application, the value for this field corresponds to the
     address of the `POSIX_Initialization_threads' structure.



File: ada_user.info,  Node: Configuring a System CPU Dependent Information Table,  Next: Configuring a System Initialization Task Table,  Prev: Configuring a System POSIX API Configuration Table,  Up: Configuring a System

23.6 CPU Dependent Information Table
====================================

The CPU Dependent Information Table is used to describe processor
dependent information required by RTEMS.  This table is generally used
to supply RTEMS with information only known by the Board Support
Package.  The contents of this table are discussed in the CPU Dependent
Information Table chapter of the Applications Supplement document for a
specific target processor.

The `rtems/confdefs.h' mechanism does not support generating this
table.  It is normally filled in by the Board Support Package.


File: ada_user.info,  Node: Configuring a System Initialization Task Table,  Next: Configuring a System Driver Address Table,  Prev: Configuring a System CPU Dependent Information Table,  Up: Configuring a System

23.7 Initialization Task Table
==============================

The Initialization Task Table is used to describe each of the user
initialization tasks to the Initialization Manager.  The table contains
one entry for each initialization task the user wishes to create and
start.  The fields of this data structure directly correspond to
arguments to the `rtems.task_create' and `rtems.task_start' directives.
The number of entries is found in the `number_of_initialization_tasks'
entry in the Configuration Table.

The format of each entry in the Initialization Task Table is defined in
the following C structure:

     typedef struct {
       rtems_name           name;
       size_t               stack_size;
       rtems_task_priority  initial_priority;
       rtems_attribute      attribute_set;
       rtems_task_entry     entry_point;
       rtems_mode           mode_set;
       rtems_task_argument  argument;
     } rtems_initialization_tasks_table;

name
     is the name of this initialization task.

stack_size
     is the size of the stack for this initialization task.

initial_priority
     is the priority of this initialization task.

attribute_set
     is the attribute set used during creation of this initialization
     task.

entry_point
     is the address of the entry point of this initialization task.

mode_set
     is the initial execution mode of this initialization task.

argument
     is the initial argument for this initialization task.


A typical declaration for an Initialization Task Table might appear as
follows:

     rtems_initialization_tasks_table
     Initialization_tasks[2] = {
        { INIT_1_NAME,
          1024,
          1,
          DEFAULT_ATTRIBUTES,
          Init_1,
          DEFAULT_MODES,
          1

        },
        { INIT_2_NAME,
          1024,
          250,
          FLOATING_POINT,
          Init_2,
          NO_PREEMPT,
          2

        }
     };


File: ada_user.info,  Node: Configuring a System Driver Address Table,  Next: Configuring a System User Extensions Table,  Prev: Configuring a System Initialization Task Table,  Up: Configuring a System

23.8 Driver Address Table
=========================

The Device Driver Table is used to inform the I/O Manager of the set of
entry points for each device driver configured in the system.  The table
contains one entry for each device driver required by the application.
The number of entries is defined in the number_of_device_drivers entry
in the Configuration Table.  This table is copied to the Device Drive
Table during the IO Manager's initialization giving the entries in this
table the lower major numbers.  The format of each entry in the Device
Driver Table is defined in the following C structure:

     typedef struct {
       rtems_device_driver_entry initialization_entry;
       rtems_device_driver_entry open_entry;
       rtems_device_driver_entry close_entry;
       rtems_device_driver_entry read_entry;
       rtems_device_driver_entry write_entry;
       rtems_device_driver_entry control_entry;
     } rtems_driver_address_table;

initialization_entry
     is the address of the entry point called by `rtems_io_initialize'
     to initialize a device driver and its associated devices.

open_entry
     is the address of the entry point called by `rtems_io_open'.

close_entry
     is the address of the entry point called by `rtems_io_close'.

read_entry
     is the address of the entry point called by `rtems_io_read'.

write_entry
     is the address of the entry point called by `rtems_io_write'.

control_entry
     is the address of the entry point called by `rtems_io_control'.


Driver entry points configured as NULL will always return a status code
of `RTEMS.SUCCESSFUL'.  No user code will be executed in this situation.

A typical declaration for a Device Driver Table might appear as follows:

     rtems_driver_address_table Driver_table[2] = {
        { tty_initialize, tty_open,  tty_close,  /* major = 0 */
          tty_read,       tty_write, tty_control
        },
        { lp_initialize, lp_open,    lp_close,   /* major = 1 */
          NULL,          lp_write,   lp_control
        }
     };

More information regarding the construction and operation of device
drivers is provided in the I/O Manager chapter.


File: ada_user.info,  Node: Configuring a System User Extensions Table,  Next: Configuring a System Multiprocessor Configuration Table,  Prev: Configuring a System Driver Address Table,  Up: Configuring a System

23.9 User Extensions Table
==========================

The User Extensions Table is used to inform RTEMS of the optional
user-supplied static extension set.  This table contains one entry for
each possible extension.  The entries are called at critical times in
the life of the system and individual tasks.  The application may
create dynamic extensions in addition to this single static set.  The
format of each entry in the User Extensions Table is defined in the
following C structure:

     typedef void           rtems_extension;
     typedef void (*rtems_task_create_extension)(
        Thread_Control * /* executing */,
        Thread_Control * /* created */
     );
     typedef void (*rtems_task_delete_extension)(
        Thread_Control * /* executing */,
        Thread_Control * /* deleted */
     );
     typedef void (*rtems_task_start_extension)(
        Thread_Control * /* executing */,
        Thread_Control * /* started */
     );
     typedef void (*rtems_task_restart_extension)(
        Thread_Control * /* executing */,
        Thread_Control * /* restarted */
     );
     typedef void (*rtems_task_switch_extension)(
        Thread_Control * /* executing */,
        Thread_Control * /* heir */
     );
     typedef void (*rtems_task_begin_extension)(
        Thread_Control * /* beginning */
     );
     typedef void (*rtems_task_exitted_extension)(
        Thread_Control * /* exiting */
     );
     typedef void (*rtems_fatal_extension)(
        Internal_errors_Source /* the_source */,
        bool                   /* is_internal */,
        uint32_t               /* the_error */
     );

     typedef struct {
       rtems_task_create_extension      thread_create;
       rtems_task_start_extension       thread_start;
       rtems_task_restart_extension     thread_restart;
       rtems_task_delete_extension      thread_delete;
       rtems_task_switch_extension      thread_switch;
       rtems_task_begin_extension       thread_begin;
       rtems_task_exitted_extension     thread_exitted;
       rtems_fatal_extension            fatal;
     } rtems_extensions_table;

thread_create
     is the address of the user-supplied subroutine for the TASK_CREATE
     extension.  If this extension for task creation is defined, it is
     called from the task_create directive.  A value of NULL indicates
     that no extension is provided.

thread_start
     is the address of the user-supplied subroutine for the TASK_START
     extension.  If this extension for task initiation is defined, it
     is called from the task_start directive.  A value of NULL
     indicates that no extension is provided.

thread_restart
     is the address of the user-supplied subroutine for the
     TASK_RESTART extension.  If this extension for task re-initiation
     is defined, it is called from the task_restart directive.  A value
     of NULL indicates that no extension is provided.

thread_delete
     is the address of the user-supplied subroutine for the TASK_DELETE
     extension.  If this RTEMS extension for task deletion is defined,
     it is called from the task_delete directive.  A value of NULL
     indicates that no extension is provided.

thread_switch
     is the address of the user-supplied subroutine for the task
     context switch extension.  This subroutine is called from RTEMS
     dispatcher after the current task has been swapped out but before
     the new task has been swapped in.  A value of NULL indicates that
     no extension is provided.  As this routine is invoked after saving
     the current task's context and before restoring the heir task's
     context, it is not necessary for this routine to save and restore
     any registers.

thread_begin
     is the address of the user-supplied subroutine which is invoked
     immediately before a task begins execution.  It is invoked in the
     context of the beginning task.  A value of NULL indicates that no
     extension is provided.

thread_exitted
     is the address of the user-supplied subroutine which is invoked
     when a task exits.  This procedure is responsible for some action
     which will allow the system to continue execution (i.e. delete or
     restart the task) or to terminate with a fatal error.  If this
     field is set to NULL, the default RTEMS TASK_EXITTED handler will
     be invoked.

fatal
     is the address of the user-supplied subroutine for the FATAL
     extension.  This RTEMS extension of fatal error handling is called
     from the `rtems.fatal_error_occurred' directive.  If the user's
     fatal error handler returns or if this entry is NULL then the
     default RTEMS fatal error handler will be executed.


A typical declaration for a User Extension Table which defines the
TASK_CREATE, TASK_DELETE, TASK_SWITCH, and FATAL extension might appear
as follows:

     rtems_extensions_table User_extensions = {
        task_create_extension,
        NULL,
        NULL,
        task_delete_extension,
        task_switch_extension,
        NULL,
        NULL,
        fatal_extension
     };

More information regarding the user extensions is provided in the User
Extensions chapter.


File: ada_user.info,  Node: Configuring a System Multiprocessor Configuration Table,  Next: Configuring a System Multiprocessor Communications Interface Table,  Prev: Configuring a System User Extensions Table,  Up: Configuring a System

23.10 Multiprocessor Configuration Table
========================================

The Multiprocessor Configuration Table contains information needed when
using RTEMS in a multiprocessor configuration.  Many of the details
associated with configuring a multiprocessor system are dependent on
the multiprocessor communications layer provided by the user.  The
address of the Multiprocessor Configuration Table should be placed in
the `User_multiprocessing_table' entry in the primary Configuration
Table.  Further details regarding many of the entries in the
Multiprocessor Configuration Table will be provided in the
Multiprocessing chapter.

When using the `rtems/confdefs.h' mechanism for configuring an RTEMS
application, the macro `CONFIGURE_MP_APPLICATION' must be defined to
automatically generate the Multiprocessor Configuration Table.  If
`CONFIGURE_MP_APPLICATION', is not defined, then a NULL pointer is
configured as the address of this table.

The format of the Multiprocessor Configuration Table is defined in the
following C structure:

     typedef struct {
       uint32_t          node;
       uint32_t          maximum_nodes;
       uint32_t          maximum_global_objects;
       uint32_t          maximum_proxies;
       uint32_t          extra_mpci_receive_server_stack;
       rtems_mpci_table *User_mpci_table;
     } rtems_multiprocessing_table;

node
     is a unique processor identifier and is used in routing messages
     between nodes in a multiprocessor configuration.  Each processor
     must have a unique node number.  RTEMS assumes that node numbers
     start at one and increase sequentially.  This assumption can be
     used to advantage by the user-supplied MPCI layer.  Typically,
     this requirement is made when the node numbers are used to
     calculate the address of inter-processor communication links.
     Zero should be avoided as a node number because some MPCI layers
     use node zero to represent broadcasted packets.  Thus, it is
     recommended that node numbers start at one and increase
     sequentially.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro `CONFIGURE_MP_NODE_NUMBER'.
     If not defined by the application, then the
     `CONFIGURE_MP_NODE_NUMBER' macro defaults to the value of the
     `NODE_NUMBER' macro which is set on the compiler command line by
     the RTEMS Multiprocessing Test Suites.

maximum_nodes
     is the number of processor nodes in the system.  When using the
     `rtems/confdefs.h' mechanism for configuring an RTEMS application,
     the value for this field corresponds to the setting of the macro
     `CONFIGURE_MP_MAXIMUM_NODES'.  If not defined by the application,
     then the `CONFIGURE_MP_MAXIMUM_NODES' macro defaults to the value
     2.

maximum_global_objects
     is the maximum number of global objects which can exist at any
     given moment in the entire system.  If this parameter is not the
     same on all nodes in the system, then a fatal error is generated
     to inform the user that the system is inconsistent.  When using
     the `rtems/confdefs.h' mechanism for configuring an RTEMS
     application, the value for this field corresponds to the setting
     of the macro `CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS'.  If not
     defined by the application, then the
     `CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS' macro defaults to the value
     32.

maximum_proxies
     is the maximum number of proxies which can exist at any given
     moment on this particular node.  A proxy is a substitute task
     control block which represent a task residing on a remote node
     when that task blocks on a remote object.  Proxies are used in
     situations in which delayed interaction is required with a remote
     node.  When using the `rtems/confdefs.h' mechanism for configuring
     an RTEMS application, the value for this field corresponds to the
     setting of the macro `CONFIGURE_MP_MAXIMUM_PROXIES'.  If not
     defined by the application, then the `CONFIGURE_MP_MAXIMUM_PROXIES'
     macro defaults to the value 32.

extra_mpci_receive_server_stack
     is the extra stack space allocated for the RTEMS MPCI receive
     server task in bytes.  The MPCI receive server may invoke nearly
     all directives and may require extra stack space on some targets.

User_mpci_table
     is the address of the Multiprocessor Communications Interface
     Table.  This table contains the entry points of user-provided
     functions which constitute the multiprocessor communications
     layer.  This table must be provided in multiprocessor
     configurations with all entries configured.  The format of this
     table and details regarding its entries can be found in the next
     section.  When using the `rtems/confdefs.h' mechanism for
     configuring an RTEMS application, the value for this field
     corresponds to the setting of the macro
     `CONFIGURE_MP_MPCI_TABLE_POINTER'.  If not defined by the
     application, then the `CONFIGURE_MP_MPCI_TABLE_POINTER' macro
     defaults to the address of the table named `MPCI_table'.



File: ada_user.info,  Node: Configuring a System Multiprocessor Communications Interface Table,  Next: Configuring a System Determining Memory Requirements,  Prev: Configuring a System Multiprocessor Configuration Table,  Up: Configuring a System

23.11 Multiprocessor Communications Interface Table
===================================================

This table defines the set of callouts that must be provided by an
Multiprocessor Communications Interface implementation.

When using the `rtems/confdefs.h' mechanism for configuring an RTEMS
application, the name of this table is assumed to be `MPCI_table'
unless the application sets the `CONFIGURE_MP_MPCI_TABLE_POINTER' when
configuring a multiprocessing system.

The format of this table is defined in the following C structure:

     typedef struct {
       uint32_t                        default_timeout; /* in ticks */
       uint32_t                        maximum_packet_size;
       rtems_mpci_initialization_entry initialization;
       rtems_mpci_get_packet_entry     get_packet;
       rtems_mpci_return_packet_entry  return_packet;
       rtems_mpci_send_entry           send_packet;
       rtems_mpci_receive_entry        receive_packet;
     } rtems_mpci_table;

default_timeout
     is the default maximum length of time a task should block waiting
     for a response to a directive which results in communication with
     a remote node.  The maximum length of time is a function the user
     supplied multiprocessor communications layer and the media used.
     This timeout only applies to directives which would not block if
     the operation were performed locally.

maximum_packet_size
     is the size in bytes of the longest packet which the MPCI layer is
     capable of sending.  This value should represent the total number
     of bytes available for a RTEMS interprocessor messages.

initialization
     is the address of the entry point for the initialization procedure
     of the user supplied multiprocessor communications layer.

get_packet
     is the address of the entry point for the procedure called by
     RTEMS to obtain a packet from the user supplied multiprocessor
     communications layer.

return_packet
     is the address of the entry point for the procedure called by
     RTEMS to return a packet to the user supplied multiprocessor
     communications layer.

send
     is the address of the entry point for the procedure called by
     RTEMS to send an envelope to another node.  This procedure is part
     of the user supplied multiprocessor communications layer.

receive
     is the address of the entry point for the procedure called by
     RTEMS to retrieve an envelope containing a message from another
     node.  This procedure is part of the user supplied multiprocessor
     communications layer.


More information regarding the required functionality of these entry
points is provided in the Multiprocessor chapter.


File: ada_user.info,  Node: Configuring a System Determining Memory Requirements,  Next: Configuring a System Sizing the RTEMS RAM Workspace,  Prev: Configuring a System Multiprocessor Communications Interface Table,  Up: Configuring a System

23.12 Determining Memory Requirements
=====================================

Since memory is a critical resource in many real-time embedded systems,
the RTEMS Classic API was specifically designed to allow unused
managers to be forcibly excluded from the run-time environment.  This
allows the application designer the flexibility to tailor RTEMS to most
efficiently meet system requirements while still satisfying even the
most stringent memory constraints.  As result, the size of the RTEMS
executive is application dependent.

It is not necessary for RTEMS Application Developers to calculate the
amount of memory required for the RTEMS Workspace.  This is done
automatically by `<rtems/confdefs.h>'.  See *note Configuring a System
Sizing the RTEMS RAM Workspace:: for more details on how this works.
In the event, you are interested in the memory required for an instance
of a particular RTEMS object, please run the test `spsize' on your
target board.

RTEMS is built to be a library and any routines that you do not
directly or indirectly require in your application will NOT be included
in your executable image.  However, some managers may be explicitly
excluded and no attempt to create these instances of these objects will
succeed even if they are configured.  The following Classic API
managers may be optionally excluded:

   * signal

   * region

   * dual ported memory

   * event

   * multiprocessing

   * partition

   * timer

   * semaphore

   * message

   * rate monotonic

RTEMS is designed to be built and installed as a library that is linked
into the application.  As such, much of RTEMS is implemented in such a
way that there is a single entry point per source file.  This avoids
having the linker being forced to pull large object files in their
entirety into an application when the application references a single
symbol.  In the event you discover an RTEMS method that is included in
your executable but never entered, please let us know.  It might be an
opportunity to break a dependency and shrink many RTEMS applications.

RTEMS based applications must somehow provide memory for RTEMS' code
and data space.  Although RTEMS' data space must be in RAM, its code
space can be located in either ROM or RAM.  In addition, the user must
allocate RAM for the RTEMS RAM Workspace.  The size of this area is
application dependent and can be calculated using the formula provided
in the Memory Requirements chapter of the Applications Supplement
document for a specific target processor.

All private RTEMS data variables and routine names used by RTEMS begin
with the underscore ( _ ) character followed by an upper-case letter.
If RTEMS is linked with an application, then the application code
should NOT contain any symbols which begin with the underscore
character and followed by an upper-case letter to avoid any naming
conflicts.  All RTEMS directive names should be treated as reserved
words.


File: ada_user.info,  Node: Configuring a System Sizing the RTEMS RAM Workspace,  Next: Multiprocessing Manager,  Prev: Configuring a System Determining Memory Requirements,  Up: Configuring a System

23.13 Sizing the RTEMS RAM Workspace
====================================

The RTEMS RAM Workspace is a user-specified block of memory reserved
for use by RTEMS.  The application should NOT modify this memory.  This
area consists primarily of the RTEMS data structures whose exact size
depends upon the values specified in the Configuration Table.  In
addition, task stacks and floating point context areas are dynamically
allocated from the RTEMS RAM Workspace.

The `rtems/confdefs.h' mechanism calcalutes the size of the RTEMS RAM
Workspace automatically.  It assumes that all tasks are floating point
and that all will be allocated the miminum stack space.  This
calculation also automatically includes the memory that will be
allocated for internal use by RTEMS.  The following macros may be set
by the application to make the calculation of memory required more
accurate:

   * `CONFIGURE_MEMORY_OVERHEAD'

   * `CONFIGURE_EXTRA_TASK_STACKS'


The starting address of the RTEMS RAM Workspace must be aligned on a
four-byte boundary.  Failure to properly align the workspace area will
result in the `rtems.fatal_error_occurred' directive being invoked with
the `RTEMS.INVALID_ADDRESS' error code.

The file `<rtems/confdefs.h>' will calculate the value that is
specified as the `work_space_size' parameter of the Configuration
Table. There are many parameters the application developer can specify
to help `<rtems/confdefs.h>' in its calculations.  Correctly specifying
the application requirements via parameters such as
`CONFIGURE_EXTRA_TASK_STACKS' and `CONFIGURE_MAXIMUM_TASKS' is critical.

The allocation of objects can operate in two modes. The default mode
has an object number ceiling. No more than the specified number of
objects can be allocated from the RTEMS RAM Workspace. The number of
objects specified in the particular API Configuration table fields are
allocated at initialisation. The second mode allows the number of
objects to grow to use the available free memory in the RTEMS RAM
Workspace.

The auto-extending mode can be enabled individually for each object
type by using the macro `rtems_resource_unlimited'. This takes a value
as a parameter, and is used to set the object maximum number field in
an API Configuration table. The value is an allocation unit size. When
RTEMS is required to grow the object table it is grown by this size.
The kernel will return the object memory back to the RTEMS RAM Workspace
when an object is destroyed. The kernel will only return an allocated
block of objects to the RTEMS RAM Workspace if at least half the
allocation size of free objects remain allocated. RTEMS always keeps one
allocation block of objects allocated. Here is an example of using
`rtems_resource_unlimited':

     #define CONFIGURE_MAXIMUM_TASKS rtems_resource_unlimited(5)

The user is cautioned that future versions of RTEMS may not have the
same memory requirements per object. Although the value calculated is
suficient for a particular target processor and release of RTEMS,
memory usage is subject to change across versions and target
processors.  To avoid problems, the user should accurately specify each
configuration parameter and allow `<rtems/confdefs.h>' to calculate the
memory requirements.  The memory requirements are likely to change each
time one of the following events occurs:

   * a configuration parameter is modified,

   * task or interrupt stack requirements change,

   * task floating point attribute is altered,

   * RTEMS is upgraded, or

   * the target processor is changed.

Failure to provide enough space in the RTEMS RAM Workspace will result
in the `rtems.fatal_error_occurred' directive being invoked with the
appropriate error code.


File: ada_user.info,  Node: Multiprocessing Manager,  Next: Multiprocessing Manager Introduction,  Prev: Configuring a System Sizing the RTEMS RAM Workspace,  Up: Top

24 Multiprocessing Manager
**************************

* Menu:

* Multiprocessing Manager Introduction::
* Multiprocessing Manager Background::
* Multiprocessing Manager Multiprocessor Communications Interface Layer::
* Multiprocessing Manager Operations::
* Multiprocessing Manager Directives::


File: ada_user.info,  Node: Multiprocessing Manager Introduction,  Next: Multiprocessing Manager Background,  Prev: Multiprocessing Manager,  Up: Multiprocessing Manager

24.1 Introduction
=================

In multiprocessor real-time systems, new requirements, such as sharing
data and global resources between processors, are introduced.  This
requires an efficient and reliable communications vehicle which allows
all processors to communicate with each other as necessary.  In
addition, the ramifications of multiple processors affect each and every
characteristic of a real-time system, almost always making them more
complicated.

RTEMS addresses these issues by providing simple and flexible real-time
multiprocessing capabilities.  The executive easily lends itself to
both tightly-coupled and loosely-coupled configurations of the target
system hardware.  In addition, RTEMS supports systems composed of both
homogeneous and heterogeneous mixtures of processors and target boards.

A major design goal of the RTEMS executive was to transcend the
physical boundaries of the target hardware configuration.  This goal is
achieved by presenting the application software with a logical view of
the target system where the boundaries between processor nodes are
transparent.  As a result, the application developer may designate
objects such as tasks, queues, events, signals, semaphores, and memory
blocks as global objects.  These global objects may then be accessed by
any task regardless of the physical location of the object and the
accessing task.  RTEMS automatically determines that the object being
accessed resides on another processor and performs the actions required
to access the desired object.  Simply stated, RTEMS allows the entire
system, both hardware and software, to be viewed logically as a single
system.

Multiprocessing operations are transparent at the application level.
Operations on remote objects are implicitly processed as remote
procedure calls.  Although remote operations on objects are supported
from Ada tasks, the calls used to support the multiprocessing
communications should be implemented in C and are not supported in the
Ada binding.  Since there is no Ada binding for RTEMS multiprocessing
support services, all examples and data structures shown in this
chapter are in C.


File: ada_user.info,  Node: Multiprocessing Manager Background,  Next: Multiprocessing Manager Nodes,  Prev: Multiprocessing Manager Introduction,  Up: Multiprocessing Manager

24.2 Background
===============

* Menu:

* Multiprocessing Manager Nodes::
* Multiprocessing Manager Global Objects::
* Multiprocessing Manager Global Object Table::
* Multiprocessing Manager Remote Operations::
* Multiprocessing Manager Proxies::
* Multiprocessing Manager Multiprocessor Configuration Table::

RTEMS makes no assumptions regarding the connection media or topology
of a multiprocessor system.  The tasks which compose a particular
application can be spread among as many processors as needed to satisfy
the application's timing requirements.  The application tasks can
interact using a subset of the RTEMS directives as if they were on the
same processor.  These directives allow application tasks to exchange
data, communicate, and synchronize regardless of which processor they
reside upon.

The RTEMS multiprocessor execution model is multiple instruction
streams with multiple data streams (MIMD).  This execution model has
each of the processors executing code independent of the other
processors.  Because of this parallelism, the application designer can
more easily guarantee deterministic behavior.

By supporting heterogeneous environments, RTEMS allows the systems
designer to select the most efficient processor for each subsystem of
the application.  Configuring RTEMS for a heterogeneous environment is
no more difficult than for a homogeneous one.  In keeping with RTEMS
philosophy of providing transparent physical node boundaries, the
minimal heterogeneous processing required is isolated in the MPCI layer.


File: ada_user.info,  Node: Multiprocessing Manager Nodes,  Next: Multiprocessing Manager Global Objects,  Prev: Multiprocessing Manager Background,  Up: Multiprocessing Manager Background

24.2.1 Nodes
------------

A processor in a RTEMS system is referred to as a node.  Each node is
assigned a unique non-zero node number by the application designer.
RTEMS assumes that node numbers are assigned consecutively from one to
the `maximum_nodes' configuration parameter.  The node number, node,
and the maximum number of nodes, maximum_nodes, in a system are found
in the Multiprocessor Configuration Table.  The maximum_nodes field and
the number of global objects, maximum_global_objects, is required to be
the same on all nodes in a system.

The node number is used by RTEMS to identify each node when performing
remote operations.  Thus, the Multiprocessor Communications Interface
Layer (MPCI) must be able to route messages based on the node number.


File: ada_user.info,  Node: Multiprocessing Manager Global Objects,  Next: Multiprocessing Manager Global Object Table,  Prev: Multiprocessing Manager Nodes,  Up: Multiprocessing Manager Background

24.2.2 Global Objects
---------------------

All RTEMS objects which are created with the GLOBAL attribute will be
known on all other nodes.  Global objects can be referenced from any
node in the system, although certain directive specific restrictions
(e.g. one cannot delete a remote object) may apply.  A task does not
have to be global to perform operations involving remote objects.  The
maximum number of global objects is the system is user configurable and
can be found in the maximum_global_objects field in the Multiprocessor
Configuration Table.  The distribution of tasks to processors is
performed during the application design phase.  Dynamic task relocation
is not supported by RTEMS.


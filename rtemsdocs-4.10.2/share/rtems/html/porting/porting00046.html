<HTML>
<!-- created Dec 13 2011 from taskcontext.texi line 186 via texi2www -->
<BODY BGCOLOR="FFFFFF">
<A HREF="http://www.rtems.com" target="Text Frame">
  <IMG align=right BORDER=0 SRC="../images/rtems_logo.jpg" ALT="RTEMS Logo"> </A>
<H1>RTEMS 4.10.2 On-Line Library</H1>
<HR>
<HEAD>
<TITLE>Task Context Management Initializing a Context</TITLE>
<LINK REL="Precedes" HREF="porting00047.html">
<LINK REV="Precedes" HREF="porting00045.html">
<LINK REV="Subdocument" HREF="porting00040.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="porting00045.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="porting00040.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="porting00047.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Porting Guide</CITE></P>
<H3>6.3.2: Initializing a Context</H3>
<P>
The _CPU_Context_Initialize routine initializes the context to a state
suitable for starting a task after a context restore operation.
Generally, this involves:
</P>
<UL>
<LI>setting a starting address,

<LI>preparing the stack,

<LI>preparing the stack and frame pointers,

<LI>setting the proper interrupt level in the context, and

<LI>initializing the floating point context

</UL>
<P>
This routine generally does not set any unnecessary register in the
context.  The state of the &quot;general data&quot; registers is undefined at task
start time. The _CPU_Context_initialize routine is prototyped as follows:
</P>
<DL><DT><DD>
<PRE>
void _CPU_Context_Initialize(
    Context_Control *_the_context,
    void            *_stack_base,
    unsigned32       _size,
    unsigned32       _isr,
    void            *_entry_point,
    unsigned32       _is_fp
);
</PRE>
</DL>
<P>
The <CODE>is_fp</CODE> parameter is TRUE if the thread is to be a floating point
thread.  This is typically only used on CPUs where the FPU may be easily
disabled by software such as on the SPARC where the PSR contains an enable
FPU bit.  The use of an FPU enable bit allows RTEMS to ensure that a
non-floating point task is unable to access the FPU.  This guarantees that
a deferred floating point context switch is safe.
</P>
<P>
The <CODE>_stack_base</CODE> parameter is the base address of the memory area
allocated for use as the task stack.  It is critical to understand that
<CODE>_stack_base</CODE> may not be the starting stack pointer for this task.
On CPU families where the stack grows from high addresses to lower ones,
(i.e. <CODE>CPU_STACK_GROWS_UP</CODE> is FALSE) the starting stack point
will be near the end of the stack memory area or close to
<CODE>_stack_base</CODE> + <CODE>_size</CODE>.  Even on CPU families where the stack
grows from low to higher addresses, there may be some required
outermost stack frame that must be put at the address <CODE>_stack_base</CODE>.
</P>
<P>
The <CODE>_size</CODE> parameter is the requested size in bytes of the stack for
this task.  It is assumed that the memory area <CODE>_stack_base</CODE>
is of this size.
</P>
<P>
XXX explain other parameters and check prototype
</P>
<P><HR>
<LINK REL="Precedes" HREF="porting00047.html">
<LINK REV="Precedes" HREF="porting00045.html">
<LINK REV="Subdocument" HREF="porting00040.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="porting00045.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="porting00040.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="porting00047.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Porting Guide</CITE></P>
<P>Copyright &copy; 1988-2008 <A HREF="http://www.oarcorp.com" target="Text Frame">OAR Corporation</A>
</BODY></HTML>

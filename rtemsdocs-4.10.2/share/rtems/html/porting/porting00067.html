<HTML>
<!-- created Dec 13 2011 from prioritybitmap.texi line 77 via texi2www -->
<BODY BGCOLOR="FFFFFF">
<A HREF="http://www.rtems.com" target="Text Frame">
  <IMG align=right BORDER=0 SRC="../images/rtems_logo.jpg" ALT="RTEMS Logo"> </A>
<H1>RTEMS 4.10.2 On-Line Library</H1>
<HR>
<HEAD>
<TITLE>Priority Bitmap Manipulation Find First Bit Routine</TITLE>
<LINK REL="Precedes" HREF="porting00068.html">
<LINK REV="Precedes" HREF="porting00066.html">
<LINK REV="Subdocument" HREF="porting00064.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="porting00066.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="porting00064.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="porting00068.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Porting Guide</CITE></P>
<H2>8.3: Find First Bit Routine</H2>
<P>
The _CPU_Bitfield_Find_first_bit routine sets _output to the bit number of
the first bit set in <CODE>_value</CODE>.  <CODE>_value</CODE> is of CPU dependent type
<CODE>Priority_Bit_map_control</CODE>.  A stub version of this routine is as follows:
</P>
<DL><DT><DD>
<PRE>
#define _CPU_Bitfield_Find_first_bit( _value, _output ) \
  { \
    (_output) = 0;   /* do something to prevent warnings */ \
  }
</PRE>
</DL>
<P>
There are a number of variables in using a &quot;find first bit&quot; type
instruction.
</P>
<OL>
<LI>What happens when run on a value of zero?

<LI>Bits may be numbered from MSB to LSB or vice-versa.

<LI>The numbering may be zero or one based.

<LI>The &quot;find first bit&quot; instruction may search from MSB or LSB.

</OL>
<P>
RTEMS guarantees that (1) will never happen so it is not a concern.
Cases (2),(3), (4) are handled by the macros _CPU_Priority_mask() and
_CPU_Priority_bits_index().  These three form a set of routines which must
logically operate together.  Bits in the <CODE>_value</CODE> are set and cleared based
on masks built by CPU_Priority_mask().  The basic major and minor values
calculated by _Priority_Major() and _Priority_Minor() are &quot;massaged&quot; by
_CPU_Priority_bits_index() to properly range between the values returned
by the &quot;find first bit&quot; instruction.  This makes it possible for
_Priority_Get_highest() to calculate the major and directly index into the
minor table.  This mapping is necessary to ensure that 0 (a high priority
major/minor) is the first bit found.
</P>
<P>
This entire &quot;find first bit&quot; and mapping process depends heavily on the
manner in which a priority is broken into a major and minor components
with the major being the 4 MSB of a priority and minor the 4 LSB.  Thus (0
&lt;&lt; 4) + 0 corresponds to priority 0 -- the highest priority.  And (15 &lt;&lt;
4) + 14 corresponds to priority 254 -- the next to the lowest priority.
</P>
<P>
If your CPU does not have a &quot;find first bit&quot; instruction, then there are
ways to make do without it.  Here are a handful of ways to implement this
in software:
</P>
<UL>
<LI>a series of 16 bit test instructions

<LI>a &quot;binary search using if's&quot;

<LI>the following algorithm based upon a 16 entry lookup table.  In this pseudo-code, bit_set_table[16] has values which indicate the first bit set:

<DL><DT><DD>
<PRE>
_number = 0 if _value &gt; 0x00ff
     _value &gt;&gt;=8
     _number = 8;
 if _value &gt; 0x0000f
     _value &gt;=8
     _number += 4

_number += bit_set_table[ _value ]
</PRE>
</DL>
</UL>
<P>
The following illustrates how the CPU_USE_GENERIC_BITFIELD_CODE macro may
be so the port can use the generic implementation of this bitfield code.
This can be used temporarily during the porting process to avoid writing
these routines until the end.  This results in a functional although lower
performance port.  This is perfectly acceptable during development and
testing phases.
</P>
<DL><DT><DD>
<PRE>
#define CPU_USE_GENERIC_BITFIELD_CODE TRUE
#define CPU_USE_GENERIC_BITFIELD_DATA TRUE
</PRE>
</DL>
<P>
Eventually, CPU specific implementations of these routines are usually
written since they dramatically impact the performance of blocking
operations.  However they may take advantage of instructions which are not
available on all models in the CPU family.  In this case, one might find
something like this stub example did:
</P>
<DL><DT><DD>
<PRE>
#if (CPU_USE_GENERIC_BITFIELD_CODE == FALSE)
#define _CPU_Bitfield_Find_first_bit( _value, _output ) \
  { \
    (_output) = 0;   /* do something to prevent warnings */ \
  }
#endif
</PRE>
</DL>
<P><HR>
<LINK REL="Precedes" HREF="porting00068.html">
<LINK REV="Precedes" HREF="porting00066.html">
<LINK REV="Subdocument" HREF="porting00064.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="porting00066.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="porting00064.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="porting00068.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Porting Guide</CITE></P>
<P>Copyright &copy; 1988-2008 <A HREF="http://www.oarcorp.com" target="Text Frame">OAR Corporation</A>
</BODY></HTML>

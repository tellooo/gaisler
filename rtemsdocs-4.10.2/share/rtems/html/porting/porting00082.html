<HTML>
<!-- created Dec 13 2011 from miscellaneous.texi line 95 via texi2www -->
<BODY BGCOLOR="FFFFFF">
<A HREF="http://www.rtems.com" target="Text Frame">
  <IMG align=right BORDER=0 SRC="../images/rtems_logo.jpg" ALT="RTEMS Logo"> </A>
<H1>RTEMS 4.10.2 On-Line Library</H1>
<HR>
<HEAD>
<TITLE>Miscellaneous Endian Swap Unsigned Integers</TITLE>
<LINK REL="Precedes" HREF="porting00083.html">
<LINK REV="Precedes" HREF="porting00081.html">
<LINK REV="Subdocument" HREF="porting00080.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="porting00081.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="porting00080.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="porting00083.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Porting Guide</CITE></P>
<H3>10.2.2: Endian Swap Unsigned Integers</H3>
<P>
The port should provide routines to swap sixteen (<CODE>CPU_swap_u16</CODE>) and
thirty-bit (<CODE>CPU_swap_u32</CODE>) unsigned integers.  These are primarily used in
two areas of RTEMS - multiprocessing support and the network endian swap
routines.  The <CODE>CPU_swap_u32</CODE> routine must be implemented as a static
routine rather than a macro because its address is taken and used
indirectly.  On the other hand, the <CODE>CPU_swap_u16</CODE> routine may be
implemented as a macro.
</P>
<P>
Some CPUs have special instructions that swap a 32-bit quantity in a
single instruction (e.g. i486).  It is probably best to avoid an &quot;endian
swapping control bit&quot; in the CPU.  One good reason is that interrupts
would probably have to be disabled to insure that an interrupt does not
try to access the same &quot;chunk&quot; with the wrong endian.  Another good reason
is that on some CPUs, the endian bit endianness for ALL fetches -- both
code and data -- so the code will be fetched incorrectly.
</P>
<P>
The following is an implementation of the <CODE>CPU_swap_u32</CODE> routine that will
work on any CPU.  It operates by breaking the unsigned thirty-two bit
integer into four byte-wide quantities and reassemblying them.
</P>
<DL><DT><DD>
<PRE>
static inline unsigned int CPU_swap_u32(
  unsigned int value
)
{
  unsigned32 byte1, byte2, byte3, byte4, swapped;

  byte4 = (value &gt;&gt; 24) &amp; 0xff;
  byte3 = (value &gt;&gt; 16) &amp; 0xff;
  byte2 = (value &gt;&gt; 8)  &amp; 0xff;
  byte1 =  value        &amp; 0xff;

  swapped = (byte1 &lt;&lt; 24) | (byte2 &lt;&lt; 16) | (byte3 &lt;&lt; 8) | byte4;
  return( swapped );
}
</PRE>
</DL>
<P>
Although the above implementation is portable, it is not particularly
efficient.  So if there is a better way to implement this on a particular
CPU family or model, please do so.  The efficiency of this routine has
significant impact on the efficiency of the multiprocessing support code
in the shared memory driver and in network applications using the ntohl()
family of routines.
</P>
<P>
Most microprocessor families have rotate instructions which can be used to
greatly improve the <CODE>CPU_swap_u32</CODE> routine.  The most common
way to do this is to:
</P>
<DL><DT><DD>
<PRE>
swap least significant two bytes with 16-bit rotate
swap upper and lower 16-bits
swap most significant two bytes with 16-bit rotate
</PRE>
</DL>
<P>
Some CPUs have special instructions that swap a 32-bit quantity in a
single instruction (e.g. i486).  It is probably best to avoid an &quot;endian
swapping control bit&quot; in the CPU.  One good reason is that interrupts
would probably have to be disabled to insure that an interrupt does not
try to access the same &quot;chunk&quot; with the wrong endian.  Another good reason
is that on some CPUs, the endian bit endianness for ALL fetches -- both
code and data -- so the code will be fetched incorrectly.
</P>
<P>
Similarly, here is a portable implementation of the <CODE>CPU_swap_u16</CODE>
routine.  Just as with the <CODE>CPU_swap_u32</CODE> routine, the porter
should provide a better implementation if possible.
</P>
<DL><DT><DD>
<PRE>
#define CPU_swap_u16( value ) \
  (((value&amp;0xff) &lt;&lt; 8) | ((value &gt;&gt; 8)&amp;0xff))
</PRE>
</DL>
<P><HR>
<LINK REL="Precedes" HREF="porting00083.html">
<LINK REV="Precedes" HREF="porting00081.html">
<LINK REV="Subdocument" HREF="porting00080.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="porting00081.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="porting00080.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="porting00083.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Porting Guide</CITE></P>
<P>Copyright &copy; 1988-2008 <A HREF="http://www.oarcorp.com" target="Text Frame">OAR Corporation</A>
</BODY></HTML>

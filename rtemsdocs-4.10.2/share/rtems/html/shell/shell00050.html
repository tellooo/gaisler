<HTML>
<!-- created Dec 13 2011 from file.texi line 2057 via texi2www -->
<BODY BGCOLOR="FFFFFF">
<A HREF="http://www.rtems.com" target="Text Frame">
  <IMG align=right BORDER=0 SRC="../images/rtems_logo.jpg" ALT="RTEMS Logo"> </A>
<H1>RTEMS 4.10.2 On-Line Library</H1>
<HR>
<HEAD>
<TITLE>File and Directory Commands hexdump - ascii/dec/hex/octal dump</TITLE>
<LINK REL="Precedes" HREF="shell00051.html">
<LINK REV="Precedes" HREF="shell00049.html">
<LINK REV="Subdocument" HREF="shell00031.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="shell00049.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="shell00031.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="shell00051.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Shell User's Guide</CITE></P>
<H3>3.2.19: hexdump - ascii/dec/hex/octal dump</H3>
<H3>SYNOPSYS:</H3>
<DL><DT><DD>
<PRE>
hexdump [-bcCdovx] [-e format_string] [-f format_file] [-n length]
        [-s skip] file ...
</PRE>
</DL>
<H3>DESCRIPTION:</H3>
<P>
The hexdump utility is a filter which displays the specified files, or
the standard input, if no files are specified, in a user specified
format.
</P>
<P>
The options are as follows:
</P>
<DL>
<DT><STRONG>-b</STRONG>
<DD>
One-byte octal display.  Display the input offset in hexadecimal,
followed by sixteen space-separated, three column, zero-filled, bytes
of input data, in octal, per line.

<DT><STRONG>-c</STRONG>
<DD>
One-byte character display.  Display the input offset in hexadecimal,
followed by sixteen space-separated, three column, space-filled,
characters of input data per line.

<DT><STRONG>-C</STRONG>
<DD>
Canonical hex+ASCII display.  Display the input offset in hexadecimal,
followed by sixteen space-separated, two column, hexadecimal bytes,
followed by the same sixteen bytes in %_p format enclosed in ``|''
characters.

<DT><STRONG>-d</STRONG>
<DD>
Two-byte decimal display.  Display the input offset in hexadecimal,
followed by eight space-separated, five column, zero-filled, two-byte
units of input data, in unsigned decimal, per line.

<DT><STRONG>-e format_string</STRONG>
<DD>
Specify a format string to be used for displaying data.

<DT><STRONG>-f format_file</STRONG>
<DD>
Specify a file that contains one or more newline separated format
strings.  Empty lines and lines whose first non-blank character is a
hash mark (#) are ignored.

<DT><STRONG>-n length</STRONG>
<DD>
Interpret only length bytes of input.

<DT><STRONG>-o</STRONG>
<DD>
Two-byte octal display.  Display the input offset in hexadecimal,
followed by eight space-separated, six column, zerofilled, two byte
quantities of input data, in octal, per line.

<DT><STRONG>-s offset</STRONG>
<DD>
Skip offset bytes from the beginning of the input.  By default, offset
is interpreted as a decimal number.  With a leading 0x or 0X, offset
is interpreted as a hexadecimal number, otherwise, with a leading 0,
offset is interpreted as an octal number.  Appending the character b,
k, or m to offset causes it to be interpreted as a multiple of 512,
1024, or 1048576, respectively.

<DT><STRONG>-v</STRONG>
<DD>
The -v option causes hexdump to display all input data.  Without the
-v option, any number of groups of output lines, which would be
identical to the immediately preceding group of output lines (except
for the input offsets), are replaced with a line containing a single
asterisk.

<DT><STRONG>-x</STRONG>
<DD>
Two-byte hexadecimal display.  Display the input offset in
hexadecimal, followed by eight, space separated, four column,
zero-filled, two-byte quantities of input data, in hexadecimal, per
line.
</DL>

<P>
For each input file, hexdump sequentially copies the input to standard
output, transforming the data according to the format strings
specified by the -e and -f options, in the order that they were
specified.
</P>
<P>
<STRONG>Formats</STRONG>
</P>
<P>
A format string contains any number of format units, separated by
whitespace.  A format unit contains up to three items: an iteration
count, a byte count, and a format.
</P>
<P>
The iteration count is an optional positive integer, which defaults to
one.  Each format is applied iteration count times.
</P>
<P>
The byte count is an optional positive integer.  If specified it
defines the number of bytes to be interpreted by each iteration of the
format.
</P>
<P>
If an iteration count and/or a byte count is specified, a single slash
must be placed after the iteration count and/or before the byte count
to disambiguate them.  Any whitespace before or after the slash is
ignored.
</P>
<P>
The format is required and must be surrounded by double quote (`` ``)
marks.  It is interpreted as a fprintf-style format string (see
<EM>fprintf</EM>), with the following exceptions:
</P>
<UL>
<LI>
An asterisk (*) may not be used as a field width or precision.
<LI>
A byte count or field precision is required for each ``s'' con-
version character (unlike the fprintf(3) default which prints the
entire string if the precision is unspecified).
<LI>
The conversion characters ``h'', ``l'', ``n'', ``p'' and ``q'' are not
supported.
<LI>
The single character escape sequences described in the C standard
are supported:

<BLOCKQUOTE>
NUL                  \0
&lt;alert character&gt;    \a
&lt;backspace&gt;          \b
&lt;form-feed&gt;          \f
&lt;newline&gt;            \n
&lt;carriage return&gt;    \r
&lt;tab&gt;                \t
&lt;vertical tab&gt;       \v
</BLOCKQUOTE>
</UL>
<P>
Hexdump also supports the following additional conversion strings:
</P>
<DL>
<DT><STRONG>_a[dox]</STRONG>
<DD>
Display the input offset, cumulative across input files, of the next
byte to be displayed.  The appended characters d, o, and x specify the
display base as decimal, octal or hexadecimal respectively.

<DT><STRONG>_A[dox]</STRONG>
<DD>
Identical to the _a conversion string except that it is only performed
once, when all of the input data has been processed.

<DT><STRONG>_c</STRONG>
<DD>
Output characters in the default character set.  Nonprinting
characters are displayed in three character, zero-padded octal, except
for those representable by standard escape notation (see above), which
are displayed as two character strings.

<DT><STRONG>_p</STRONG>
<DD>
Output characters in the default character set.  Nonprinting
characters are displayed as a single ``.''.

<DT><STRONG>_u</STRONG>
<DD>
Output US ASCII characters, with the exception that control characters
are displayed using the following, lower-case, names.  Characters
greater than 0xff, hexadecimal, are displayed as hexadecimal
strings.

<P>
000 nul  001 soh  002 stx  003 etx  004 eot  005 enq
006 ack  007 bel  008 bs   009 ht   00A lf   00B vt
00C ff   00D cr   00E so   00F si   010 dle  011 dc1
012 dc2  013 dc3  014 dc4  015 nak  016 syn  017 etb
018 can  019 em   01A sub  01B esc  01C fs   01D gs
01E rs   01F us   07F del
</DL>
</P>
<P>
The default and supported byte counts for the conversion characters
are as follows:
</P>
<BLOCKQUOTE>
%_c, %_p, %_u, %c       One byte counts only.

%d, %i, %o, %u, %X, %x  Four byte default, one, two, four
                        and eight byte counts supported.

%E, %e, %f, %G, %g      Eight byte default, four byte
                        counts supported.
</BLOCKQUOTE>
<P>
The amount of data interpreted by each format string is the sum of the
data required by each format unit, which is the iteration count times
the byte count, or the iteration count times the number of bytes
required by the format if the byte count is not specified.
</P>
<P>
The input is manipulated in ``blocks'', where a block is defined as
the largest amount of data specified by any format string.  Format
strings interpreting less than an input block's worth of data, whose
last format unit both interprets some number of bytes and does not
have a specified iteration count, have the iteration count incremented
until the entire input block has been processed or there is not enough
data remaining in the block to satisfy the format string.
</P>
<P>
If, either as a result of user specification or hexdump modifying the
iteration count as described above, an iteration count is greater than
one, no trailing whitespace characters are output during the last
iteration.
</P>
<P>
It is an error to specify a byte count as well as multiple conversion
characters or strings unless all but one of the conversion characters
or strings is _a or _A.
</P>
<P>
If, as a result of the specification of the -n option or end-of-file
being reached, input data only partially satisfies a format string,
the input block is zero-padded sufficiently to display all available
data (i.e. any format units overlapping the end of data will display
some num- ber of the zero bytes).
</P>
<P>
Further output by such format strings is replaced by an equivalent
number of spaces.  An equivalent number of spaces is defined as the
number of spaces output by an s conversion character with the same
field width and precision as the original conversion character or
conversion string but with any ``+'', `` '', ``#'' conversion flag
characters removed, and ref- erencing a NULL string.
</P>
<P>
If no format strings are specified, the default display is equivalent
to specifying the -x option.
</P>
<H3>EXIT STATUS:</H3>
<P>
This command returns 0 on success and non-zero if an error is encountered.
</P>
<H3>NOTES:</H3>
<P>
NONE
</P>
<H3>EXAMPLES:</H3>
<P>
The following is an example of how to use <CODE>hexdump</CODE>:
</P>
<DL><DT><DD>
<PRE>
SHLL [/] $ hexdump -C -n 512 /dev/hda1
</PRE>
</DL>
<H3>CONFIGURATION:</H3>
<P>
This command is included in the default shell command set.  When
building a custom command set, define
<CODE>CONFIGURE_SHELL_COMMAND_HEXDUMP</CODE> to have this command included.
</P>
<P>
This command can be excluded from the shell command set by defining
<CODE>CONFIGURE_SHELL_NO_COMMAND_HEXDUMP</CODE> when all shell commands have
been configured.
</P>
<H3>PROGRAMMING INFORMATION:</H3>
<P>
The <CODE>hexdump</CODE> command is implemented by a C language function
which has the following prototype:
</P>
<DL><DT><DD>
<PRE>
int rtems_shell_rtems_main_hexdump(
  int    argc,
  char **argv
);
</PRE>
</DL>
<P>
The configuration structure for the <CODE>hexdump</CODE> has the following
prototype:
</P>
<DL><DT><DD>
<PRE>
extern rtems_shell_cmd_t rtems_shell_HEXDUMP_Command;
</PRE>
</DL>
<P><HR>
<LINK REL="Precedes" HREF="shell00051.html">
<LINK REV="Precedes" HREF="shell00049.html">
<LINK REV="Subdocument" HREF="shell00031.html">
<LINK REV="Library" HREF="../index.html">
</HEAD><BODY><P>
<A HREF="shell00049.html"><IMG ALIGN=MIDDLE SRC="../images/prev-arrow.gif" ALT="PREV"></A>
<A HREF="shell00031.html"> <IMG ALIGN=MIDDLE SRC="../images/up-arrow.gif" ALT="UP"></A>
<A HREF="shell00051.html"><IMG ALIGN=MIDDLE SRC="../images/next-arrow.gif" ALT="NEXT"></A>
<A HREF="../index.html"> <IMG ALIGN=MIDDLE SRC="../images/dir-arrow.gif" ALT="Bookshelf"></A>
<CITE>RTEMS Shell User's Guide</CITE></P>
<P>Copyright &copy; 1988-2008 <A HREF="http://www.oarcorp.com" target="Text Frame">OAR Corporation</A>
</BODY></HTML>

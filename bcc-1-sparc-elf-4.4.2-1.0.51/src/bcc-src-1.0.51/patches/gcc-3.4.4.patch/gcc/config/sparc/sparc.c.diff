--- gcc-3.4.4.old/./gcc/config/sparc/sparc.c	2020-02-28 17:30:18.296572661 +0100
+++ gcc-3.4.4.new/./gcc/config/sparc/sparc.c	2017-11-17 15:20:11.598240000 +0100
@@ -74,6 +74,11 @@
    saved (as 4-byte quantities).  */
 static int num_gfregs;
 
+/* disable flag_delayed_branch in toplev. Call dbr_schedule in reorg */
+static int sparc_flag_delayed_branch = 0;
+/* diable delay schedule of load instructions */
+int sparc_fix_load_in_delay = 0;
+
 /* Save the operands last given to a compare for use when we
    generate a scc or bcc insn.  */
 rtx sparc_compare_op0, sparc_compare_op1;
@@ -133,6 +138,7 @@
 static const char *frame_base_name;
 static HOST_WIDE_INT frame_base_offset;
 
+static int sparc_reorg_nullify (void);
 static void sparc_init_modes (void);
 static int save_regs (FILE *, int, int, const char *, int, int, HOST_WIDE_INT);
 static int restore_regs (FILE *, int, int, const char *, int, int);
@@ -196,6 +202,8 @@
 static const char *get_some_local_dynamic_name (void);
 static int get_some_local_dynamic_name_1 (rtx *, void *);
 static bool sparc_rtx_costs (rtx, int, int, int *);
+static void sparc_reorg (void);
+
 
 /* Option handling.  */
 
@@ -274,6 +282,9 @@
 #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
 #define TARGET_ASM_CAN_OUTPUT_MI_THUNK sparc_can_output_mi_thunk
 
+#undef TARGET_MACHINE_DEPENDENT_REORG
+#define TARGET_MACHINE_DEPENDENT_REORG sparc_reorg
+
 #undef TARGET_RTX_COSTS
 #define TARGET_RTX_COSTS sparc_rtx_costs
 #undef TARGET_ADDRESS_COST
@@ -309,6 +320,7 @@
     { TARGET_CPU_sparclet, "tsc701" },
     { TARGET_CPU_sparclite, "f930" },
     { TARGET_CPU_v8, "v8" },
+    { TARGET_CPU_leon, "leon" },
     { TARGET_CPU_hypersparc, "hypersparc" },
     { TARGET_CPU_sparclite86x, "sparclite86x" },
     { TARGET_CPU_supersparc, "supersparc" },
@@ -350,6 +362,9 @@
     /* TI ultrasparc III */
     /* ??? Check if %y issue still holds true in ultra3.  */
     { "ultrasparc3", PROCESSOR_ULTRASPARC3, MASK_ISA, MASK_V9|MASK_DEPRECATED_V8_INSNS},
+    /* sparc-leon */
+    { "leon",        PROCESSOR_LEON, (MASK_ISA & (~MASK_V8)), 0 },
+    { "ut699",       PROCESSOR_LEON, (MASK_ISA), MASK_V8|MASK_FPU },
     { 0, 0, 0, 0 }
   };
   const struct cpu_table *cpu;
@@ -404,6 +419,9 @@
     abort ();
   sparc_select[0].string = def->name;
 
+  /* enable always fsmuld suppression */ 
+  flag_fno_fsmuld = 1;
+  
   for (sel = &sparc_select[0]; sel->name; ++sel)
     {
       if (sel->string)
@@ -411,6 +429,18 @@
 	  for (cpu = &cpu_table[0]; cpu->name; ++cpu)
 	    if (! strcmp (sel->string, cpu->name))
 	      {
+		if (! strcmp (sel->string, "ut699")) {
+		  if (debug_patch_divsqrt) {
+		    fprintf(stderr, "ut699: enable -fstore-after-divsqrt -fno-fsmuld -fno-sf-divsqrt\n");
+		  }
+		  flag_fstore_after_divsqrt = 1;
+		  flag_fno_sf_divsqrt = 1;
+		  flag_fno_fsmuld = 1;
+		  sparc_fix_ut699 = 1;
+		  sparc_fix_b2bst = 1;
+                  sparc_fix_tn0013 = 1;
+		} else {
+		
 		if (sel->set_tune_p)
 		  sparc_cpu = cpu->processor;
 
@@ -419,6 +449,7 @@
 		    target_flags &= ~cpu->disable;
 		    target_flags |= cpu->enable;
 		  }
+		}
 		break;
 	      }
 
@@ -427,6 +458,29 @@
 	}
     }
 
+  if (sparc_fix_ut699) 
+    {
+      sparc_fix_load_in_delay = 1;
+      sparc_flag_delayed_branch = flag_delayed_branch;
+      flag_delayed_branch = 0;
+      fpstore_errata = 1;
+    }
+
+  if (sparc_fix_gr712rc || sparc_fix_ut700)
+    {
+      sparc_fix_b2bst = 1;
+      sparc_fix_tn0013 = 1;
+    }
+
+  if (sparc_fix_b2bst || sparc_fix_tn0013)
+    {
+      sparc_flag_delayed_branch = 0;
+      flag_delayed_branch = 0;
+    }
+
+  /*printf("-- flags: %x MASK_ISA %x MASK_V8 %x\n",target_flags,MASK_ISA, MASK_V8); */
+  
+  
   /* If -mfpu or -mno-fpu was explicitly used, don't override with
      the processor default.  Clear MASK_FPU_SET to avoid confusing
      the reverse mapping from switch values to names.  */
@@ -4410,7 +4464,7 @@
   fprintf (file, "\t%s#PROLOGUE# 0\n", ASM_COMMENT_START);
 
   if (actual_fsize == 0)
-    /* do nothing.  */ ;
+    /* do nothing.  */ ; 
   else if (! leaf_function)
     {
       if (actual_fsize <= 4096)
@@ -7753,6 +7807,8 @@
 			  dwarf2out_reg_save
 			    (l, regno+1, offset+base_offset + UNITS_PER_WORD);
 			}
+		      if (sparc_fix_b2bst)
+		      fprintf (file, "\tnop\n");
 		    }
 		  else
 		    fprintf (file, "\t%s\t[%s+%d], %s\n",
@@ -7874,8 +7930,8 @@
 		       sp_str, size, sp_str);
 	      if (gmask & HARD_FRAME_POINTER_MASK)
 		{
-		  fprintf (file, "\tst\t%s, [%s+%d]\n",
-			   fp_str, sp_str, reg_offset);
+		  fprintf (file, "\tst\t%s, [%s+%d]\n%s",
+			   fp_str, sp_str, reg_offset, sparc_fix_b2bst ? "\tnop\n" : "");
 		  fprintf (file, "\tsub\t%s, -"HOST_WIDE_INT_PRINT_DEC", %s"
 		  		 "\t%s# set up frame pointer\n",
 			   sp_str, size, fp_str, ASM_COMMENT_START);
@@ -7888,8 +7944,8 @@
 	      fprintf (file, "\tsub\t%s, %s, %s\n", sp_str, t1_str, sp_str);
 	      if (gmask & HARD_FRAME_POINTER_MASK)
 		{
-		  fprintf (file, "\tst\t%s, [%s+%d]\n",
-			   fp_str, sp_str, reg_offset);
+		  fprintf (file, "\tst\t%s, [%s+%d]\n%s",
+			   fp_str, sp_str, reg_offset, sparc_fix_b2bst ? "\tnop\n" : "");
 		  fprintf (file, "\tadd\t%s, %s, %s\t%s# set up frame pointer\n",
 			   sp_str, t1_str, fp_str, ASM_COMMENT_START);
 		  reg_offset += 4;
@@ -7940,10 +7996,11 @@
 		       sp_str, size1, sp_str);
 	      if (gmask & HARD_FRAME_POINTER_MASK)
 		{
-		  fprintf (file, "\tst\t%s, [%s+%d]\n"
+		  fprintf (file, "\tst\t%s, [%s+%d]\n%s"
 				 "\tsub\t%s, -"HOST_WIDE_INT_PRINT_DEC", %s"
 				 "\t%s# set up frame pointer\n",
-			   fp_str, sp_str, offset, sp_str, size1,
+			   fp_str, sp_str, offset, sparc_fix_b2bst ? "\tnop\n" : "",
+			   sp_str, size1,
 			   fp_str, ASM_COMMENT_START);
 		  offset += 4;
 		}
@@ -7954,9 +8011,10 @@
 	      fprintf (file, "\tsub\t%s, %s, %s\n", sp_str, t1_str, sp_str);
 	      if (gmask & HARD_FRAME_POINTER_MASK)
 		{
-		  fprintf (file, "\tst\t%s, [%s+%d]\n"
+		  fprintf (file, "\tst\t%s, [%s+%d]\n%s"
 				 "\tadd\t%s, %s, %s\t%s# set up frame pointer\n",
-			   fp_str, sp_str, offset, sp_str, t1_str,
+			   fp_str, sp_str, offset, sparc_fix_b2bst ? "\tnop\n" : "",
+			   sp_str, t1_str,
 			   fp_str, ASM_COMMENT_START);
 		  offset += 4;
 		}
@@ -8001,6 +8059,7 @@
 	}
     }
 
+  fprintf (file, "\tnop\n\tnop\n");
   fprintf (file, "\t%s#PROLOGUE# 1\n", ASM_COMMENT_START);
 }
 
@@ -8941,6 +9000,10 @@
 	      *total = COSTS_N_INSNS (5);
 	      return true;
 
+	    case PROCESSOR_LEON:
+	      *total = COSTS_N_INSNS (1);
+	      return true;
+
 	    case PROCESSOR_HYPERSPARC:
 	    case PROCESSOR_SPARCLITE86X:
 	    default:
@@ -8977,6 +9040,10 @@
 	  *total = COSTS_N_INSNS (63);
 	  return true;
 
+	case PROCESSOR_LEON:
+	  *total = COSTS_N_INSNS (23);
+	  return true;
+
 	case PROCESSOR_HYPERSPARC:
 	case PROCESSOR_SPARCLITE86X:
 	  *total = COSTS_N_INSNS (17);
@@ -9005,6 +9072,10 @@
 	      *total = COSTS_N_INSNS (5);
 	      return true;
 
+	    case PROCESSOR_LEON:
+	      *total = COSTS_N_INSNS (1);
+	      return true;
+
 	    case PROCESSOR_HYPERSPARC:
 	    case PROCESSOR_SPARCLITE86X:
 	    default:
@@ -9037,6 +9108,10 @@
 	    case PROCESSOR_CYPRESS:
 	      *total = COSTS_N_INSNS (7);
 	      return true;
+	      
+	    case PROCESSOR_LEON:
+	      *total = COSTS_N_INSNS (1);
+	      return true;
 
 	    case PROCESSOR_HYPERSPARC:
 	    case PROCESSOR_SPARCLITE86X:
@@ -9134,6 +9209,13 @@
 		*total = COSTS_N_INSNS (9);
 	      return true;
 
+	    case PROCESSOR_LEON:
+	      if (GET_MODE (x) == SFmode)
+		*total = COSTS_N_INSNS (15);
+	      else
+		*total = COSTS_N_INSNS (15);
+	      return true;
+	      
 	    case PROCESSOR_HYPERSPARC:
 	    case PROCESSOR_SPARCLITE86X:
 	      if (GET_MODE (x) == SFmode)
@@ -9154,6 +9236,9 @@
       else if (sparc_cpu == PROCESSOR_ULTRASPARC3)
 	*total = (GET_MODE (x) == DImode
 		  ? COSTS_N_INSNS (71) : COSTS_N_INSNS (40));
+      else if (sparc_cpu == PROCESSOR_LEON)
+	*total = (GET_MODE (x) == DImode
+		  ? COSTS_N_INSNS (5) : COSTS_N_INSNS (5));
       else
 	*total = COSTS_N_INSNS (25);
       return true;
@@ -9234,6 +9319,14 @@
 	    *total = COSTS_N_INSNS (2);
 	  return true;
 	  
+	case PROCESSOR_LEON:
+	  if (outer_code == ZERO_EXTEND
+	      || outer_code == SIGN_EXTEND)
+	    *total = COSTS_N_INSNS (2);
+	  else
+	    *total = COSTS_N_INSNS (3);
+	  return true;
+	  
 	case PROCESSOR_HYPERSPARC:
 	case PROCESSOR_SPARCLITE86X:
 	default:
@@ -9482,4 +9575,913 @@
   fputs (")", file);
 }
 
+/**************************** handle fdivd ****************************/
+char *
+output_divdf3 (rtx op0, rtx op1, rtx dest, rtx scratch)
+{
+  static char string[128];
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "debug_patch_divsqrt:\n");
+    debug_rtx(op0);
+    debug_rtx(op1);
+    debug_rtx(dest);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+  sprintf(string,"fdivd\t%%1, %%2, %%0; st %%0, %%3 !!!");
+  return string;
+}
+
+void
+output_divdf3_emit (rtx dest, rtx op0, rtx op1, rtx scratch)
+{
+  rtx slot0, div, divsave;
+  
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "output_divdf3_emit:\n");
+    debug_rtx(op0);
+    debug_rtx(op1);
+    debug_rtx(dest);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+	
+  div = gen_rtx_SET (VOIDmode,
+		     dest,
+		     gen_rtx_DIV (DFmode,
+				  op0,
+				  op1));
+  
+  if (TARGET_STORE_AFTER_DIVSQRT) {
+    slot0 = assign_stack_local (DFmode, 8, 8);
+    divsave = gen_rtx_SET (VOIDmode, slot0, dest);
+    emit_insn(divsave);
+    emit_insn (gen_rtx_PARALLEL(VOIDmode,
+				gen_rtvec (2,
+					   div,
+					   gen_rtx_CLOBBER (SImode,
+							    slot0))));
+  } else {
+    emit_insn(div);
+  }
+}
+
+/**************************** handle fdivs ****************************/
+char *
+output_divsf3 (rtx op0, rtx op1, rtx dest, rtx scratch)
+{
+  static char string[128];
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "debug_patch_divsqrt:\n");
+    debug_rtx(op0);
+    debug_rtx(op1);
+    debug_rtx(dest);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+  sprintf(string,"fdivs\t%%1, %%2, %%0; st %%0, %%3 !!!");
+  return string;
+}
+
+void
+output_divsf3_emit (rtx dest, rtx op0, rtx op1, rtx scratch)
+{
+  rtx slot0, div, divsave;
+  
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "output_divsf3_emit:\n");
+    debug_rtx(op0);
+    debug_rtx(op1);
+    debug_rtx(dest);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+  
+  div = gen_rtx_SET (VOIDmode,
+		     dest,
+		     gen_rtx_DIV (SFmode,
+				  op0,
+				  op1));
+  
+  if (TARGET_STORE_AFTER_DIVSQRT) {
+    slot0 = assign_stack_local (SFmode, 4, 4);
+    divsave = gen_rtx_SET (VOIDmode, slot0, dest);
+    emit_insn(divsave);
+    emit_insn (gen_rtx_PARALLEL(VOIDmode,
+				gen_rtvec (2,
+					   div,
+					   gen_rtx_CLOBBER (SImode,
+							    slot0))));
+  } else {
+    emit_insn(div);
+  }
+}
+
+/**************************** handle sqrtdf2 ****************************/
+
+char *
+output_sqrtdf2 (rtx dest, rtx op0, rtx scratch)
+{
+  static char string[50];
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "output_sqrtdf2:\n");
+    debug_rtx(dest);
+    debug_rtx(op0);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+  sprintf(string,"fsqrtd\t%%1, %%0; st %%0, %%2 !!!");
+  return string;
+}
+
+
+void
+output_sqrtdf2_emit (rtx dest, rtx op0, rtx scratch)
+{
+  rtx slot0, sqrt, sqrtsave;
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "output_sqrtdf2_emit:\n");
+    debug_rtx(dest);
+    debug_rtx(op0);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+  
+  sqrt = gen_rtx_SET (VOIDmode,
+		     dest,
+		     gen_rtx_SQRT (DFmode,
+				  op0));
+  
+  if (TARGET_STORE_AFTER_DIVSQRT) {
+    slot0 = assign_stack_local (DFmode, 8, 8);
+    sqrtsave = gen_rtx_SET (VOIDmode, slot0, dest);
+    emit_insn(sqrtsave);
+    emit_insn (gen_rtx_PARALLEL(VOIDmode,
+				gen_rtvec (2,
+					   sqrt,
+					   gen_rtx_CLOBBER (SImode,
+							    slot0))));
+  } else {
+    emit_insn(sqrt);
+  }
+	
+}
+
+/**************************** handle sqrtsf2 ****************************/
+
+char *
+output_sqrtsf2 (rtx dest, rtx op0, rtx scratch)
+{
+  static char string[50];
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "output_sqrtsf2:\n");
+    debug_rtx(dest);
+    debug_rtx(op0);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+  sprintf(string,"fsqrts\t%%1, %%0; st %%0, %%2 !!!");
+  return string;
+}
+
+void
+output_sqrtsf2_emit (rtx dest, rtx op0, rtx scratch)
+{
+  rtx slot0, sqrt, sqrtsave;
+  if (debug_patch_divsqrt) {
+    fprintf(stderr, "output_sqrtsf2_emit:\n");
+    debug_rtx(dest);
+    debug_rtx(op0);
+    fprintf(stderr, "scratch: 0x%x\n",(int)scratch);
+  }
+  
+  sqrt = gen_rtx_SET (VOIDmode,
+		     dest,
+		     gen_rtx_SQRT (SFmode,
+				  op0));
+  
+  if (TARGET_STORE_AFTER_DIVSQRT) {
+    slot0 = assign_stack_local (SFmode, 4, 4);
+    sqrtsave = gen_rtx_SET (VOIDmode, slot0, dest);
+    emit_insn(sqrtsave);
+    emit_insn (gen_rtx_PARALLEL(VOIDmode,
+				gen_rtvec (2,
+					   sqrt,
+					   gen_rtx_CLOBBER (SImode,
+							    slot0))));
+  } else {
+    emit_insn(sqrt);
+  }
+
+}
+
+static int sparc_sload_p(rtx insn, int isload)
+{
+  enum attr_type insn_type;
+  rtx set;
+  if ( insn
+       && (GET_CODE (insn) == INSN)
+       && (set = single_set (insn)) != NULL_RTX) 
+    {
+      if (recog_memoized (insn)) 
+	{
+	  insn_type = get_attr_type (insn);
+	  switch(insn_type) {
+	  case TYPE_LOAD:
+	  case TYPE_SLOAD:
+	  case TYPE_FPLOAD:
+	    return isload;
+	  case TYPE_STORE:
+	  case TYPE_FPSTORE:
+	    return !isload;
+	  default:;
+	  }
+	}
+    }
+  return 0;
+}
+
+static int
+fpop_reg_depend_p (rtx insn, unsigned int reg)
+{
+  extract_insn (insn);
+  return (REGNO (recog_data.operand[1]) == reg
+	  || (recog_data.n_operands == 3
+	      && REGNO (recog_data.operand[2]) == reg));
+}
+
+static int
+div_sqrt_insn_p (rtx insn)
+{
+  if ( GET_CODE (PATTERN (insn)) != SET)
+    return false;
+
+  switch (get_attr_type (insn))
+    {
+    case TYPE_FPDIVS:
+    case TYPE_FPSQRTS:
+    case TYPE_FPDIVD:
+    case TYPE_FPSQRTD:
+      return true;
+    default:
+      return false;
+    }
+}
+
+static int
+fpop_insn_p (rtx insn)
+{
+  if ( GET_CODE (PATTERN (insn)) != SET)
+    return false;
+
+  switch (get_attr_type (insn))
+    {
+    case TYPE_FPMOVE:
+    case TYPE_FPCMOVE:
+    case TYPE_FP:
+    case TYPE_FPCMP:
+    case TYPE_FPMUL:
+    case TYPE_FPDIVS:
+    case TYPE_FPSQRTS:
+    case TYPE_FPDIVD:
+    case TYPE_FPSQRTD:
+      return true;
+    default:
+      return false;
+    }
+}
+
+/* True if INSN is a md pattern or asm statement.  */
+#define USEFUL_INSN_P(INSN)						\
+   (GET_CODE (PATTERN (INSN)) != USE					\
+   && GET_CODE (PATTERN (INSN)) != CLOBBER)
+
+#define NONJUMP_INSN_P(X) (GET_CODE (X) == INSN)
+#define MEM_P(X) (GET_CODE (X) == MEM)
+
+static void
+sparc_reorg_b2bst(void)
+{
+  rtx insn, next;
+
+  /* Force all instructions to be split into their final form.  */
+  split_all_insns_noflow ();
+
+  /* Now look for specific patterns in the insn stream.  */
+  for (insn = get_insns (); insn; insn = next)
+    {
+      bool insert_nop = false;
+      rtx set;
+      rtx jump = 0;
+
+      /* Look into the instruction in a delay slot.  */
+      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE) {
+	jump = XVECEXP (PATTERN (insn), 0, 0);
+	insn = XVECEXP (PATTERN (insn), 0, 1);
+      }
+
+      if (sparc_fix_gr712rc
+	  && (JUMP_P (insn) || jump)
+	  && JUMP_LABEL(jump ? jump : insn) != 0
+	  && get_attr_branch_type (jump ? jump : insn) == BRANCH_TYPE_ICC)
+	{
+	rtx target;
+
+	target = next_active_insn (JUMP_LABEL(jump ? jump : insn));
+	if (target
+	    && (fpop_insn_p (target)
+	    || ((JUMP_P (target)
+		 && get_attr_branch_type (target) == BRANCH_TYPE_FCC))))
+	  emit_insn_before (gen_nop (), target);
+      }
+
+	/* TN-0013 */
+	if (sparc_fix_tn0013
+	  && NONJUMP_INSN_P (insn)
+	  && div_sqrt_insn_p(insn))
+	{
+	  int i;
+	  int fp_found = 0;
+	  unsigned int dest_reg;
+	  rtx after;
+
+	  dest_reg = REGNO (SET_DEST (single_set (insn)));
+
+	  next = next_active_insn (insn);
+	  if (!next)
+	    break;
+
+	  for (after = next, i = 0; i < 4; i++)
+	    {
+	      if (i != 3
+		  && fpop_insn_p (after))
+		{
+		  if (fpop_reg_depend_p (after, dest_reg))
+		    break;
+		  fp_found++;
+		}
+
+	      if (i != 3
+		  && (set = single_set (after)) != NULL_RTX
+		  && REG_P (SET_DEST (set))
+		  && REGNO (SET_DEST (set)) > 31)
+		{
+		  if (REGNO (SET_DEST (set)) == dest_reg)
+		    break;
+		  fp_found++;
+		}
+
+	      if (i > 1
+		  && fp_found >= 2
+		  && div_sqrt_insn_p(after))
+		{
+		  if (i == 2)
+		    emit_insn_before (gen_nop (), next);
+		  insert_nop = true;
+		  break;
+		}
+
+	      if (div_sqrt_insn_p (after))
+		break;
+	      
+	      if (i < 3
+		  && (!NONJUMP_INSN_P (after)
+		      || GET_CODE (PATTERN (after)) == SEQUENCE))
+		{
+		  insert_nop = true;
+		  break;
+		}
+
+	      after = next_active_insn (after);
+	      if (!after)
+		break;
+	    }
+	}
+
+      /* Look for a double-word store */
+      if (sparc_fix_b2bst
+	  && NONJUMP_INSN_P (insn)
+	  && (set = single_set (insn)) != NULL_RTX
+	  && GET_MODE_SIZE (GET_MODE (SET_DEST (set))) == 8
+	  && MEM_P (SET_DEST (set)))
+	{
+	  next = next_active_insn (insn);
+	  if (!next)
+	    break;
+
+	  /* Skip empty assembly statements */
+	  if ((GET_CODE(PATTERN(next)) == ASM_INPUT) ||
+	      (USEFUL_INSN_P (next) &&
+	      (asm_noperands (PATTERN (next))>=0) &&
+	      !strcmp(decode_asm_operands (PATTERN (next), NULL,
+					   NULL, NULL,
+					   NULL), "")))
+	    next = next_active_insn (next);
+	  if (!next)
+	    break;
+
+	  /* If the insn is a branch, then it cannot be problematic.  */
+	  if (!NONJUMP_INSN_P (next) || GET_CODE (PATTERN (next)) == SEQUENCE)
+	    continue;
+
+	  if ((set = single_set (next)) == NULL_RTX)
+	    continue;
+
+	  /* Add NOP if double-word store is followed by any type of store */
+	  if (MEM_P (SET_DEST (set)))
+	    insert_nop = true;
+	}
+      else
+      /* Look for single-word, half-word, or byte store */
+      if (sparc_fix_b2bst
+	  && NONJUMP_INSN_P (insn)
+	  && (set = single_set (insn)) != NULL_RTX
+	  && GET_MODE_SIZE (GET_MODE (SET_DEST (set))) <= 4
+	  && MEM_P (SET_DEST (set)))
+	{
+	  rtx after;
+
+	  next = next_active_insn (insn);
+	  if (!next)
+	    break;
+
+	  /* Skip empty assembly statements */
+	  if ((GET_CODE(PATTERN(next)) == ASM_INPUT) ||
+	      (USEFUL_INSN_P (next) &&
+	      (asm_noperands (PATTERN (next))>=0) &&
+	      !strcmp(decode_asm_operands (PATTERN (next), NULL,
+					   NULL, NULL,
+					   NULL), "")))
+	    next = next_active_insn (next);
+	  if (!next)
+	    break;
+
+	  /* If the insn is a branch, then it cannot be problematic.  */
+	  if (!NONJUMP_INSN_P (next) || GET_CODE (PATTERN (next)) == SEQUENCE)
+	    continue;
+
+	  /* If the insn is a load or store, then it cannot be problematic. */
+	  if ((set = single_set (next)) != NULL_RTX
+	      && (MEM_P (SET_DEST (set)) || MEM_P (SET_SRC (set))))
+	    continue;
+
+	  after = next_active_insn (next);
+	  if (!after)
+	    continue;
+
+	  /* Skip empty assembly statements */
+	  if ((GET_CODE(PATTERN(after)) == ASM_INPUT) ||
+	      (USEFUL_INSN_P (after) &&
+	      (asm_noperands (PATTERN (after))>=0) &&
+	      !strcmp(decode_asm_operands (PATTERN (after), NULL,
+					   NULL, NULL,
+					   NULL), "")))
+	    after = next_active_insn (after);
+	  if (!after)
+	    break;
+
+	  /* If the insn is a branch, then it cannot be problematic.  */
+	  if (!NONJUMP_INSN_P (after) || GET_CODE (PATTERN (after)) == SEQUENCE)
+	    continue;
+
+	  /* Add NOP if third instruction is a store */
+	  if (((set = single_set (after)) != NULL_RTX)
+	      && MEM_P (SET_DEST (set)))
+	    insert_nop = true;
+	}
+      else
+	next = NEXT_INSN (insn);
+
+      if (insert_nop)
+	emit_insn_before (gen_nop (), next);
+    }
+
+  return 0;
+}
+
+static void sparc_reorg (void)
+{
+  rtx insn, next, cstore;
+  if (!sparc_fix_ut699 && !sparc_fix_b2bst && !sparc_fix_gr712rc
+      && !sparc_fix_tn0013)
+    return;
+  
+  if (sparc_flag_delayed_branch) 
+    {
+      /* cannot use dbr_schedule() */
+      dbr_schedule (get_insns (), rtl_dump_file);
+    }
+
+  if (sparc_fix_b2bst || sparc_fix_gr712rc || sparc_fix_tn0013) {
+    sparc_reorg_b2bst();
+  }
+
+  if (!sparc_fix_ut699)
+    return;
+
+  if (!flag_fnullify_allnop) {
+    sparc_reorg_nullify ();
+    return;
+  } 
+
+  for (insn = get_insns (); insn; insn = next)
+    {
+      bool insert_nop = 0;
+      next = NEXT_INSN (insn);
+      cstore = next_active_insn (insn);
+      if (sparc_sload_p(insn, 1) && 
+	  (sparc_sload_p(cstore, 0) ||
+	   (/*sparc_fix_socc3 &&*/ sparc_sload_p(cstore, 1))))
+	{
+	  emit_insn_after (gen_nop (), insn);
+	}
+    }
+}
+
+#define NONJUMP_INSN_P(X) (GET_CODE (X) == INSN)
+#define MEM_P(X) (GET_CODE (X) == MEM)
+#define CALL_P(X) (GET_CODE (X) == CALL_INSN)
+
+/* Return the memory reference contained in X if any, zero otherwise.  */
+
+static rtx
+mem_ref (rtx x)
+{
+  if (GET_CODE (x) == SIGN_EXTEND || GET_CODE (x) == ZERO_EXTEND)
+    x = XEXP (x, 0);
+
+  if (MEM_P (x))
+    return x;
+
+  return NULL_RTX;
+}
+
+static int sparc_reorg_nullify (void)
+{
+  rtx insn, next;
+
+  /* Now look for specific patterns in the insn stream.  */
+  for (insn = get_insns (); insn; insn = next)
+    {
+      bool insert_nop = false;
+      rtx set;
+
+      /* Look into the instruction in a delay slot.  */
+      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)
+	insn = XVECEXP (PATTERN (insn), 0, 1);
+
+      if (NONJUMP_INSN_P (insn)
+	  && (set = single_set (insn)) != NULL_RTX
+	  && GET_MODE_SIZE (GET_MODE (SET_SRC (set))) <= 4
+	  && mem_ref (SET_SRC (set)) != NULL_RTX
+	  && REG_P (SET_DEST (set))
+	  && REGNO (SET_DEST (set)) < 32)
+	{
+	  /* There is no problem if the second memory access has a data
+	     dependency on the first single-cycle load.  */
+	  rtx x = SET_DEST (set);
+
+	  /* If the insn has a delay slot, then it cannot be problematic.  */
+	  next = next_active_insn (insn);
+	  if (!next)
+	    break;
+	  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)
+	    continue;
+
+	  /* Look for a second memory access to/from an integer register.  */
+	  if ((set = single_set (next)) != NULL_RTX)
+	    {
+	      rtx src = SET_SRC (set);
+	      rtx dest = SET_DEST (set);
+	      rtx mem;
+
+	      /* LDD is affected.  */
+	      if ((mem = mem_ref (src)) != NULL_RTX
+		  && REG_P (dest)
+		  && REGNO (dest) < 32
+		  && !reg_mentioned_p (x, XEXP (mem, 0)))
+		insert_nop = true;
+
+	      /* STD is *not* affected.  */
+	      else if ((mem = mem_ref (dest)) != NULL_RTX
+		       && GET_MODE_SIZE (GET_MODE (mem)) <= 4
+		       && (src == const0_rtx
+			   || (REG_P (src)
+			       && REGNO (src) < 32
+			       && REGNO (src) != REGNO (x)))
+		       && !reg_mentioned_p (x, XEXP (mem, 0)))
+		insert_nop = true;
+	    }
+	}
+
+      else
+	next = NEXT_INSN (insn);
+
+      if (insert_nop)
+	emit_insn_before (gen_nop (), next);
+    }
+
+  return 0;
+}
+
+/* Check criterias, if it doesn't match return false. save desitination
+ * register nunmber in *rd_fno
+ */
+static bool fpstore_errata_check_insn1(rtx insn, unsigned int *rd_fno, char **s)
+{
+  enum attr_type insn_type;
+  rtx set;
+  unsigned int regno;
+
+  *s = NULL;
+
+  /* Must set an FP register */
+  if (GET_CODE (insn) != INSN
+      || GET_CODE (PATTERN (insn)) == SEQUENCE
+      || (set = single_set (insn)) == NULL_RTX
+      || GET_CODE(SET_DEST (set)) != REG
+      || (regno = REGNO(SET_DEST (set))) < SPARC_FIRST_FP_REG)
+    return false;
+
+  insn_type = get_attr_type (insn);
+
+  switch (insn_type) {
+    default:
+      return false;
+    case TYPE_FPLOAD:
+      *s = "ldf";
+    case TYPE_FPMUL: /* determine if single */
+      if (GET_MODE_SIZE(GET_MODE(SET_DEST(set))) != GET_MODE_SIZE (SImode))
+        return false;
+      if (*s == NULL)
+        *s = "fpmul";
+    case TYPE_FPDIVS:
+      if (*s == NULL)
+        *s = "fpdivs";
+    case TYPE_FPSQRTS: /* always single */
+      if (*s == NULL)
+        *s = "fpsqrts";
+      break;
+    case TYPE_FP: /* can not trust SINGLE/DOUBLE for fitos and fstoi */
+      if (*s == NULL)
+        *s = "fp";
+    case TYPE_FPMOVE: /* fneg and fabs double precision is single precision */
+      if (*s == NULL)
+        *s = "fpmove";
+      break;
+  }
+
+  *rd_fno = regno;
+
+  return true;
+}
+
+/* insn is the first instruction in the possible sequence, next is the next
+ * insn object (of unknown type) to be executed.
+ */
+static void fpstore_errata_check_sequence(rtx insn, rtx next)
+{
+  unsigned int ins1_rd, ins2_rd;
+  static int cnt = 0, tot = 0, *s;
+
+  tot++;
+
+  if (fpstore_errata_debug)
+    fprintf (stderr, "fpstore: insn=%p, next=%p, insn.prev=%p, insn.next=%p\n",
+    		insn, next, PREV_INSN(insn), NEXT_INSN(insn));
+
+  s = NULL;
+  if (fpstore_errata_check_insn1(insn, &ins1_rd, &s) == false)
+    return;
+
+  if (fpstore_errata_debug)
+    fprintf (stderr, "fpstore: (%d,%d) first insn (%s) match: %u\n", tot-1, cnt, s, ins1_rd);
+
+  cnt++;
+
+  /* If not the next instruction is not real find next real insn */
+  if (!next) {
+      if (fpstore_errata_debug)
+        fprintf (stderr, "fpstore: next=NULL\n");
+      return;
+  }
+  if (!INSN_P(next)) {
+    next = next_active_insn (next);
+    if (!next) {
+      if (fpstore_errata_debug)
+        fprintf (stderr, "fpstore: step next active = NULL\n");
+      return;
+    }
+    if (fpstore_errata_debug) {
+      fprintf (stderr, "fpstore: step next active next=%p, next.prev=%p,"
+               "next.next=%p\n", next, PREV_INSN(next), NEXT_INSN(next));
+    }
+  }
+
+  if (fpstore_errata_check_insn1(next, &ins2_rd, &s) == false)
+    return;
+
+  if (fpstore_errata_debug)
+    fprintf (stderr, "fpstore: (+1) second insn (%s) match: %u\n", s, ins2_rd);
+
+  /* Allowed register numbers for second instruction must be within same
+   * double precision pair but not the same register.
+   */
+  if ((ins1_rd == ins2_rd) || ((ins1_rd & ~1) != (ins2_rd & ~1))) {
+    if (fpstore_errata_debug)
+      fprintf (stderr, "fpstore: second insn reg miss-match\n");
+    return;
+  }
+
+  /* Search for a single-precision store of same FP register as desitination of first
+   * register within the next 4 instructions
+   */
+  if (fpstore_deep_scan == 0) {
+    int i;
+    rtx curr, set;
+
+    if (fpstore_errata_debug)
+      fprintf (stderr, "fpstore: doing ds\n");
+
+    for (i = 0, curr = next; i < 4 && curr; i ++) {
+      /* Find next real instruction */
+      curr = next_active_insn (curr);
+      if (!curr)
+        break; /* close to return, we insert nop */
+
+      /* skip handling of jumps. then we insert nop */
+      if (JUMP_P(curr) || CALL_P(curr) ||
+          ((GET_CODE (curr) == INSN) && GET_CODE(PATTERN (curr)) == SEQUENCE)) {
+        if (fpstore_errata_debug)
+          fprintf (stderr, "fpstore: (+%d) ds jump found\n", 2+i);
+        if (i == 3) {
+          /* delay-slot is not part of sequence ang jump instr. is harmless */
+          if (fpstore_errata_debug)
+            fprintf (stderr, "fpstore: ds jump delay-slot never reached\n");
+          return;
+        }
+        break;
+      }
+
+      /* DEBUG: Find FP single-store (next if-statement) */
+      if (fpstore_errata_debug && NONJUMP_INSN_P(curr)
+          && get_attr_type (curr) == TYPE_FPSTORE) {
+
+        fprintf (stderr, "fpstore: (+%d) ds debug1 fpstore found\n", 2+i);
+
+        if ( (set = single_set (curr)) != NULL_RTX) {
+          fprintf (stderr, "fpstore: ds debug2 single-set != NULL\n");
+
+            if (GET_CODE(SET_SRC (set)) == REG) {
+              fprintf (stderr, "fpstore: ds debug3 OK set_src==REG\n");
+              
+              if (REGNO (SET_SRC (set)) == ins1_rd) {
+                fprintf (stderr, "fpstore: ds debug4 OK reg-match\n");
+                
+                if (GET_MODE_SIZE(GET_MODE(SET_SRC(set))) ==
+                    GET_MODE_SIZE (SImode)) {
+                fprintf (stderr, "fpstore: ds debug5 OK size.. EMIT\n");
+                } else {
+                          fprintf (stderr, "fpstore: ds debug5 size=%u (single=%u)\n",
+                               GET_MODE_SIZE(GET_MODE(SET_SRC(set))),
+                               GET_MODE_SIZE (SImode));
+                }
+
+              } else {
+                fprintf (stderr, "fpstore: ds debug4 FAIL reg-match %u\n",
+                         REGNO (SET_SRC (set)));
+              }
+
+            } else {
+              fprintf (stderr, "fpstore: ds debug3 FAIL set_src==%d\n",
+                       GET_CODE(SET_SRC (set)));
+            }
+        } else {
+	  fprintf (stderr, "fpstore: ds debug2 single-set == NULL. abort\n");
+        }
+      }
+
+      /* Find FP single-store */
+      if (NONJUMP_INSN_P(curr)
+          && get_attr_type (curr) == TYPE_FPSTORE
+          && (set = single_set (curr)) != NULL_RTX
+          && GET_CODE(SET_SRC (set)) == REG
+          && REGNO (SET_SRC (set)) == ins1_rd
+          && GET_MODE_SIZE(GET_MODE(SET_SRC(set))) == GET_MODE_SIZE (SImode)) {
+
+        if (fpstore_errata_debug)
+          fprintf (stderr, "fpstore: (+%d) ds fpstore found\n", 2+i);
+        break;
+     }
+    }
+    if (i == 4) {
+      if (fpstore_errata_debug)
+        fprintf (stderr, "fpstore: ds didn't find fpstore\n");
+      return;
+    }
+  }
+
+  /* Insert NOP between the first two instructions in the sequence */
+  emit_insn_before (gen_nop (), next);
+
+  if (fpstore_errata_debug) {
+    fprintf (stderr, "fpstore: emit NOP (n=%p,n.prev=%p,n.prev.prev=%p)\n",
+             next, PREV_INSN(next),
+             PREV_INSN(next) ? PREV_INSN(PREV_INSN(next)) : NULL);
+  }
+}
+
+/* The fpstore errata work around is run after the final split pass, this
+ * is due to movdf_insn_sp32 declaration will result in a RTL which as two
+ * fmovs, after the split pass they will appear as two fmovs and can be fixed
+ * using the below function.
+ */
+int sparc_fpstore_after_final_split (void)
+{
+  rtx insn, next, dslot;
+  static int tot = 0, scan_cnt = 0;
+  int cnt, cnt2, cnt3;
+
+  if (fpstore_errata_debug) {
+    fprintf (stderr, "fpstore: starting %d scan: bs=%d ds=%d\n", scan_cnt++,
+             fpstore_branch_slots,
+             fpstore_deep_scan);
+  }
+
+  if (fpstore_errata == 0) /* errata not enabled */
+    return 0;
+
+  /* From changes to sparc.md we know:
+   * It is avoided that LDF/FPOP is in delay slot of a call, return (jump)
+   * or sibling_call that is not relative (which we can follow and analyse
+   * easily). It is configurable (for debug) to avoid the affected from
+   * branch delay-slots, if not we must follow both taken/not-taken branch
+   * execution paths.
+   *
+   * Now look for specific patterns in the instruction stream:
+   *  1. LDF/FPOP %fX
+   *  2. LDF/FPOP %fY
+   * where X and Y is within the same double precision pair.
+   * The fix is to put a NOP instruction bettween 1. and 2.
+   */
+  cnt = cnt2 = cnt3 = 0;
+  for (insn = get_insns (); insn; insn = next)
+    {
+      if (fpstore_errata_debug) {
+        fprintf (stderr, "fpstore(%d,%d): insn %p:\n", tot, cnt, insn);
+        debug_rtx(insn);
+      }
+
+      /* Check only instructions */
+      if (NONJUMP_INSN_P (insn)) {
+
+        /* Look into the instruction in a delay slot.
+         * We cover both cases: 1. branch to label, 2. branch not taken
+         */
+        if (GET_CODE (PATTERN (insn)) == SEQUENCE) {
+
+          dslot = XVECEXP (PATTERN (insn), 0, 1);
+
+          if (fpstore_branch_slots == 0) {
+            rtx code_label, jump_insn;
+
+            /* Get Jump insn and delay-slot insn */
+            jump_insn = XVECEXP (PATTERN (insn), 0, 0);
+
+            if (JUMP_P (jump_insn)) {
+              enum attr_type jump_insn_type = get_attr_type (jump_insn);
+
+              /* Machine description makes sure there is nothing that could
+               * trigger errata in a non-branch delay-slot.. but in a branch
+               * delay-slot we must take care of what is jumped to.
+               */
+              if ((jump_insn_type == TYPE_UNCOND_BRANCH) ||
+                  (jump_insn_type == TYPE_BRANCH)) {
+                /* in branch delay-slot. Get branch destination instruction
+                 * after code label and delay-slot instruction.
+                 */
+                code_label = JUMP_LABEL(jump_insn);
+
+                if (fpstore_errata_debug)
+                  fprintf (stderr, "fpstore: in delay-slot of branch\n");
+
+                fpstore_errata_check_sequence(dslot, code_label);
+                cnt3++;
+              }
+            }
+          }
+
+          /* now handle branch not taken execution path */
+          insn = dslot;
+        }
+
+        next = NEXT_INSN (insn);
+        fpstore_errata_check_sequence(insn, next);
+        cnt2++;
+      } else
+        next = NEXT_INSN (insn);
+
+      cnt++;
+      tot++;
+    }
+
+  if (fpstore_errata_debug)
+    fprintf (stderr, "fpstore: stopping scanning, processed %d %d %d %d\n", tot, cnt, cnt2, cnt3);
+
+  return 0;
+}
+
 #include "gt-sparc.h"
